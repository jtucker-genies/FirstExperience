
//@Genies-UnityApiInterface
//@ts-nocheck
declare module 'Unity.Profiling.Memory' {
    import * as System from 'System'

    /**
    * Flags that specify what kind of data to capture in a snapshot.
    */
    enum CaptureFlags {
        ManagedObjects = 1,
        NativeObjects = 2,
        NativeAllocations = 4,
        NativeAllocationSites = 8,
        NativeStackTraces = 16 
    }

    /**
    * Container for memory snapshot metadata.
    */
    class MemorySnapshotMetadata extends System.Object {

        /**
        * User defined metadata.
        */
        public get Description(): string;
        public set Description(value: string);

        public constructor ()
    }

}

declare module 'System' {
    import * as System_Runtime_Serialization from 'System.Runtime.Serialization'
    import * as System_Reflection from 'System.Reflection'
    import * as System_Runtime_InteropServices from 'System.Runtime.InteropServices'

    interface Enum extends IFormattable, IComparable, IConvertible {

    }

    interface IFormattable {

    }

    interface IComparable {

    }

    interface IConvertible {

    }

    interface IEquatable$1<T> {

        Equals? ($other: T) : boolean
    }

    interface MulticastDelegate {
        (...args:any[]) : any; 
        Invoke?: (...args:any[]) => any;
    }
    var MulticastDelegate: { new (func: (...args:any[]) => any): MulticastDelegate; }

    interface Delegate extends ICloneable, System_Runtime_Serialization.ISerializable {

    }

    interface ICloneable {

    }

    interface IAsyncResult {

    }

    interface AsyncCallback {
        (ar: IAsyncResult) : void; 
        Invoke?: (ar: IAsyncResult) => void;
    }
    var AsyncCallback: { new (func: (ar: IAsyncResult) => void): AsyncCallback; }

    interface IntPtr extends System_Runtime_Serialization.ISerializable, IEquatable$1<IntPtr> {

    }

    interface Action$1<T> {
        (obj: T) : void; 
        Invoke?: (obj: T) => void;
    }

    interface Func$1<TResult> {
        () : TResult; 
        Invoke?: () => TResult;
    }

    interface Action {
        () : void; 
        Invoke?: () => void;
    }
    var Action: { new (func: () => void): Action; }

    interface IFormatProvider {

    }

    interface Type extends System_Reflection.IReflect, System_Runtime_InteropServices._Type {

    }

    interface IDisposable {

    }

    interface Action$2<T1,T2> {
        (arg1: T1, arg2: T2) : void; 
        Invoke?: (arg1: T1, arg2: T2) => void;
    }

    interface DateTime extends IFormattable, ISpanFormattable, IComparable, IComparable$1<DateTime>, IConvertible, System_Runtime_Serialization.ISerializable, IEquatable$1<DateTime> {

    }

    interface IComparable$1<T> {

        CompareTo? ($other: T) : int
    }

    interface Exception extends System_Runtime_InteropServices._Exception, System_Runtime_Serialization.ISerializable {

    }

    interface Nullable$1<T> {

    }

    interface SystemException {

    }

    interface Char extends IComparable, IComparable$1<number>, IConvertible, IEquatable$1<number> {

    }

}

declare module 'Unity.IO.Archive' {
    import * as System from 'System'
    import * as Unity_Jobs from 'Unity.Jobs'
    import * as UnityEngine from 'UnityEngine'
    import * as Unity_Content from 'Unity.Content'

    /**
    * Options for tracking the status of the archive operation.
    */
    enum ArchiveStatus {
        InProgress = 0,
        Complete = 1,
        Failed = 2 
    }

    /**
    * Represents information about a file included in an archive.
    */
    class ArchiveFileInfo extends System.ValueType {

        /**
        * The name of the archived file.
        */
        public Filename : string
        /**
        * The size of the archived file, in bytes.
        */
        public FileSize : bigint

    }

    /**
    * Represents an asynchronous operation handle that references an archive.
    */
    class ArchiveHandle extends System.ValueType {

        /**
        * Status of the archive mount operation.
        */
        public get Status(): ArchiveStatus;
        /**
        * JobHandle of the mount operation.
        */
        public get JobHandle(): Unity_Jobs.JobHandle;
        /**
        * The type of compression the archive uses.
        */
        public get Compression(): UnityEngine.CompressionType;
        /**
        * Indicates if the archive contains streamed blocks.
        */
        public get IsStreamed(): boolean;

        /**
        * Removes the archive from its mount point.
        * @returns Returns the JobHandle of the unmount operation.
        */
        public Unmount () : Unity_Jobs.JobHandle
        /**
        * Retrieves the path where the archive was mounted.
        * @returns Returns the path where the archive was mounted.
        */
        public GetMountPath () : string
        /**
        * Retrieves information about files included in the archive.
        * @returns Returns information about files included in the archive.
        */
        public GetFileInfo () : ArchiveFileInfo[]
    }

    /**
    * Provides methods for managing archived files.
    */
    class ArchiveFileInterface {

        /**
        * Loads all files in an archive to a mount point.
        * @param namespaceId ContentNamespace identifier.
        * @param filePath Path of the archive on disk.
        * @param prefix Mount point identifier. Set to an empty string if no prefix should be used.
        * @returns Returns an operation handle that references the archive.
        */
        public static MountAsync ($namespaceId: Unity_Content.ContentNamespace, $filePath: string, $prefix: string) : ArchiveHandle
        /**
        * Retrieves all mounted archives.
        * @param namespaceId ContentNamespace identifier.
        * @returns Returns operation handles that reference mounted archives.
        */
        public static GetMountedArchives ($namespaceId: Unity_Content.ContentNamespace) : ArchiveHandle[]
    }

}

declare module 'Unity.Jobs' {
    import * as System from 'System'

    /**
    * A handle to a job, which uniquely identifies a job scheduled in the job system.
    */
    interface JobHandle extends System.IEquatable$1<JobHandle> {

    }

}

declare module 'UnityEngine' {
    import * as System from 'System'
    import * as UnityEngine_SortingLayer from 'UnityEngine.SortingLayer'
    import * as UnityEngine_Application from 'UnityEngine.Application'
    import * as UnityEngine_Events from 'UnityEngine.Events'
    import * as System_Threading from 'System.Threading'
    import * as UnityEngine_Camera from 'UnityEngine.Camera'
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering'
    import * as System_Collections_Generic from 'System.Collections.Generic'
    import * as UnityEngine_SceneManagement from 'UnityEngine.SceneManagement'
    import * as System_Collections from 'System.Collections'
    import * as Unity_Collections from 'Unity.Collections'
    import * as UnityEngine_Experimental_Rendering from 'UnityEngine.Experimental.Rendering'
    import * as UnityEngine_GraphicsBuffer from 'UnityEngine.GraphicsBuffer'
    import * as UnityEngine_Mesh from 'UnityEngine.Mesh'
    import * as UnityEngine_ReflectionProbe from 'UnityEngine.ReflectionProbe'
    import * as UnityEngine_RectInt from 'UnityEngine.RectInt'
    import * as UnityEngine_CullingGroup from 'UnityEngine.CullingGroup'
    import * as UnityEngine_BoundsInt from 'UnityEngine.BoundsInt'
    import * as UnityEngine_Display from 'UnityEngine.Display'
    import * as Unity_Jobs from 'Unity.Jobs'
    import * as UnityEngine_LightProbeProxyVolume from 'UnityEngine.LightProbeProxyVolume'
    import * as UnityEngine_Random from 'UnityEngine.Random'
    import * as UnityEngine_ShaderVariantCollection from 'UnityEngine.ShaderVariantCollection'
    import * as UnityEngine_TouchScreenKeyboard from 'UnityEngine.TouchScreenKeyboard'
    import * as UnityEngine_RectTransform from 'UnityEngine.RectTransform'
    import * as UnityEngine_U2D from 'UnityEngine.U2D'

    /**
    * Compression Method for Asset Bundles.
    */
    enum CompressionType {
        None = 0,
        Lzma = 1,
        Lz4 = 2,
        Lz4HC = 3 
    }

    /**
    * SortingLayer allows you to set the render order of multiple sprites easily. There is always a default SortingLayer named "Default" which all sprites are added to initially. Added more SortingLayers to easily control the order of rendering of groups of sprites. Layers can be ordered before or after the default layer.
    */
    class SortingLayer extends System.ValueType {

        /**
        * Delegate for sorting layer events when a layer is added.
        */
        public static onLayerAdded : UnityEngine_SortingLayer.LayerCallback
        /**
        * Delegate for sorting layer events when a layer is removed.
        */
        public static onLayerRemoved : UnityEngine_SortingLayer.LayerCallback
        /**
        * This is the unique id assigned to the layer. It is not an ordered running value and it should not be used to compare with other layers to determine the sorting order.
        */
        public get id(): int;
        /**
        * Returns the name of the layer as defined in the TagManager.
        */
        public get name(): string;
        /**
        * This is the relative value that indicates the sort order of this layer relative to the other layers.
        */
        public get value(): int;
        /**
        * Returns all the layers defined in this project.
        */
        public static get layers(): SortingLayer[];

        /**
        * Returns the final sorting layer value. To determine the sorting order between the various sorting layers, use this method to retrieve the final sorting value and use CompareTo to determine the order.
        * @param id The unique value of the sorting layer as returned by any renderer's sortingLayerID property.
        * @returns The final sorting value of the layer relative to other layers.
        */
        public static GetLayerValueFromID ($id: int) : int
        /**
        * Returns the final sorting layer value. Additional resources: GetLayerValueFromID.
        * @param name The unique value of the sorting layer as returned by any renderer's sortingLayerID property.
        * @returns The final sorting value of the layer relative to other layers.
        */
        public static GetLayerValueFromName ($name: string) : int
        /**
        * Returns the id given the name. Will return 0 if an invalid name was given.
        * @param name The name of the layer.
        * @returns Returns the unique id of the layer with name.
        */
        public static NameToID ($name: string) : int
        /**
        * Returns the unique id of the layer. Will return "<unknown layer>" if an invalid id is given.
        * @param id The unique id of the layer.
        * @returns The name of the layer with id or "<unknown layer>" for invalid id.
        */
        public static IDToName ($id: int) : string
        /**
        * Returns true if the id provided is a valid layer id.
        * @param id The unique id of a layer.
        * @returns True if the id provided is valid and assigned to a layer.
        */
        public static IsValid ($id: int) : boolean
    }

    /**
    * Sets which weights to use when calculating curve segments.
    */
    enum WeightedMode {
        None = 0,
        In = 1,
        Out = 2,
        Both = 3 
    }

    /**
    * A single keyframe that can be injected into an animation curve.
    */
    class Keyframe extends System.ValueType {

        /**
        * The time of the keyframe.
        */
        public get time(): float;
        public set time(value: float);
        /**
        * The value of the curve at keyframe.
        */
        public get value(): float;
        public set value(value: float);
        /**
        * Sets the incoming tangent for this key. The incoming tangent affects the slope of the curve from the previous key to this key.
        */
        public get inTangent(): float;
        public set inTangent(value: float);
        /**
        * Sets the outgoing tangent for this key. The outgoing tangent affects the slope of the curve from this key to the next key.
        */
        public get outTangent(): float;
        public set outTangent(value: float);
        /**
        * Sets the incoming weight for this key. The incoming weight affects the slope of the curve from the previous key to this key.
        */
        public get inWeight(): float;
        public set inWeight(value: float);
        /**
        * Sets the outgoing weight for this key. The outgoing weight affects the slope of the curve from this key to the next key.
        */
        public get outWeight(): float;
        public set outWeight(value: float);
        /**
        * Weighted mode for the keyframe.
        */
        public get weightedMode(): WeightedMode;
        public set weightedMode(value: WeightedMode);

        /**
        * Create a keyframe.
        */
        public constructor ($time: float, $value: float)
        /**
        * Create a keyframe.
        */
        public constructor ($time: float, $value: float, $inTangent: float, $outTangent: float)
        /**
        * Create a keyframe.
        */
        public constructor ($time: float, $value: float, $inTangent: float, $outTangent: float, $inWeight: float, $outWeight: float)
    }

    /**
    * Determines how time is treated outside of the keyframed range of an AnimationClip or AnimationCurve.
    */
    enum WrapMode {
        Once = 1,
        Loop = 2,
        PingPong = 4,
        Default = 0,
        ClampForever = 8,
        Clamp = 1 
    }

    /**
    * Store a collection of Keyframes that can be evaluated over time.
    */
    class AnimationCurve extends System.Object implements System.IEquatable$1<AnimationCurve> {

        /**
        * All keys defined in the animation curve.
        */
        public get keys(): Keyframe[];
        public set keys(value: Keyframe[]);
        /**
        * The number of keys in the curve. (Read Only)
        */
        public get length(): int;
        /**
        * The behaviour of the animation before the first keyframe.
        */
        public get preWrapMode(): WrapMode;
        public set preWrapMode(value: WrapMode);
        /**
        * The behaviour of the animation after the last keyframe.
        */
        public get postWrapMode(): WrapMode;
        public set postWrapMode(value: WrapMode);

        /**
        * Creates an animation curve from an arbitrary number of keyframes.
        * @param keys An array of Keyframes used to define the curve.
        */
        public constructor (...keys: Keyframe[])
        /**
        * Creates an empty animation curve.
        */
        public constructor ()
        /**
        * Evaluate the curve at time.
        * @param time The time within the curve you want to evaluate (the horizontal axis in the curve graph).
        * @returns The value of the curve, at the point in time specified.
        */
        public Evaluate ($time: float) : float
        /**
        * Add a new key to the curve.
        * @param time The time at which to add the key (horizontal axis in the curve graph).
        * @param value The value for the key (vertical axis in the curve graph).
        * @returns The index of the added key, or -1 if the key could not be added.
        * @methodSwap AddKey_EBB7509C_H1075CF37
        */
        public AddKey ($time: float, $value: float) : int
        /**
        * Add a new key to the curve.
        * @param key The key to add to the curve.
        * @returns The index of the added key, or -1 if the key could not be added.
        */
        public AddKey ($key: Keyframe) : int
        /**
        * Moves the key at index to key.time and key.value.
        * @param index The index of the key to move.
        * @param key The keyframe containing the new time and value.
        * @returns The index of the keyframe after moving it.
        */
        public MoveKey ($index: int, $key: Keyframe) : int
        /**
        * Erases all KeyFrame from this instance of the AnimationCurve.
        */
        public ClearKeys () : void
        /**
        * Removes a key.
        * @param index The index of the key to remove.
        */
        public RemoveKey ($index: int) : void
        /**
        * A HashCode for the animation curve, computed using all individual Keyframe.
        * @returns A HashCode.
        */
        public GetHashCode () : int
        /**
        * Smooth the in and out tangents of the keyframe at index.
        * @param index The index of the keyframe to be smoothed.
        * @param weight The smoothing weight to apply to the keyframe's tangents.
        */
        public SmoothTangents ($index: int, $weight: float) : void
        /**
        * Creates a constant "curve" starting at timeStart, ending at timeEnd, and set to the value value.
        * @param timeStart The start time for the constant curve.
        * @param timeEnd The end time for the constant curve.
        * @param value The value for the constant curve.
        * @returns The constant curve created from the specified values.
        */
        public static Constant ($timeStart: float, $timeEnd: float, $value: float) : AnimationCurve
        /**
        * A straight Line starting at timeStart, valueStart and ending at timeEnd, valueEnd.
        * @param timeStart The start time for the linear curve.
        * @param valueStart The start value for the linear curve.
        * @param timeEnd The end time for the linear curve.
        * @param valueEnd The end value for the linear curve.
        * @returns The linear curve created from the specified values.
        */
        public static Linear ($timeStart: float, $valueStart: float, $timeEnd: float, $valueEnd: float) : AnimationCurve
        /**
        * Creates an ease-in and out curve starting at timeStart, valueStart and ending at timeEnd, valueEnd.
        * @param timeStart The start time for the ease curve.
        * @param valueStart The start value for the ease curve.
        * @param timeEnd The end time for the ease curve.
        * @param valueEnd The end value for the ease curve.
        * @returns The ease-in and out curve generated from the specified values.
        */
        public static EaseInOut ($timeStart: float, $valueStart: float, $timeEnd: float, $valueEnd: float) : AnimationCurve
        public Equals ($o: any) : boolean
        public Equals ($other: AnimationCurve) : boolean
        /**
        * Copies the keys and properties of the specified AnimationCurve object into this instance of the  AnimationCurve class.
        * @param other The AnimationCurve object to obtain the values to copy.
        */
        public CopyFrom ($other: AnimationCurve) : void
        public get_Item ($index: int) : Keyframe
    }

    /**
    * Access to application runtime data.
    */
    class Application extends System.Object {

        /**
        * Returns true when called in any kind of built Player, or when called in the Editor in Play mode (Read Only).
        */
        public static get isPlaying(): boolean;
        /**
        * Whether the Player currently has focus (Read-only).
        */
        public static get isFocused(): boolean;
        /**
        * Returns true when Unity is launched with the -batchmode flag from the command line (Read Only).
        */
        public static get isBatchMode(): boolean;
        /**
        * The URL of the document. For WebGL, this is a web URL. For Android, iOS, or Universal Windows Platform (UWP) this is a deep link URL (Read Only).
        */
        public static get absoluteURL(): string;
        /**
        * The version of the Unity runtime used to play the content.
        */
        public static get unityVersion(): string;
        /**
        * Returns application version number  (Read Only).
        */
        public static get version(): string;
        /**
        * Specifies the frame rate at which Unity tries to render your game.
        */
        public static get targetFrameRate(): int;
        public static set targetFrameRate(value: int);
        /**
        * Returns the platform the game is running on (Read Only).
        */
        public static get platform(): RuntimePlatform;
        /**
        * Identifies whether the current Runtime platform is a known mobile platform.
        */
        public static get isMobilePlatform(): boolean;
        /**
        * Is the current Runtime platform a known console platform.
        */
        public static get isConsolePlatform(): boolean;
        /**
        * The language the user's operating system is running in.
        */
        public static get systemLanguage(): SystemLanguage;
        /**
        * Returns the type of internet reachability currently possible on the device.
        */
        public static get internetReachability(): NetworkReachability;
        /**
        * Cancellation token raised on exiting Play mode (Editor) or on quitting the application (Read Only).
        */
        public static get exitCancellationToken(): System_Threading.CancellationToken;
        /**
        * Whether the game is running inside the Unity Editor (Read Only).
        */
        public static get isEditor(): boolean;

        public constructor ()
        /**
        * Unloads the Unity Player.
        */
        public static Unload () : void
        /**
        * Opens the URL specified, subject to the permissions and limitations of your app’s current platform and environment.
        * @param url The URL to open.
        */
        public static OpenURL ($url: string) : void
        public static add_lowMemory ($value: UnityEngine_Application.LowMemoryCallback) : void
        public static add_memoryUsageChanged ($value: UnityEngine_Application.MemoryUsageChangedCallback) : void
        public static add_logMessageReceived ($value: UnityEngine_Application.LogCallback) : void
        public static add_logMessageReceivedThreaded ($value: UnityEngine_Application.LogCallback) : void
        public static add_onBeforeRender ($value: UnityEngine_Events.UnityAction) : void
        public static add_focusChanged ($value: System.Action$1<boolean>) : void
        public static add_deepLinkActivated ($value: System.Action$1<string>) : void
        public static add_wantsToQuit ($value: System.Func$1<boolean>) : void
        public static add_quitting ($value: System.Action) : void
        public static add_unloading ($value: System.Action) : void
        public static remove_lowMemory ($value: UnityEngine_Application.LowMemoryCallback) : void
        public static remove_memoryUsageChanged ($value: UnityEngine_Application.MemoryUsageChangedCallback) : void
        public static remove_logMessageReceived ($value: UnityEngine_Application.LogCallback) : void
        public static remove_logMessageReceivedThreaded ($value: UnityEngine_Application.LogCallback) : void
        public static remove_onBeforeRender ($value: UnityEngine_Events.UnityAction) : void
        public static remove_focusChanged ($value: System.Action$1<boolean>) : void
        public static remove_deepLinkActivated ($value: System.Action$1<string>) : void
        public static remove_wantsToQuit ($value: System.Func$1<boolean>) : void
        public static remove_quitting ($value: System.Action) : void
        public static remove_unloading ($value: System.Action) : void
    }

    /**
    * The platform application is running. Returned by Application.platform.
    */
    enum RuntimePlatform {
        OSXEditor = 0,
        OSXPlayer = 1,
        WindowsPlayer = 2,
        OSXWebPlayer = 3,
        OSXDashboardPlayer = 4,
        WindowsWebPlayer = 5,
        WindowsEditor = 7,
        IPhonePlayer = 8,
        XBOX360 = 10,
        PS3 = 9,
        Android = 11,
        NaCl = 12,
        FlashPlayer = 15,
        LinuxPlayer = 13,
        LinuxEditor = 16,
        WebGLPlayer = 17,
        MetroPlayerX86 = 18,
        WSAPlayerX86 = 18,
        MetroPlayerX64 = 19,
        WSAPlayerX64 = 19,
        MetroPlayerARM = 20,
        WSAPlayerARM = 20,
        WP8Player = 21,
        BB10Player = 22,
        BlackBerryPlayer = 22,
        TizenPlayer = 23,
        PSP2 = 24,
        PS4 = 25,
        PSM = 26,
        XboxOne = 27,
        SamsungTVPlayer = 28,
        WiiU = 30,
        tvOS = 31,
        Switch = 32,
        Lumin = 33,
        Stadia = 34,
        CloudRendering = 35,
        GameCoreScarlett = -1,
        GameCoreXboxSeries = 36,
        GameCoreXboxOne = 37,
        PS5 = 38,
        EmbeddedLinuxArm64 = 39,
        EmbeddedLinuxArm32 = 40,
        EmbeddedLinuxX64 = 41,
        EmbeddedLinuxX86 = 42,
        LinuxServer = 43,
        WindowsServer = 44,
        OSXServer = 45,
        QNXArm32 = 46,
        QNXArm64 = 47,
        QNXX64 = 48,
        QNXX86 = 49,
        VisionOS = 50 
    }

    /**
    * The language the user's operating system is running in. Returned by Application.systemLanguage.
    */
    enum SystemLanguage {
        Afrikaans = 0,
        Arabic = 1,
        Basque = 2,
        Belarusian = 3,
        Bulgarian = 4,
        Catalan = 5,
        Chinese = 6,
        Czech = 7,
        Danish = 8,
        Dutch = 9,
        English = 10,
        Estonian = 11,
        Faroese = 12,
        Finnish = 13,
        French = 14,
        German = 15,
        Greek = 16,
        Hebrew = 17,
        Hugarian = 18,
        Icelandic = 19,
        Indonesian = 20,
        Italian = 21,
        Japanese = 22,
        Korean = 23,
        Latvian = 24,
        Lithuanian = 25,
        Norwegian = 26,
        Polish = 27,
        Portuguese = 28,
        Romanian = 29,
        Russian = 30,
        SerboCroatian = 31,
        Slovak = 32,
        Slovenian = 33,
        Spanish = 34,
        Swedish = 35,
        Thai = 36,
        Turkish = 37,
        Ukrainian = 38,
        Vietnamese = 39,
        ChineseSimplified = 40,
        ChineseTraditional = 41,
        Hindi = 42,
        Unknown = 43,
        Hungarian = 18 
    }

    /**
    * Describes network reachability options.
    */
    enum NetworkReachability {
        NotReachable = 0,
        ReachableViaCarrierDataNetwork = 1,
        ReachableViaLocalAreaNetwork = 2 
    }

    /**
    * Contains information about a change in the application's memory usage.
    */
    class ApplicationMemoryUsageChange extends System.ValueType {

        /**
        * The memory usage level for the application.
        */
        public get memoryUsage(): ApplicationMemoryUsage;

        public constructor ($usage: ApplicationMemoryUsage)
    }

    /**
    * Describes the application memory usage level.
    */
    enum ApplicationMemoryUsage {
        Unknown = 0,
        Low = 1,
        Medium = 2,
        High = 3,
        Critical = 4 
    }

    /**
    * The type of the log message in Debug.unityLogger.Log or delegate registered with Application.RegisterLogCallback.
    */
    enum LogType {
        Error = 0,
        Assert = 1,
        Warning = 2,
        Log = 3,
        Exception = 4 
    }

    /**
    * Stack trace logging options.
    */
    enum StackTraceLogType {
        None = 0,
        ScriptOnly = 1,
        Full = 2 
    }

    /**
    * Constants to pass to Application.RequestUserAuthorization.
    */
    enum UserAuthorization {
        WebCam = 1,
        Microphone = 2 
    }

    /**
    * Application installation mode (Read Only).
    */
    enum ApplicationInstallMode {
        Unknown = 0,
        Store = 1,
        DeveloperBuild = 2,
        Adhoc = 3,
        Enterprise = 4,
        Editor = 5 
    }

    /**
    * Application sandbox type.
    */
    enum ApplicationSandboxType {
        Unknown = 0,
        NotSandboxed = 1,
        Sandboxed = 2,
        SandboxBroken = 3 
    }

    /**
    * Type of the imported(native) data.
    */
    enum AudioType {
        UNKNOWN = 0,
        ACC = 1,
        AIFF = 2,
        IT = 10,
        MOD = 12,
        MPEG = 13,
        OGGVORBIS = 14,
        S3M = 17,
        WAV = 20,
        XM = 21,
        XMA = 22,
        VAG = 23,
        AUDIOQUEUE = 24 
    }

    /**
    * The various primitives that can be created using the GameObject.CreatePrimitive function.
    */
    enum PrimitiveType {
        Sphere = 0,
        Capsule = 1,
        Cylinder = 2,
        Cube = 3,
        Plane = 4,
        Quad = 5 
    }

    /**
    * The coordinate space in which to operate.
    */
    enum Space {
        World = 0,
        Self = 1 
    }

    /**
    * Option flags for specifying special treatment of a log message.
    */
    enum LogOption {
        None = 0,
        NoStacktrace = 1 
    }

    /**
    * Priority of a thread.
    */
    enum ThreadPriority {
        Low = 0,
        BelowNormal = 1,
        Normal = 2,
        High = 4 
    }

    /**
    * A Camera is a device through which the player views the world.
    */
    class Camera extends Behaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;
        /**
        * The minimum allowed aperture.
        */
        public static kMinAperture : float
        /**
        * The maximum allowed aperture.
        */
        public static kMaxAperture : float
        /**
        * The minimum blade count for the aperture diaphragm.
        */
        public static kMinBladeCount : int
        /**
        * The maximum blade count for the aperture diaphragm.
        */
        public static kMaxBladeCount : int
        /**
        * Delegate that you can use to execute custom code before a Camera culls the scene.
        */
        public static onPreCull : UnityEngine_Camera.CameraCallback
        /**
        * Delegate that you can use to execute custom code before a Camera renders the scene.
        */
        public static onPreRender : UnityEngine_Camera.CameraCallback
        /**
        * Delegate that you can use to execute custom code after a Camera renders the scene.
        */
        public static onPostRender : UnityEngine_Camera.CameraCallback
        /**
        * The distance of the near clipping plane from the the Camera, in world units.
        */
        public get nearClipPlane(): float;
        public set nearClipPlane(value: float);
        /**
        * The distance of the far clipping plane from the Camera, in world units.
        */
        public get farClipPlane(): float;
        public set farClipPlane(value: float);
        /**
        * The vertical field of view of the Camera, in degrees.
        */
        public get fieldOfView(): float;
        public set fieldOfView(value: float);
        /**
        * The rendering path that should be used, if possible.
        */
        public get renderingPath(): RenderingPath;
        public set renderingPath(value: RenderingPath);
        /**
        * The rendering path that is currently being used (Read Only).
        */
        public get actualRenderingPath(): RenderingPath;
        /**
        * High dynamic range rendering.
        */
        public get allowHDR(): boolean;
        public set allowHDR(value: boolean);
        /**
        * MSAA rendering.
        */
        public get allowMSAA(): boolean;
        public set allowMSAA(value: boolean);
        /**
        * Dynamic Resolution Scaling.
        */
        public get allowDynamicResolution(): boolean;
        public set allowDynamicResolution(value: boolean);
        /**
        * Should camera rendering be forced into a RenderTexture.
        */
        public get forceIntoRenderTexture(): boolean;
        public set forceIntoRenderTexture(value: boolean);
        /**
        * Camera's half-size when in orthographic mode.
        */
        public get orthographicSize(): float;
        public set orthographicSize(value: float);
        /**
        * Is the camera orthographic (true) or perspective (false)?
        */
        public get orthographic(): boolean;
        public set orthographic(value: boolean);
        /**
        * Opaque object sorting mode.
        */
        public get opaqueSortMode(): UnityEngine_Rendering.OpaqueSortMode;
        public set opaqueSortMode(value: UnityEngine_Rendering.OpaqueSortMode);
        /**
        * Transparent object sorting mode.
        */
        public get transparencySortMode(): TransparencySortMode;
        public set transparencySortMode(value: TransparencySortMode);
        /**
        * An axis that describes the direction along which the distances of objects are measured for the purpose of sorting.
        */
        public get transparencySortAxis(): Vector3;
        public set transparencySortAxis(value: Vector3);
        /**
        * Camera's depth in the camera rendering order.
        */
        public get depth(): float;
        public set depth(value: float);
        /**
        * The aspect ratio (width divided by height).
        */
        public get aspect(): float;
        public set aspect(value: float);
        /**
        * Get the world-space speed of the camera (Read Only).
        */
        public get velocity(): Vector3;
        /**
        * This is used to render parts of the Scene selectively.
        */
        public get cullingMask(): int;
        public set cullingMask(value: int);
        /**
        * Mask to select which layers can trigger events on the camera.
        */
        public get eventMask(): int;
        public set eventMask(value: int);
        /**
        * How to perform per-layer culling for a Camera.
        */
        public get layerCullSpherical(): boolean;
        public set layerCullSpherical(value: boolean);
        /**
        * Identifies what kind of camera this is, using the CameraType enum.
        */
        public get cameraType(): CameraType;
        public set cameraType(value: CameraType);
        /**
        * Sets the culling mask used to determine which objects from which Scenes to draw.
        * See EditorSceneManager.SetSceneCullingMask.
        */
        public get overrideSceneCullingMask(): bigint;
        public set overrideSceneCullingMask(value: bigint);
        /**
        * Per-layer culling distances.
        */
        public get layerCullDistances(): float[];
        public set layerCullDistances(value: float[]);
        /**
        * Whether or not the Camera will use occlusion culling during rendering.
        */
        public get useOcclusionCulling(): boolean;
        public set useOcclusionCulling(value: boolean);
        /**
        * Sets a custom matrix for the camera to use for all culling queries.
        */
        public get cullingMatrix(): Matrix4x4;
        public set cullingMatrix(value: Matrix4x4);
        /**
        * The color with which the screen will be cleared.
        */
        public get backgroundColor(): Color;
        public set backgroundColor(value: Color);
        /**
        * How the camera clears the background.
        */
        public get clearFlags(): CameraClearFlags;
        public set clearFlags(value: CameraClearFlags);
        /**
        * How and if camera generates a depth texture.
        */
        public get depthTextureMode(): DepthTextureMode;
        public set depthTextureMode(value: DepthTextureMode);
        /**
        * Should the camera clear the stencil buffer after the deferred light pass?
        */
        public get clearStencilAfterLightingPass(): boolean;
        public set clearStencilAfterLightingPass(value: boolean);
        /**
        * Enable usePhysicalProperties to use physical camera properties to compute the field of view and the frustum.
        */
        public get usePhysicalProperties(): boolean;
        public set usePhysicalProperties(value: boolean);
        /**
        * The sensor sensitivity of the camera. To use this property, enable UsePhysicalProperties.
        */
        public get iso(): int;
        public set iso(value: int);
        /**
        * The exposure time of the camera, in seconts. To use this property, enable UsePhysicalProperties.
        */
        public get shutterSpeed(): float;
        public set shutterSpeed(value: float);
        /**
        * The camera aperture. To use this property, enable UsePhysicalProperties.
        */
        public get aperture(): float;
        public set aperture(value: float);
        /**
        * The focus distance of the lens. To use this property, enable UsePhysicalProperties.
        */
        public get focusDistance(): float;
        public set focusDistance(value: float);
        /**
        * The camera focal length, expressed in millimeters. To use this property, enable UsePhysicalProperties.
        */
        public get focalLength(): float;
        public set focalLength(value: float);
        /**
        * The blade count in the lens of the camera. To use this property, enable UsePhysicalProperties.
        */
        public get bladeCount(): int;
        public set bladeCount(value: int);
        /**
        * The curvature of the blades. To use this property, enable UsePhysicalProperties.
        */
        public get curvature(): Vector2;
        public set curvature(value: Vector2);
        /**
        * The camera barrel clipping. To use this property, enable UsePhysicalProperties.
        */
        public get barrelClipping(): float;
        public set barrelClipping(value: float);
        /**
        * The camera anamorphism. To use this property, enable UsePhysicalProperties.
        */
        public get anamorphism(): float;
        public set anamorphism(value: float);
        /**
        * The size of the camera sensor, expressed in millimeters.
        */
        public get sensorSize(): Vector2;
        public set sensorSize(value: Vector2);
        /**
        * The lens offset of the camera. The lens shift is relative to the sensor size. For example, a lens shift of 0.5 offsets the sensor by half its horizontal size.
        */
        public get lensShift(): Vector2;
        public set lensShift(value: Vector2);
        /**
        * There are two gates for a camera, the sensor gate and the resolution gate. The physical camera sensor gate is defined by the sensorSize property, the resolution gate is defined by the render target area.
        */
        public get gateFit(): UnityEngine_Camera.GateFitMode;
        public set gateFit(value: UnityEngine_Camera.GateFitMode);
        /**
        * Where on the screen is the camera rendered in normalized coordinates.
        */
        public get rect(): Rect;
        public set rect(value: Rect);
        /**
        * Where on the screen is the camera rendered in pixel coordinates.
        */
        public get pixelRect(): Rect;
        public set pixelRect(value: Rect);
        /**
        * How wide is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
        */
        public get pixelWidth(): int;
        /**
        * How tall is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
        */
        public get pixelHeight(): int;
        /**
        * How wide is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
        */
        public get scaledPixelWidth(): int;
        /**
        * How tall is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
        */
        public get scaledPixelHeight(): int;
        /**
        * Destination render texture.
        */
        public get targetTexture(): RenderTexture;
        public set targetTexture(value: RenderTexture);
        /**
        * Gets the temporary RenderTexture target for this Camera.
        */
        public get activeTexture(): RenderTexture;
        /**
        * Set the target display for this Camera.
        */
        public get targetDisplay(): int;
        public set targetDisplay(value: int);
        /**
        * Matrix that transforms from camera space to world space (Read Only).
        */
        public get cameraToWorldMatrix(): Matrix4x4;
        /**
        * Matrix that transforms from world to camera space.
        */
        public get worldToCameraMatrix(): Matrix4x4;
        public set worldToCameraMatrix(value: Matrix4x4);
        /**
        * Set a custom projection matrix.
        */
        public get projectionMatrix(): Matrix4x4;
        public set projectionMatrix(value: Matrix4x4);
        /**
        * Get or set the raw projection matrix with no camera offset (no jittering).
        */
        public get nonJitteredProjectionMatrix(): Matrix4x4;
        public set nonJitteredProjectionMatrix(value: Matrix4x4);
        /**
        * Should the jittered matrix be used for transparency rendering?
        */
        public get useJitteredProjectionMatrixForTransparentRendering(): boolean;
        public set useJitteredProjectionMatrixForTransparentRendering(value: boolean);
        /**
        * Get the view projection matrix used on the last frame.
        */
        public get previousViewProjectionMatrix(): Matrix4x4;
        /**
        * The first enabled Camera component that is tagged "MainCamera" (Read Only).
        */
        public static get main(): Camera;
        /**
        * The camera we are currently rendering with, for low-level render control only (Read Only).
        */
        public static get current(): Camera;
        /**
        * If not null, the camera will only render the contents of the specified Scene.
        */
        public get scene(): UnityEngine_SceneManagement.Scene;
        public set scene(value: UnityEngine_SceneManagement.Scene);
        /**
        * Stereoscopic rendering.
        */
        public get stereoEnabled(): boolean;
        /**
        * The distance between the virtual eyes. Use this to query or set the current eye separation. Note that most VR devices provide this value, in which case setting the value will have no effect.
        */
        public get stereoSeparation(): float;
        public set stereoSeparation(value: float);
        /**
        * Distance to a point where virtual eyes converge.
        */
        public get stereoConvergence(): float;
        public set stereoConvergence(value: float);
        /**
        * Determines whether the stereo view matrices are suitable to allow for a single pass cull.
        */
        public get areVRStereoViewMatricesWithinSingleCullTolerance(): boolean;
        /**
        * Defines which eye of a VR display the Camera renders into.
        */
        public get stereoTargetEye(): StereoTargetEyeMask;
        public set stereoTargetEye(value: StereoTargetEyeMask);
        /**
        * Returns the eye that is currently rendering.
        * If called when stereo is not enabled it will return Camera.MonoOrStereoscopicEye.Mono.
        * If called during a camera rendering callback such as OnRenderImage it will return the currently rendering eye.
        * If called outside of a rendering callback and stereo is enabled, it will return the default eye which is Camera.MonoOrStereoscopicEye.Left.
        */
        public get stereoActiveEye(): UnityEngine_Camera.MonoOrStereoscopicEye;
        /**
        * The number of cameras in the current Scene.
        */
        public static get allCamerasCount(): int;
        /**
        * Returns all enabled cameras in the Scene.
        */
        public static get allCameras(): Camera[];
        public get sceneViewFilterMode(): UnityEngine_Camera.SceneViewFilterMode;
        /**
        * Number of command buffers set up on this camera (Read Only).
        */
        public get commandBufferCount(): int;

        private constructor ()
        /**
        * Revert all camera parameters to default.
        */
        public Reset () : void
        /**
        * Resets this Camera's transparency sort settings to the default. Default transparency settings are taken from GraphicsSettings instead of directly from this Camera.
        */
        public ResetTransparencySortSettings () : void
        /**
        * Revert the aspect ratio to the screen's aspect ratio.
        */
        public ResetAspect () : void
        /**
        * Make culling queries reflect the camera's built in parameters.
        */
        public ResetCullingMatrix () : void
        /**
        * Make the camera render with shader replacement.
        */
        public SetReplacementShader ($shader: Shader, $replacementTag: string) : void
        /**
        * Remove shader replacement from camera.
        */
        public ResetReplacementShader () : void
        /**
        * Retrieves the effective vertical field of view of the camera, including GateFit.
        * Fitting the sensor gate and the resolution gate has an impact on the final field of view. If the sensor gate aspect ratio is the same as the resolution gate aspect ratio or if the camera is not in physical mode, then this method returns the same value as the fieldofview property.
        * @returns Returns the effective vertical field of view.
        */
        public GetGateFittedFieldOfView () : float
        /**
        * Retrieves the effective lens offset of the camera, including GateFit.
        * Fitting the sensor gate and the resolution gate has an impact on the final obliqueness of the projection. If the sensor gate aspect ratio is the same as the resolution gate aspect ratio, then this method returns the same value as the lenshift property. If the camera is not in physical mode, then this methods returns Vector2.zero.
        * @returns Returns the effective lens shift value.
        */
        public GetGateFittedLensShift () : Vector2
        /**
        * Sets the Camera to render to the chosen buffers of one or more RenderTextures.
        * @param colorBuffer The RenderBuffer(s) to which color information will be rendered.
        * @param depthBuffer The RenderBuffer to which depth information will be rendered.
        */
        public SetTargetBuffers ($colorBuffer: RenderBuffer, $depthBuffer: RenderBuffer) : void
        /**
        * Sets the Camera to render to the chosen buffers of one or more RenderTextures.
        * @param colorBuffer The RenderBuffer(s) to which color information will be rendered.
        * @param depthBuffer The RenderBuffer to which depth information will be rendered.
        */
        public SetTargetBuffers ($colorBuffer: RenderBuffer[], $depthBuffer: RenderBuffer) : void
        /**
        * Make the rendering position reflect the camera's position in the Scene.
        */
        public ResetWorldToCameraMatrix () : void
        /**
        * Make the projection reflect normal camera's parameters.
        */
        public ResetProjectionMatrix () : void
        /**
        * Calculates and returns oblique near-plane projection matrix.
        * @param clipPlane Vector4 that describes a clip plane.
        * @returns Oblique near-plane projection matrix.
        */
        public CalculateObliqueMatrix ($clipPlane: Vector4) : Matrix4x4
        /**
        * Transforms position from world space into screen space.
        * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
        */
        public WorldToScreenPoint ($position: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye) : Vector3
        /**
        * Transforms position from world space into viewport space.
        * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
        */
        public WorldToViewportPoint ($position: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye) : Vector3
        public ViewportToWorldPoint ($position: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye) : Vector3
        /**
        * Transforms a point from screen space into world space, where world space is defined as the coordinate system at the very top of your game's hierarchy.
        * @param position A screen space position (often mouse x, y), plus a z position for depth (for example, a camera clipping plane).
        * @param eye By default, Camera.MonoOrStereoscopicEye.Mono. Can be set to Camera.MonoOrStereoscopicEye.Left or Camera.MonoOrStereoscopicEye.Right for use in stereoscopic rendering (e.g., for VR).
        * @returns The worldspace point created by converting the screen space point at the provided distance z from the camera plane.
        */
        public ScreenToWorldPoint ($position: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye) : Vector3
        /**
        * Transforms position from world space into screen space.
        * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
        */
        public WorldToScreenPoint ($position: Vector3) : Vector3
        /**
        * Transforms position from world space into viewport space.
        * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
        */
        public WorldToViewportPoint ($position: Vector3) : Vector3
        /**
        * Transforms position from viewport space into world space.
        * @param position The 3d vector in Viewport space.
        * @returns The 3d vector in World space.
        */
        public ViewportToWorldPoint ($position: Vector3) : Vector3
        /**
        * Transforms a point from screen space into world space, where world space is defined as the coordinate system at the very top of your game's hierarchy.
        * @param position A screen space position (often mouse x, y), plus a z position for depth (for example, a camera clipping plane).
        * @param eye By default, Camera.MonoOrStereoscopicEye.Mono. Can be set to Camera.MonoOrStereoscopicEye.Left or Camera.MonoOrStereoscopicEye.Right for use in stereoscopic rendering (e.g., for VR).
        * @returns The worldspace point created by converting the screen space point at the provided distance z from the camera plane.
        */
        public ScreenToWorldPoint ($position: Vector3) : Vector3
        /**
        * Transforms position from screen space into viewport space.
        */
        public ScreenToViewportPoint ($position: Vector3) : Vector3
        /**
        * Transforms position from viewport space into screen space.
        */
        public ViewportToScreenPoint ($position: Vector3) : Vector3
        /**
        * Returns a ray going from camera through a viewport point.
        * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
        */
        public ViewportPointToRay ($pos: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye) : Ray
        /**
        * Returns a ray going from camera through a viewport point.
        * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
        */
        public ViewportPointToRay ($pos: Vector3) : Ray
        /**
        * Returns a ray going from camera through a screen point.
        * @param pos A 3D point, with the x and y coordinates containing a 2D screenspace point in pixels. The lower left pixel of the screen is (0,0). The upper right pixel of the screen is (screen width in pixels - 1, screen height in pixels - 1). Unity ignores the z coordinate.
        * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
        */
        public ScreenPointToRay ($pos: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye) : Ray
        /**
        * Returns a ray going from camera through a screen point.
        * @param pos A 3D point, with the x and y coordinates containing a 2D screenspace point in pixels. The lower left pixel of the screen is (0,0). The upper right pixel of the screen is (screen width in pixels - 1, screen height in pixels - 1). Unity ignores the z coordinate.
        * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
        */
        public ScreenPointToRay ($pos: Vector3) : Ray
        /**
        * Given viewport coordinates, calculates the view space vectors pointing to the four frustum corners at the specified camera depth.
        * @param viewport Normalized viewport coordinates to use for the frustum calculation.
        * @param z Z-depth from the camera origin at which the corners will be calculated.
        * @param eye Camera eye projection matrix to use.
        * @param outCorners Output array for the frustum corner vectors. Cannot be null and length must be >= 4.
        */
        public CalculateFrustumCorners ($viewport: Rect, $z: float, $eye: UnityEngine_Camera.MonoOrStereoscopicEye, $outCorners: Vector3[]) : void
        public static CalculateProjectionMatrixFromPhysicalProperties ($output: $Ref<Matrix4x4>, $focalLength: float, $sensorSize: Vector2, $lensShift: Vector2, $nearClip: float, $farClip: float, $gateFitParameters?: UnityEngine_Camera.GateFitParameters) : void
        /**
        * Converts focal length to field of view.
        * @param focalLength Focal length in millimeters.
        * @param sensorSize Sensor size in millimeters. Use the sensor height to get the vertical field of view. Use the sensor width to get the horizontal field of view.
        * @returns field of view in degrees.
        */
        public static FocalLengthToFieldOfView ($focalLength: float, $sensorSize: float) : float
        /**
        * Converts field of view to focal length. Use either sensor height and vertical field of view or sensor width and horizontal field of view.
        * @param fieldOfView field of view in degrees.
        * @param sensorSize Sensor size in millimeters.
        * @returns Focal length in millimeters.
        */
        public static FieldOfViewToFocalLength ($fieldOfView: float, $sensorSize: float) : float
        /**
        * Converts the horizontal field of view (FOV) to the vertical FOV, based on the value of the aspect ratio parameter.
        * @param horizontalFOV The horizontal FOV value in degrees.
        * @param aspectRatio The aspect ratio value used for the conversion
        */
        public static HorizontalToVerticalFieldOfView ($horizontalFieldOfView: float, $aspectRatio: float) : float
        /**
        * Converts the vertical field of view (FOV) to the horizontal FOV, based on the value of the aspect ratio parameter.
        * @param verticalFieldOfView The vertical FOV value in degrees.
        * @param aspectRatio The aspect ratio value used for the conversion
        */
        public static VerticalToHorizontalFieldOfView ($verticalFieldOfView: float, $aspectRatio: float) : float
        /**
        * Gets the non-jittered projection matrix of a specific left or right stereoscopic eye.
        * @param eye Specifies the stereoscopic eye whose non-jittered projection matrix needs to be returned.
        * @returns The non-jittered projection matrix of the specified stereoscopic eye.
        */
        public GetStereoNonJitteredProjectionMatrix ($eye: UnityEngine_Camera.StereoscopicEye) : Matrix4x4
        /**
        * Gets the left or right view matrix of a specific stereoscopic eye.
        * @param eye Specifies the stereoscopic eye whose view matrix needs to be returned.
        * @returns The view matrix of the specified stereoscopic eye.
        */
        public GetStereoViewMatrix ($eye: UnityEngine_Camera.StereoscopicEye) : Matrix4x4
        /**
        * Sets the non-jittered projection matrix, sourced from the VR SDK.
        * @param eye Specifies the stereoscopic eye whose non-jittered projection matrix will be sourced from the VR SDK.
        */
        public CopyStereoDeviceProjectionMatrixToNonJittered ($eye: UnityEngine_Camera.StereoscopicEye) : void
        /**
        * Gets the projection matrix of a specific left or right stereoscopic eye.
        * @param eye Specifies the stereoscopic eye whose projection matrix needs to be returned.
        * @returns The projection matrix of the specified stereoscopic eye.
        */
        public GetStereoProjectionMatrix ($eye: UnityEngine_Camera.StereoscopicEye) : Matrix4x4
        /**
        * Sets a custom projection matrix for a specific stereoscopic eye.
        * @param eye Specifies the stereoscopic eye whose projection matrix needs to be set.
        * @param matrix The matrix to be set.
        */
        public SetStereoProjectionMatrix ($eye: UnityEngine_Camera.StereoscopicEye, $matrix: Matrix4x4) : void
        /**
        * Reset the camera to using the Unity computed projection matrices for all stereoscopic eyes.
        */
        public ResetStereoProjectionMatrices () : void
        /**
        * Sets a custom view matrix for a specific stereoscopic eye.
        * @param eye Specifies the stereoscopic view matrix to set.
        * @param matrix The matrix to be set.
        */
        public SetStereoViewMatrix ($eye: UnityEngine_Camera.StereoscopicEye, $matrix: Matrix4x4) : void
        /**
        * Reset the camera to using the Unity computed view matrices for all stereoscopic eyes.
        */
        public ResetStereoViewMatrices () : void
        /**
        * Fills an array of Camera with the current cameras in the Scene, without allocating a new array.
        * @param cameras An array to be filled up with cameras currently in the Scene.
        */
        public static GetAllCameras ($cameras: Camera[]) : int
        /**
        * Render into a static cubemap from this camera.
        * @param cubemap The cube map to render to.
        * @param faceMask A bitmask which determines which of the six faces are rendered to.
        * @returns False if rendering fails, else true.
        * @methodSwap RenderToCubemap_EBB7509C_A7955F50
        */
        public RenderToCubemap ($cubemap: Cubemap, $faceMask: int) : boolean
        public RenderToCubemap ($cubemap: Cubemap) : boolean
        /**
        * Render into a cubemap from this camera.
        * @param faceMask A bitfield indicating which cubemap faces should be rendered into.
        * @param cubemap The texture to render to.
        * @returns False if rendering fails, else true.
        * @methodSwap RenderToCubemap_EBB7509C_H795E908A
        */
        public RenderToCubemap ($cubemap: RenderTexture, $faceMask: int) : boolean
        public RenderToCubemap ($cubemap: RenderTexture) : boolean
        /**
        * Render one side of a stereoscopic 360-degree image into a cubemap from this camera.
        * @param cubemap The texture to render to.
        * @param faceMask A bitfield indicating which cubemap faces should be rendered into. Set to the integer value 63 to render all faces.
        * @param stereoEye A Camera eye corresponding to the left or right eye for stereoscopic rendering, or neither for non-stereoscopic rendering.
        * @returns False if rendering fails, else true.
        * @methodSwap RenderToCubemap_EBB7509C_H8A3B5FED
        */
        public RenderToCubemap ($cubemap: RenderTexture, $faceMask: int, $stereoEye: UnityEngine_Camera.MonoOrStereoscopicEye) : boolean
        /**
        * Render the camera manually.
        */
        public Render () : void
        /**
        * Render the camera with shader replacement.
        */
        public RenderWithShader ($shader: Shader, $replacementTag: string) : void
        public RenderDontRestore () : void
        public SubmitRenderRequest<RequestData> ($renderRequest: RequestData) : void
        public static SetupCurrent ($cur: Camera) : void
        /**
        * Makes this camera's settings match other camera.
        * @param other Copy camera settings to the other camera.
        */
        public CopyFrom ($other: Camera) : void
        /**
        * Remove command buffers from execution at a specified place.
        * @param evt When to execute the command buffer during rendering.
        */
        public RemoveCommandBuffers ($evt: UnityEngine_Rendering.CameraEvent) : void
        /**
        * Remove all command buffers set on this camera.
        */
        public RemoveAllCommandBuffers () : void
        /**
        * Add a command buffer to be executed at a specified place.
        * @param evt When to execute the command buffer during rendering.
        * @param buffer The buffer to execute.
        */
        public AddCommandBuffer ($evt: UnityEngine_Rendering.CameraEvent, $buffer: UnityEngine_Rendering.CommandBuffer) : void
        /**
        * Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
        * @param evt The point during the graphics processing at which this command buffer should commence on the GPU.
        * @param buffer The buffer to execute.
        * @param queueType The desired async compute queue type to execute the buffer on.
        */
        public AddCommandBufferAsync ($evt: UnityEngine_Rendering.CameraEvent, $buffer: UnityEngine_Rendering.CommandBuffer, $queueType: UnityEngine_Rendering.ComputeQueueType) : void
        /**
        * Remove command buffer from execution at a specified place.
        * @param evt When to execute the command buffer during rendering.
        * @param buffer The buffer to execute.
        */
        public RemoveCommandBuffer ($evt: UnityEngine_Rendering.CameraEvent, $buffer: UnityEngine_Rendering.CommandBuffer) : void
        /**
        * Get command buffers to be executed at a specified place.
        * @param evt When to execute the command buffer during rendering.
        * @returns Array of command buffers.
        */
        public GetCommandBuffers ($evt: UnityEngine_Rendering.CameraEvent) : UnityEngine_Rendering.CommandBuffer[]
        /**
        * Get culling parameters for a camera.
        * @param cullingParameters Resultant culling parameters.
        * @param stereoAware Generate single-pass stereo aware culling parameters.
        * @returns Flag indicating whether culling parameters are valid.
        */
        public TryGetCullingParameters ($cullingParameters: $Ref<UnityEngine_Rendering.ScriptableCullingParameters>) : boolean
        /**
        * Get culling parameters for a camera.
        * @param cullingParameters Resultant culling parameters.
        * @param stereoAware Generate single-pass stereo aware culling parameters.
        * @returns Flag indicating whether culling parameters are valid.
        */
        public TryGetCullingParameters ($stereoAware: boolean, $cullingParameters: $Ref<UnityEngine_Rendering.ScriptableCullingParameters>) : boolean
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * Behaviours are Components that can be enabled or disabled.
    */
    class Behaviour extends Component {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;

        private constructor ()
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * Base class for everything attached to a GameObject.
    */
    class Component extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);

        private constructor ()
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
        /**
        * Gets the index of the component on its parent GameObject.
        * @returns The component index.
        */
        public GetComponentIndex () : int
        /**
        * Checks the GameObject's tag against the defined tag.
        * @param tag The tag to compare.
        * @returns Returns true if GameObject has same tag. Returns false otherwise.
        */
        public CompareTag ($tag: string) : boolean
    }

    /**
    * Base class for all objects Unity can reference.
    */
    class Object extends System.Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);

        public constructor ()
        /**
        * Gets  the instance ID of the object.
        * @returns Returns the instance ID of the object.
        */
        public GetInstanceID () : int
        public GetHashCode () : int
        public Equals ($other: any) : boolean
        public static InstantiateAsync<T extends Object> ($original: T) : AsyncInstantiateOperation$1<T>
        public static InstantiateAsync<T extends Object> ($original: T, $parent: Transform) : AsyncInstantiateOperation$1<T>
        public static InstantiateAsync<T extends Object> ($original: T, $position: Vector3, $rotation: Quaternion) : AsyncInstantiateOperation$1<T>
        public static InstantiateAsync<T extends Object> ($original: T, $parent: Transform, $position: Vector3, $rotation: Quaternion) : AsyncInstantiateOperation$1<T>
        /**
        * @methodSwap InstantiateAsync_EBB7509C_H6D080506
        */
        public static InstantiateAsync<T extends Object> ($original: T, $count: int) : AsyncInstantiateOperation$1<T>
        /**
        * @methodSwap InstantiateAsync_EBB7509C_H62587F13
        */
        public static InstantiateAsync<T extends Object> ($original: T, $count: int, $parent: Transform) : AsyncInstantiateOperation$1<T>
        /**
        * @methodSwap InstantiateAsync_EBB7509C_H6CA5A470
        */
        public static InstantiateAsync<T extends Object> ($original: T, $count: int, $position: Vector3, $rotation: Quaternion) : AsyncInstantiateOperation$1<T>
        /**
        * @methodSwap InstantiateAsync_EBB7509C_H74BF0307
        */
        public static InstantiateAsync<T extends Object> ($original: T, $count: int, $parent: Transform, $position: Vector3, $rotation: Quaternion) : AsyncInstantiateOperation$1<T>
        /**
        * Clones the object original and returns the clone.
        * @param original An existing object that you want to make a copy of.
        * @param position Position for the new object.
        * @param rotation Orientation of the new object.
        * @param parent Parent that will be assigned to the new object.
        * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
        * @returns The instantiated clone.
        */
        public static Instantiate ($original: Object, $position: Vector3, $rotation: Quaternion) : Object
        /**
        * Clones the object original and returns the clone.
        * @param original An existing object that you want to make a copy of.
        * @param position Position for the new object.
        * @param rotation Orientation of the new object.
        * @param parent Parent that will be assigned to the new object.
        * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
        * @returns The instantiated clone.
        */
        public static Instantiate ($original: Object, $position: Vector3, $rotation: Quaternion, $parent: Transform) : Object
        /**
        * Clones the object original and returns the clone.
        * @param original An existing object that you want to make a copy of.
        * @param position Position for the new object.
        * @param rotation Orientation of the new object.
        * @param parent Parent that will be assigned to the new object.
        * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
        * @returns The instantiated clone.
        */
        public static Instantiate ($original: Object) : Object
        /**
        * Clones the object original and returns the clone.
        * @param original An existing object that you want to make a copy of.
        * @param position Position for the new object.
        * @param rotation Orientation of the new object.
        * @param parent Parent that will be assigned to the new object.
        * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
        * @returns The instantiated clone.
        */
        public static Instantiate ($original: Object, $scene: UnityEngine_SceneManagement.Scene) : Object
        /**
        * Clones the object original and returns the clone.
        * @param original An existing object that you want to make a copy of.
        * @param position Position for the new object.
        * @param rotation Orientation of the new object.
        * @param parent Parent that will be assigned to the new object.
        * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
        * @returns The instantiated clone.
        */
        public static Instantiate ($original: Object, $parent: Transform) : Object
        /**
        * Clones the object original and returns the clone.
        * @param original An existing object that you want to make a copy of.
        * @param position Position for the new object.
        * @param rotation Orientation of the new object.
        * @param parent Parent that will be assigned to the new object.
        * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
        * @returns The instantiated clone.
        */
        public static Instantiate ($original: Object, $parent: Transform, $instantiateInWorldSpace: boolean) : Object
        public static Instantiate<T extends Object> ($original: T) : T
        public static Instantiate<T extends Object> ($original: T, $position: Vector3, $rotation: Quaternion) : T
        public static Instantiate<T extends Object> ($original: T, $position: Vector3, $rotation: Quaternion, $parent: Transform) : T
        public static Instantiate<T extends Object> ($original: T, $parent: Transform) : T
        public static Instantiate<T extends Object> ($original: T, $parent: Transform, $worldPositionStays: boolean) : T
        /**
        * Removes a GameObject, component or asset.
        * @param obj The object to destroy.
        * @param t The optional amount of time to delay before destroying the object.
        * @methodSwap Destroy_EBB7509C_C8B9832E
        */
        public static Destroy ($obj: Object, $t: float) : void
        /**
        * Removes a GameObject, component or asset.
        * @param obj The object to destroy.
        * @param t The optional amount of time to delay before destroying the object.
        */
        public static Destroy ($obj: Object) : void
        /**
        * Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
        * @param obj Object to be destroyed.
        * @param allowDestroyingAssets Set to true to allow assets to be destroyed.
        */
        public static DestroyImmediate ($obj: Object, $allowDestroyingAssets: boolean) : void
        /**
        * Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
        * @param obj Object to be destroyed.
        * @param allowDestroyingAssets Set to true to allow assets to be destroyed.
        */
        public static DestroyImmediate ($obj: Object) : void
        /**
        * Gets a list of all loaded objects of Type type.
        * @param type The type of object to find.
        * @param includeInactive If true, components attached to inactive GameObjects are also included.
        * @returns The array of objects found matching the type specified.
        */
        public static FindObjectsOfType ($type: System.Type) : Object[]
        /**
        * Gets a list of all loaded objects of Type type.
        * @param type The type of object to find.
        * @param includeInactive If true, components attached to inactive GameObjects are also included.
        * @returns The array of objects found matching the type specified.
        */
        public static FindObjectsOfType ($type: System.Type, $includeInactive: boolean) : Object[]
        /**
        * Retrieves a list of all loaded objects of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @param sortMode Whether and how to sort the returned array. Not sorting the array makes this function run significantly faster.
        * @returns The array of objects found matching the type specified.
        */
        public static FindObjectsByType ($type: System.Type, $sortMode: FindObjectsSortMode) : Object[]
        /**
        * Retrieves a list of all loaded objects of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @param sortMode Whether and how to sort the returned array. Not sorting the array makes this function run significantly faster.
        * @returns The array of objects found matching the type specified.
        */
        public static FindObjectsByType ($type: System.Type, $findObjectsInactive: FindObjectsInactive, $sortMode: FindObjectsSortMode) : Object[]
        /**
        * Do not destroy the target Object when loading a new Scene.
        * @param target An Object not destroyed on Scene change.
        */
        public static DontDestroyOnLoad ($target: Object) : void
        /**
        * Gets a list of all loaded objects of Type type.
        * @param type The type of object to find.
        * @param includeInactive If true, components attached to inactive GameObjects are also included.
        * @returns The array of objects found matching the type specified.
        */
        public static FindObjectsOfType<T extends Object> () : T[]
        /**
        * Retrieves a list of all loaded objects of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @param sortMode Whether and how to sort the returned array. Not sorting the array makes this function run significantly faster.
        * @returns The array of objects found matching the type specified.
        */
        public static FindObjectsByType<T extends Object> ($sortMode: FindObjectsSortMode) : T[]
        /**
        * Gets a list of all loaded objects of Type type.
        * @param type The type of object to find.
        * @param includeInactive If true, components attached to inactive GameObjects are also included.
        * @returns The array of objects found matching the type specified.
        */
        public static FindObjectsOfType<T extends Object> ($includeInactive: boolean) : T[]
        /**
        * Retrieves a list of all loaded objects of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @param sortMode Whether and how to sort the returned array. Not sorting the array makes this function run significantly faster.
        * @returns The array of objects found matching the type specified.
        */
        public static FindObjectsByType<T extends Object> ($findObjectsInactive: FindObjectsInactive, $sortMode: FindObjectsSortMode) : T[]
        /**
        * Returns the first active loaded object of Type type.
        * @param type The type of object to find.
        * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type.
        */
        public static FindObjectOfType<T extends Object> () : T
        /**
        * Returns the first active loaded object of Type type.
        * @param type The type of object to find.
        * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type.
        */
        public static FindObjectOfType<T extends Object> ($includeInactive: boolean) : T
        /**
        * Retrieves the first active loaded object of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @returns Returns the first active loaded object that matches the specified type. If no object matches the specified type, returns null.
        */
        public static FindFirstObjectByType<T extends Object> () : T
        /**
        * Retrieves any active loaded object of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @returns Returns an arbitrary active loaded object that matches the specified type. If no object matches the specified type, returns null.
        */
        public static FindAnyObjectByType<T extends Object> () : T
        /**
        * Retrieves the first active loaded object of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @returns Returns the first active loaded object that matches the specified type. If no object matches the specified type, returns null.
        */
        public static FindFirstObjectByType<T extends Object> ($findObjectsInactive: FindObjectsInactive) : T
        /**
        * Retrieves any active loaded object of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @returns Returns an arbitrary active loaded object that matches the specified type. If no object matches the specified type, returns null.
        */
        public static FindAnyObjectByType<T extends Object> ($findObjectsInactive: FindObjectsInactive) : T
        /**
        * Returns the first active loaded object of Type type.
        * @param type The type of object to find.
        * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type.
        */
        public static FindObjectOfType ($type: System.Type) : Object
        /**
        * Retrieves the first active loaded object of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @returns Returns the first active loaded object that matches the specified type. If no object matches the specified type, returns null.
        */
        public static FindFirstObjectByType ($type: System.Type) : Object
        /**
        * Retrieves any active loaded object of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @returns Returns an arbitrary active loaded object that matches the specified type. If no object matches the specified type, returns null.
        */
        public static FindAnyObjectByType ($type: System.Type) : Object
        /**
        * Returns the first active loaded object of Type type.
        * @param type The type of object to find.
        * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type.
        */
        public static FindObjectOfType ($type: System.Type, $includeInactive: boolean) : Object
        /**
        * Retrieves the first active loaded object of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @returns Returns the first active loaded object that matches the specified type. If no object matches the specified type, returns null.
        */
        public static FindFirstObjectByType ($type: System.Type, $findObjectsInactive: FindObjectsInactive) : Object
        /**
        * Retrieves any active loaded object of Type type.
        * @param type The type of object to find.
        * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
        * @returns Returns an arbitrary active loaded object that matches the specified type. If no object matches the specified type, returns null.
        */
        public static FindAnyObjectByType ($type: System.Type, $findObjectsInactive: FindObjectsInactive) : Object
        /**
        * Returns the name of the object.
        * @returns The name returned by ToString.
        */
        public ToString () : string
        public static op_Implicit ($exists: Object) : boolean
        public static op_Equality ($x: Object, $y: Object) : boolean
        public static op_Inequality ($x: Object, $y: Object) : boolean
    }

    class AsyncInstantiateOperation$1<T> extends CustomYieldInstruction {

        /**
        * Indicates if coroutine should be kept suspended.
        */
        public get keepWaiting(): boolean;
        public get Current(): any;
        public get isDone(): boolean;
        public get progress(): float;
        public get allowSceneActivation(): boolean;
        public set allowSceneActivation(value: boolean);
        public get Result(): T[];

        public GetOperation () : AsyncInstantiateOperation
        public IsWaitingForSceneActivation () : boolean
        public WaitForCompletion () : void
        public Cancel () : void
        public add_completed ($value: System.Action$1<AsyncOperation>) : void
        public remove_completed ($value: System.Action$1<AsyncOperation>) : void
    }

    /**
    * Base class for custom yield instructions to suspend coroutines.
    */
    class CustomYieldInstruction extends System.Object implements System_Collections.IEnumerator {

        /**
        * Indicates if coroutine should be kept suspended.
        */
        public get keepWaiting(): boolean;
        public get Current(): any;

        public MoveNext () : boolean
        public Reset () : void
    }

    /**
    * Asynchronous instantiate operation on UnityEngine.Object type.
    */
    class AsyncInstantiateOperation extends AsyncOperation {

        /**
        * Has the operation finished? (Read Only)
        */
        public get isDone(): boolean;
        /**
        * What's the operation's progress. (Read Only)
        */
        public get progress(): float;
        /**
        * Priority lets you tweak in which order async operation calls will be performed.
        */
        public get priority(): int;
        public set priority(value: int);
        /**
        * Allow Scenes to be activated as soon as it is ready.
        */
        public get allowSceneActivation(): boolean;
        public set allowSceneActivation(value: boolean);
        /**
        * If isDone is true, then Result contains the instantiated objects. The size of the array is the same as the 'count' argument for the InstantiateAsync call.
        */
        public get Result(): Object[];

        public constructor ()
        /**
        * This property can be true only if allowSceneActivation is set to false, and if the operation has already completed everything needed for object instantiation except for the main thread integrating the objects and calling their Awake methods. Users can set allowSceneActivation to true to trigger the activation or call the Cancel method to cancel instantiation.
        * @returns True if the operation is waits for user to allow the scene activation.
        */
        public IsWaitingForSceneActivation () : boolean
        /**
        * Blocks the current thread until this operation is done.
        */
        public WaitForCompletion () : void
        /**
        * Method that cancels all the operations connected to the asynchronous instantiation if the operation is not done yet, that is, where isDone == false. This method deletes all the objects created so far, which are not visible to users while they're not activated, and stops all the internal jobs connected to the operation.
        */
        public Cancel () : void
        /**
        * Gets the target duration allowed per frame to integrate instantiated object operations, in milliseconds.
        */
        public static GetIntegrationTimeMS () : float
        /**
        * Sets the target duration allowed per frame to integrate instantiated object operations, in milliseconds.
        */
        public static SetIntegrationTimeMS ($integrationTimeMS: float) : void
    }

    /**
    * Asynchronous operation coroutine.
    */
    class AsyncOperation extends YieldInstruction {

        /**
        * Has the operation finished? (Read Only)
        */
        public get isDone(): boolean;
        /**
        * What's the operation's progress. (Read Only)
        */
        public get progress(): float;
        /**
        * Priority lets you tweak in which order async operation calls will be performed.
        */
        public get priority(): int;
        public set priority(value: int);
        /**
        * Allow Scenes to be activated as soon as it is ready.
        */
        public get allowSceneActivation(): boolean;
        public set allowSceneActivation(value: boolean);

        public constructor ()
        public add_completed ($value: System.Action$1<AsyncOperation>) : void
        public remove_completed ($value: System.Action$1<AsyncOperation>) : void
    }

    /**
    * Base class for all yield instructions.
    */
    class YieldInstruction extends System.Object {

        public constructor ()
    }

    /**
    * Position, rotation and scale of an object.
    */
    class Transform extends Component implements System_Collections.IEnumerable {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * The world space position of the Transform.
        */
        public get position(): Vector3;
        public set position(value: Vector3);
        /**
        * Position of the transform relative to the parent transform.
        */
        public get localPosition(): Vector3;
        public set localPosition(value: Vector3);
        /**
        * The rotation as Euler angles in degrees.
        */
        public get eulerAngles(): Vector3;
        public set eulerAngles(value: Vector3);
        /**
        * The rotation as Euler angles in degrees relative to the parent transform's rotation.
        */
        public get localEulerAngles(): Vector3;
        public set localEulerAngles(value: Vector3);
        /**
        * The red axis of the transform in world space.
        */
        public get right(): Vector3;
        public set right(value: Vector3);
        /**
        * The green axis of the transform in world space.
        */
        public get up(): Vector3;
        public set up(value: Vector3);
        /**
        * Returns a normalized vector representing the blue axis of the transform in world space.
        */
        public get forward(): Vector3;
        public set forward(value: Vector3);
        /**
        * A Quaternion that stores the rotation of the Transform in world space.
        */
        public get rotation(): Quaternion;
        public set rotation(value: Quaternion);
        /**
        * The rotation of the transform relative to the transform rotation of the parent.
        */
        public get localRotation(): Quaternion;
        public set localRotation(value: Quaternion);
        /**
        * The scale of the transform relative to the GameObjects parent.
        */
        public get localScale(): Vector3;
        public set localScale(value: Vector3);
        /**
        * The parent of the transform.
        */
        public get parent(): Transform;
        public set parent(value: Transform);
        /**
        * Matrix that transforms a point from world space into local space (Read Only).
        */
        public get worldToLocalMatrix(): Matrix4x4;
        /**
        * Matrix that transforms a point from local space into world space (Read Only).
        */
        public get localToWorldMatrix(): Matrix4x4;
        /**
        * Returns the topmost transform in the hierarchy.
        */
        public get root(): Transform;
        /**
        * The number of children the parent Transform has.
        */
        public get childCount(): int;
        /**
        * The global scale of the object (Read Only).
        */
        public get lossyScale(): Vector3;
        /**
        * Has the transform changed since the last time the flag was set to 'false'?
        */
        public get hasChanged(): boolean;
        public set hasChanged(value: boolean);
        /**
        * The transform capacity of the transform's hierarchy data structure.
        */
        public get hierarchyCapacity(): int;
        public set hierarchyCapacity(value: int);
        /**
        * The number of transforms in the transform's hierarchy data structure.
        */
        public get hierarchyCount(): int;

        /**
        * Set the parent of the transform.
        * @param parent The parent Transform to use.
        * @param worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
        */
        public SetParent ($p: Transform) : void
        /**
        * Set the parent of the transform.
        * @param parent The parent Transform to use.
        * @param worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
        */
        public SetParent ($parent: Transform, $worldPositionStays: boolean) : void
        /**
        * Sets the world space position and rotation of the Transform component.
        */
        public SetPositionAndRotation ($position: Vector3, $rotation: Quaternion) : void
        /**
        * Sets the position and rotation of the Transform component in local space (i.e. relative to its parent transform).
        */
        public SetLocalPositionAndRotation ($localPosition: Vector3, $localRotation: Quaternion) : void
        /**
        * Gets the position and rotation of the Transform component in world space.
        */
        public GetPositionAndRotation ($position: $Ref<Vector3>, $rotation: $Ref<Quaternion>) : void
        /**
        * Gets the position and rotation of the Transform component in local space (that is, relative to its parent transform).
        */
        public GetLocalPositionAndRotation ($localPosition: $Ref<Vector3>, $localRotation: $Ref<Quaternion>) : void
        /**
        * Moves the transform in the direction and distance of translation.
        */
        public Translate ($translation: Vector3, $relativeTo: Space) : void
        /**
        * Moves the transform in the direction and distance of translation.
        */
        public Translate ($translation: Vector3) : void
        /**
        * Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
        * @methodSwap Translate_EBB7509C_H28752197
        */
        public Translate ($x: float, $y: float, $z: float, $relativeTo: Space) : void
        /**
        * Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
        * @methodSwap Translate_EBB7509C_E4172388
        */
        public Translate ($x: float, $y: float, $z: float) : void
        /**
        * Moves the transform in the direction and distance of translation.
        */
        public Translate ($translation: Vector3, $relativeTo: Transform) : void
        /**
        * Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
        * @methodSwap Translate_EBB7509C_H2E495CD
        */
        public Translate ($x: float, $y: float, $z: float, $relativeTo: Transform) : void
        /**
        * Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
        * @param eulers The rotation to apply in euler angles.
        * @param relativeTo Determines whether to rotate the GameObject either locally to  the GameObject or relative to the Scene in world space.
        */
        public Rotate ($eulers: Vector3, $relativeTo: Space) : void
        /**
        * Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
        * @param eulers The rotation to apply in euler angles.
        */
        public Rotate ($eulers: Vector3) : void
        /**
        * The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
        * @param xAngle Degrees to rotate the GameObject around the X axis.
        * @param yAngle Degrees to rotate the GameObject around the Y axis.
        * @param zAngle Degrees to rotate the GameObject around the Z axis.
        * @param relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
        * @methodSwap Rotate_EBB7509C_H28752197
        */
        public Rotate ($xAngle: float, $yAngle: float, $zAngle: float, $relativeTo: Space) : void
        /**
        * The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
        * @param xAngle Degrees to rotate the GameObject around the X axis.
        * @param yAngle Degrees to rotate the GameObject around the Y axis.
        * @param zAngle Degrees to rotate the GameObject around the Z axis.
        * @methodSwap Rotate_EBB7509C_E4172388
        */
        public Rotate ($xAngle: float, $yAngle: float, $zAngle: float) : void
        /**
        * Rotates the object around the given axis by the number of degrees defined by the given angle.
        * @param axis The axis to apply rotation to.
        * @param angle The degrees of rotation to apply.
        * @param relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
        * @methodSwap Rotate_EBB7509C_AAF45F22
        */
        public Rotate ($axis: Vector3, $angle: float, $relativeTo: Space) : void
        /**
        * Rotates the object around the given axis by the number of degrees defined by the given angle.
        * @param axis The axis to apply rotation to.
        * @param angle The degrees of rotation to apply.
        * @methodSwap Rotate_EBB7509C_H75CC56AF
        */
        public Rotate ($axis: Vector3, $angle: float) : void
        /**
        * Rotates the transform about axis passing through point in world coordinates by angle degrees.
        */
        public RotateAround ($point: Vector3, $axis: Vector3, $angle: float) : void
        /**
        * Rotates the transform so the forward vector points at target's current position.
        * @param target Object to point towards.
        * @param worldUp Vector specifying the upward direction.
        */
        public LookAt ($target: Transform, $worldUp: Vector3) : void
        /**
        * Rotates the transform so the forward vector points at target's current position.
        * @param target Object to point towards.
        * @param worldUp Vector specifying the upward direction.
        */
        public LookAt ($target: Transform) : void
        /**
        * Rotates the transform so the forward vector points at worldPosition.
        * @param worldPosition Point to look at.
        * @param worldUp Vector specifying the upward direction.
        */
        public LookAt ($worldPosition: Vector3, $worldUp: Vector3) : void
        /**
        * Rotates the transform so the forward vector points at worldPosition.
        * @param worldPosition Point to look at.
        * @param worldUp Vector specifying the upward direction.
        */
        public LookAt ($worldPosition: Vector3) : void
        /**
        * Transforms direction from local space to world space.
        */
        public TransformDirection ($direction: Vector3) : Vector3
        /**
        * Transforms direction x, y, z from local space to world space.
        * @methodSwap TransformDirection_EBB7509C_E4172388
        */
        public TransformDirection ($x: float, $y: float, $z: float) : Vector3
        /**
        * Transforms a direction from world space to local space. The opposite of Transform.TransformDirection.
        */
        public InverseTransformDirection ($direction: Vector3) : Vector3
        /**
        * Transforms the direction x, y, z from world space to local space. The opposite of Transform.TransformDirection.
        * @methodSwap InverseTransformDirection_EBB7509C_E4172388
        */
        public InverseTransformDirection ($x: float, $y: float, $z: float) : Vector3
        /**
        * Transforms vector from local space to world space.
        */
        public TransformVector ($vector: Vector3) : Vector3
        /**
        * Transforms vector x, y, z from local space to world space.
        * @methodSwap TransformVector_EBB7509C_E4172388
        */
        public TransformVector ($x: float, $y: float, $z: float) : Vector3
        /**
        * Transforms a vector from world space to local space. The opposite of Transform.TransformVector.
        */
        public InverseTransformVector ($vector: Vector3) : Vector3
        /**
        * Transforms the vector x, y, z from world space to local space. The opposite of Transform.TransformVector.
        * @methodSwap InverseTransformVector_EBB7509C_E4172388
        */
        public InverseTransformVector ($x: float, $y: float, $z: float) : Vector3
        /**
        * Transforms position from local space to world space.
        */
        public TransformPoint ($position: Vector3) : Vector3
        /**
        * Transforms the position x, y, z from local space to world space.
        * @methodSwap TransformPoint_EBB7509C_E4172388
        */
        public TransformPoint ($x: float, $y: float, $z: float) : Vector3
        /**
        * Transforms position from world space to local space.
        */
        public InverseTransformPoint ($position: Vector3) : Vector3
        /**
        * Transforms the position x, y, z from world space to local space.
        * @methodSwap InverseTransformPoint_EBB7509C_E4172388
        */
        public InverseTransformPoint ($x: float, $y: float, $z: float) : Vector3
        /**
        * Unparents all children.
        */
        public DetachChildren () : void
        /**
        * Move the transform to the start of the local transform list.
        */
        public SetAsFirstSibling () : void
        /**
        * Move the transform to the end of the local transform list.
        */
        public SetAsLastSibling () : void
        /**
        * Sets the sibling index.
        * @param index Index to set.
        */
        public SetSiblingIndex ($index: int) : void
        /**
        * Gets the sibling index.
        */
        public GetSiblingIndex () : int
        /**
        * Finds a child by name n and returns it.
        * @param n Name of child to be found.
        * @returns The found child transform. Null if child with matching name isn't found.
        */
        public Find ($n: string) : Transform
        /**
        * Is this transform a child of parent?
        */
        public IsChildOf ($parent: Transform) : boolean
        public GetEnumerator () : System_Collections.IEnumerator
        /**
        * Returns a transform child by index.
        * @param index Index of the child transform to return. Must be smaller than Transform.childCount.
        * @returns Transform child by index.
        */
        public GetChild ($index: int) : Transform
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
        private constructor ()
    }

    /**
    * Representation of 3D vectors and points.
    */
    class Vector3 extends System.ValueType implements System.IFormattable, System.IEquatable$1<Vector3> {

        public static kEpsilon : float
        public static kEpsilonNormalSqrt : float
        /**
        * X component of the vector.
        */
        public x : float
        /**
        * Y component of the vector.
        */
        public y : float
        /**
        * Z component of the vector.
        */
        public z : float
        /**
        * Returns a normalized vector based on the current vector. The normalized vector has a magnitude of 1 and is in the same direction as the current vector. Returns a zero vector If the current vector is too small to be normalized.
        */
        public get normalized(): Vector3;
        /**
        * Returns the length of this vector (Read Only).
        */
        public get magnitude(): float;
        /**
        * Returns the squared length of this vector (Read Only).
        */
        public get sqrMagnitude(): float;
        /**
        * Shorthand for writing Vector3(0, 0, 0).
        */
        public static get zero(): Vector3;
        /**
        * Shorthand for writing Vector3(1, 1, 1).
        */
        public static get one(): Vector3;
        /**
        * Shorthand for writing Vector3(0, 0, 1).
        */
        public static get forward(): Vector3;
        /**
        * Shorthand for writing Vector3(0, 0, -1).
        */
        public static get back(): Vector3;
        /**
        * Shorthand for writing Vector3(0, 1, 0).
        */
        public static get up(): Vector3;
        /**
        * Shorthand for writing Vector3(0, -1, 0).
        */
        public static get down(): Vector3;
        /**
        * Shorthand for writing Vector3(-1, 0, 0).
        */
        public static get left(): Vector3;
        /**
        * Shorthand for writing Vector3(1, 0, 0).
        */
        public static get right(): Vector3;
        /**
        * Shorthand for writing Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
        */
        public static get positiveInfinity(): Vector3;
        /**
        * Shorthand for writing Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
        */
        public static get negativeInfinity(): Vector3;

        /**
        * Creates a new vector with given x, y, z components.
        */
        public constructor ($x: float, $y: float, $z: float)
        /**
        * Creates a new vector with given x, y components and sets z to zero.
        */
        public constructor ($x: float, $y: float)
        /**
        * Spherically interpolates between two vectors.
        */
        public static Slerp ($a: Vector3, $b: Vector3, $t: float) : Vector3
        /**
        * Spherically interpolates between two vectors.
        */
        public static SlerpUnclamped ($a: Vector3, $b: Vector3, $t: float) : Vector3
        /**
        * Makes vectors normalized and orthogonal to each other.
        */
        public static OrthoNormalize ($normal: $Ref<Vector3>, $tangent: $Ref<Vector3>) : void
        /**
        * Makes vectors normalized and orthogonal to each other.
        */
        public static OrthoNormalize ($normal: $Ref<Vector3>, $tangent: $Ref<Vector3>, $binormal: $Ref<Vector3>) : void
        /**
        * Rotates a vector current towards target.
        * @param current The vector being managed.
        * @param target The vector.
        * @param maxRadiansDelta The maximum angle in radians allowed for this rotation.
        * @param maxMagnitudeDelta The maximum allowed change in vector magnitude for this rotation.
        * @returns The location that RotateTowards generates.
        */
        public static RotateTowards ($current: Vector3, $target: Vector3, $maxRadiansDelta: float, $maxMagnitudeDelta: float) : Vector3
        /**
        * Linearly interpolates between two points.
        * @param a Start value, returned when t = 0.
        * @param b End value, returned when t = 1.
        * @param t Value used to interpolate between a and b.
        * @returns Interpolated value, equals to a + (b - a) * t.
        */
        public static Lerp ($a: Vector3, $b: Vector3, $t: float) : Vector3
        /**
        * Linearly interpolates between two vectors.
        */
        public static LerpUnclamped ($a: Vector3, $b: Vector3, $t: float) : Vector3
        /**
        * Calculate a position between the points specified by current and target, moving no farther than the distance specified by maxDistanceDelta.
        * @param current The position to move from.
        * @param target The position to move towards.
        * @param maxDistanceDelta Distance to move current per call.
        * @returns The new position.
        */
        public static MoveTowards ($current: Vector3, $target: Vector3, $maxDistanceDelta: float) : Vector3
        /**
        * Gradually changes a vector towards a desired goal over time.
        * @param current The current position.
        * @param target The position we are trying to reach.
        * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
        * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
        * @param maxSpeed Optionally allows you to clamp the maximum speed.
        * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
        * @methodSwap SmoothDamp_EBB7509C_FB5AD0E3
        */
        public static SmoothDamp ($current: Vector3, $target: Vector3, $currentVelocity: $Ref<Vector3>, $smoothTime: float, $maxSpeed: float) : Vector3
        /**
        * Gradually changes a vector towards a desired goal over time.
        * @param current The current position.
        * @param target The position we are trying to reach.
        * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
        * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
        * @param maxSpeed Optionally allows you to clamp the maximum speed.
        * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
        * @methodSwap SmoothDamp_EBB7509C_H177B12AA
        */
        public static SmoothDamp ($current: Vector3, $target: Vector3, $currentVelocity: $Ref<Vector3>, $smoothTime: float) : Vector3
        /**
        * Gradually changes a vector towards a desired goal over time.
        * @param current The current position.
        * @param target The position we are trying to reach.
        * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
        * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
        * @param maxSpeed Optionally allows you to clamp the maximum speed.
        * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
        * @methodSwap SmoothDamp_EBB7509C_H15C5A34
        */
        public static SmoothDamp ($current: Vector3, $target: Vector3, $currentVelocity: $Ref<Vector3>, $smoothTime: float, $maxSpeed: float, $deltaTime: float) : Vector3
        /**
        * Set x, y and z components of an existing Vector3.
        */
        public Set ($newX: float, $newY: float, $newZ: float) : void
        /**
        * Multiplies two vectors component-wise.
        */
        public static Scale ($a: Vector3, $b: Vector3) : Vector3
        /**
        * Multiplies every component of this vector by the same component of scale.
        */
        public Scale ($scale: Vector3) : void
        /**
        * Cross Product of two vectors.
        */
        public static Cross ($lhs: Vector3, $rhs: Vector3) : Vector3
        public GetHashCode () : int
        /**
        * Returns true if the given vector is exactly equal to this vector.
        */
        public Equals ($other: any) : boolean
        public Equals ($other: Vector3) : boolean
        /**
        * Reflects a vector off the plane defined by a normal.
        * @param inDirection The direction vector towards the plane.
        * @param inNormal The normal vector that defines the plane.
        */
        public static Reflect ($inDirection: Vector3, $inNormal: Vector3) : Vector3
        /**
        * Returns a normalized vector based on the given vector. The normalized vector has a magnitude of 1 and is in the same direction as the given vector. Returns a zero vector If the given vector is too small to be normalized.
        * @param value The vector to be normalized.
        * @returns A new vector with the same direction as the original vector but with a magnitude of 1.0.
        */
        public static Normalize ($value: Vector3) : Vector3
        /**
        * Makes this vector have a magnitude of 1.
        */
        public Normalize () : void
        /**
        * Dot Product of two vectors.
        */
        public static Dot ($lhs: Vector3, $rhs: Vector3) : float
        /**
        * Projects a vector onto another vector.
        */
        public static Project ($vector: Vector3, $onNormal: Vector3) : Vector3
        /**
        * Projects a vector onto a plane.
        * @param vector The vector to project on the plane.
        * @param planeNormal The normal which defines the plane to project on.
        * @returns The orthogonal projection of vector on the plane.
        */
        public static ProjectOnPlane ($vector: Vector3, $planeNormal: Vector3) : Vector3
        /**
        * Calculates the angle between two vectors.
        * @param from The vector from which the angular difference is measured.
        * @param to The vector to which the angular difference is measured.
        * @returns The angle in degrees between the two vectors.
        */
        public static Angle ($from: Vector3, $to: Vector3) : float
        /**
        * Calculates the signed angle between vectors from and to in relation to axis.
        * @param from The vector from which the angular difference is measured.
        * @param to The vector to which the angular difference is measured.
        * @param axis A vector around which the other vectors are rotated.
        * @returns Returns the signed angle between from and to in degrees.
        */
        public static SignedAngle ($from: Vector3, $to: Vector3, $axis: Vector3) : float
        /**
        * Returns the distance between a and b.
        */
        public static Distance ($a: Vector3, $b: Vector3) : float
        /**
        * Returns a copy of vector with its magnitude clamped to maxLength.
        */
        public static ClampMagnitude ($vector: Vector3, $maxLength: float) : Vector3
        public static Magnitude ($vector: Vector3) : float
        public static SqrMagnitude ($vector: Vector3) : float
        /**
        * Returns a vector that is made from the smallest components of two vectors.
        */
        public static Min ($lhs: Vector3, $rhs: Vector3) : Vector3
        /**
        * Returns a vector that is made from the largest components of two vectors.
        */
        public static Max ($lhs: Vector3, $rhs: Vector3) : Vector3
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        public get_Item ($index: int) : float
        public set_Item ($index: int, $value: float) : void
        public static op_Addition ($a: Vector3, $b: Vector3) : Vector3
        public static op_Subtraction ($a: Vector3, $b: Vector3) : Vector3
        public static op_UnaryNegation ($a: Vector3) : Vector3
        /**
        * Multiplies a vector by a number.
        * @methodSwap op_Multiply_EBB7509C_H75CC56AF
        */
        public static op_Multiply ($a: Vector3, $d: float) : Vector3
        /**
        * Multiplies a vector by a number.
        * @methodSwap op_Multiply_EBB7509C_H66444A53
        */
        public static op_Multiply ($d: float, $a: Vector3) : Vector3
        public static op_Division ($a: Vector3, $d: float) : Vector3
        public static op_Equality ($lhs: Vector3, $rhs: Vector3) : boolean
        public static op_Inequality ($lhs: Vector3, $rhs: Vector3) : boolean
    }

    /**
    * Quaternions are used to represent rotations.
    */
    class Quaternion extends System.ValueType implements System.IFormattable, System.IEquatable$1<Quaternion> {

        /**
        * X component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
        */
        public x : float
        /**
        * Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
        */
        public y : float
        /**
        * Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
        */
        public z : float
        /**
        * W component of the Quaternion. Do not directly modify quaternions.
        */
        public w : float
        public static kEpsilon : float
        /**
        * The identity rotation (Read Only).
        */
        public static get identity(): Quaternion;
        /**
        * Returns or sets the euler angle representation of the rotation in degrees.
        */
        public get eulerAngles(): Vector3;
        public set eulerAngles(value: Vector3);
        /**
        * Returns this quaternion with a magnitude of 1 (Read Only).
        */
        public get normalized(): Quaternion;

        /**
        * Constructs new Quaternion with given x,y,z,w components.
        */
        public constructor ($x: float, $y: float, $z: float, $w: float)
        /**
        * Creates a rotation from fromDirection to toDirection.
        * @param fromDirection A non-unit or unit vector representing a direction axis to rotate.
        * @param toDirection A non-unit or unit vector representing the target direction axis.
        * @returns A unit quaternion which rotates from fromDirection to toDirection.
        */
        public static FromToRotation ($fromDirection: Vector3, $toDirection: Vector3) : Quaternion
        /**
        * Returns the Inverse of rotation.
        */
        public static Inverse ($rotation: Quaternion) : Quaternion
        /**
        * Spherically linear interpolates between unit quaternions a and b by a ratio of t.
        * @param a Start unit quaternion value, returned when t = 0.
        * @param b End unit quaternion value, returned when t = 1.
        * @param t Interpolation ratio. Value is clamped to the range [0, 1].
        * @returns A unit quaternion spherically interpolated between quaternions a and b.
        */
        public static Slerp ($a: Quaternion, $b: Quaternion, $t: float) : Quaternion
        /**
        * Spherically linear interpolates between unit quaternions a and b by t.
        * @param a Start unit quaternion value, returned when t = 0.
        * @param b End unit quaternion value, returned when t = 1.
        * @param t Interpolation ratio. Value is unclamped.
        * @returns A unit quaternion spherically interpolated between unit quaternions a and b.
        */
        public static SlerpUnclamped ($a: Quaternion, $b: Quaternion, $t: float) : Quaternion
        /**
        * Interpolates between a and b by t and normalizes the result afterwards.
        * @param a Start unit quaternion value, returned when t = 0.
        * @param b End unit quaternion value, returned when t = 1.
        * @param t Interpolation ratio. The value is clamped to the range [0, 1].
        * @returns A unit quaternion interpolated between quaternions a and b.
        */
        public static Lerp ($a: Quaternion, $b: Quaternion, $t: float) : Quaternion
        /**
        * Interpolates between a and b by t and normalizes the result afterwards. The parameter t is not clamped.
        */
        public static LerpUnclamped ($a: Quaternion, $b: Quaternion, $t: float) : Quaternion
        /**
        * Creates a rotation which rotates angle degrees around axis.
        */
        public static AngleAxis ($angle: float, $axis: Vector3) : Quaternion
        /**
        * Creates a rotation with the specified forward and upwards directions.
        * @param forward The direction to look in.
        * @param upwards The vector that defines in which direction up is.
        */
        public static LookRotation ($forward: Vector3, $upwards: Vector3) : Quaternion
        /**
        * Creates a rotation with the specified forward and upwards directions.
        * @param forward The direction to look in.
        * @param upwards The vector that defines in which direction up is.
        */
        public static LookRotation ($forward: Vector3) : Quaternion
        /**
        * Set x, y, z and w components of an existing Quaternion.
        */
        public Set ($newX: float, $newY: float, $newZ: float, $newW: float) : void
        /**
        * The dot product between two rotations.
        */
        public static Dot ($a: Quaternion, $b: Quaternion) : float
        /**
        * Creates a rotation with the specified forward and upwards directions.
        * @param view The direction to look in.
        * @param up The vector that defines in which direction up is.
        */
        public SetLookRotation ($view: Vector3) : void
        /**
        * Creates a rotation with the specified forward and upwards directions.
        * @param view The direction to look in.
        * @param up The vector that defines in which direction up is.
        */
        public SetLookRotation ($view: Vector3, $up: Vector3) : void
        /**
        * Returns the angle in degrees between two rotations a and b. The resulting angle ranges from 0 to 180.
        */
        public static Angle ($a: Quaternion, $b: Quaternion) : float
        /**
        * Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis; applied in that order.
        * @methodSwap Euler_EBB7509C_E4172388
        */
        public static Euler ($x: float, $y: float, $z: float) : Quaternion
        /**
        * Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis.
        */
        public static Euler ($euler: Vector3) : Quaternion
        /**
        * Converts a rotation to angle-axis representation (angles in degrees).
        */
        public ToAngleAxis ($angle: $Ref<float>, $axis: $Ref<Vector3>) : void
        /**
        * Creates a rotation which rotates from fromDirection to toDirection.
        */
        public SetFromToRotation ($fromDirection: Vector3, $toDirection: Vector3) : void
        /**
        * Rotates a rotation from towards to.
        * @param from The unit quaternion to be aligned with to.
        * @param to The target unit quaternion.
        * @param maxDegreesDelta The maximum angle in degrees allowed for this rotation.
        * @returns A unit quaternion rotated towards to by an angular step of maxDegreesDelta.
        */
        public static RotateTowards ($from: Quaternion, $to: Quaternion, $maxDegreesDelta: float) : Quaternion
        /**
        * Converts this quaternion to a quaternion with the same orientation but with a magnitude of 1.0.
        */
        public static Normalize ($q: Quaternion) : Quaternion
        public Normalize () : void
        public GetHashCode () : int
        public Equals ($other: any) : boolean
        public Equals ($other: Quaternion) : boolean
        /**
        * Returns a formatted string for this quaternion.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this quaternion.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this quaternion.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        public get_Item ($index: int) : float
        public set_Item ($index: int, $value: float) : void
        /**
        * Combines rotations lhs and rhs.
        * @param lhs Left-hand side quaternion.
        * @param rhs Right-hand side quaternion.
        */
        public static op_Multiply ($lhs: Quaternion, $rhs: Quaternion) : Quaternion
        /**
        * Rotates the point point with rotation.
        */
        public static op_Multiply ($rotation: Quaternion, $point: Vector3) : Vector3
        public static op_Equality ($lhs: Quaternion, $rhs: Quaternion) : boolean
        public static op_Inequality ($lhs: Quaternion, $rhs: Quaternion) : boolean
    }

    /**
    * A standard 4x4 transformation matrix.
    */
    class Matrix4x4 extends System.ValueType implements System.IFormattable, System.IEquatable$1<Matrix4x4> {

        public m00 : float
        public m10 : float
        public m20 : float
        public m30 : float
        public m01 : float
        public m11 : float
        public m21 : float
        public m31 : float
        public m02 : float
        public m12 : float
        public m22 : float
        public m32 : float
        public m03 : float
        public m13 : float
        public m23 : float
        public m33 : float
        /**
        * Attempts to get a rotation quaternion from this matrix.
        */
        public get rotation(): Quaternion;
        /**
        * Attempts to get a scale value from the matrix. (Read Only)
        */
        public get lossyScale(): Vector3;
        /**
        * Checks whether this is an identity matrix. (Read Only)
        */
        public get isIdentity(): boolean;
        /**
        * The determinant of the matrix. (Read Only)
        */
        public get determinant(): float;
        /**
        * This property takes a projection matrix and returns the six plane coordinates that define a projection frustum.
        */
        public get decomposeProjection(): FrustumPlanes;
        /**
        * The inverse of this matrix. (Read Only)
        */
        public get inverse(): Matrix4x4;
        /**
        * Returns the transpose of this matrix (Read Only).
        */
        public get transpose(): Matrix4x4;
        /**
        * Returns a matrix with all elements set to zero (Read Only).
        */
        public static get zero(): Matrix4x4;
        /**
        * Returns the identity matrix (Read Only).
        */
        public static get identity(): Matrix4x4;

        public constructor ($column0: Vector4, $column1: Vector4, $column2: Vector4, $column3: Vector4)
        /**
        * Checks if this matrix is a valid transform matrix.
        */
        public ValidTRS () : boolean
        public static Determinant ($m: Matrix4x4) : float
        /**
        * Creates a translation, rotation and scaling matrix.
        */
        public static TRS ($pos: Vector3, $q: Quaternion, $s: Vector3) : Matrix4x4
        /**
        * Sets this matrix to a translation, rotation and scaling matrix.
        */
        public SetTRS ($pos: Vector3, $q: Quaternion, $s: Vector3) : void
        /**
        * Computes the inverse of a 3D affine matrix.
        * @param input Input matrix to invert.
        * @param result The result of the inversion. Equal to the input matrix if the function fails.
        * @returns Returns true and a valid result if the function succeeds, false and a copy of the input matrix if the function fails.
        */
        public static Inverse3DAffine ($input: Matrix4x4, $result: $Ref<Matrix4x4>) : boolean
        public static Inverse ($m: Matrix4x4) : Matrix4x4
        public static Transpose ($m: Matrix4x4) : Matrix4x4
        /**
        * Create an orthogonal projection matrix.
        * @param left Left-side x-coordinate.
        * @param right Right-side x-coordinate.
        * @param bottom Bottom y-coordinate.
        * @param top Top y-coordinate.
        * @param zNear Near depth clipping plane value.
        * @param zFar Far depth clipping plane value.
        * @returns The projection matrix.
        */
        public static Ortho ($left: float, $right: float, $bottom: float, $top: float, $zNear: float, $zFar: float) : Matrix4x4
        /**
        * Create a perspective projection matrix.
        * @param fov Vertical field-of-view in degrees.
        * @param aspect Aspect ratio (width divided by height).
        * @param zNear Near depth clipping plane value.
        * @param zFar Far depth clipping plane value.
        * @returns The projection matrix.
        */
        public static Perspective ($fov: float, $aspect: float, $zNear: float, $zFar: float) : Matrix4x4
        /**
        * Create a "look at" matrix.
        * @param from The source point.
        * @param to The target point.
        * @param up The vector describing the up direction (typically Vector3.up).
        * @returns The resulting transformation matrix.
        */
        public static LookAt ($from: Vector3, $to: Vector3, $up: Vector3) : Matrix4x4
        /**
        * This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
        * @param left The X coordinate of the left side of the near projection plane in view space.
        * @param right The X coordinate of the right side of the near projection plane in view space.
        * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
        * @param top The Y coordinate of the top side of the near projection plane in view space.
        * @param zNear Z distance to the near plane from the origin in view space.
        * @param zFar Z distance to the far plane from the origin in view space.
        * @param frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
        * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in.
        * @methodSwap Frustum_EBB7509C_E1201BF3
        */
        public static Frustum ($left: float, $right: float, $bottom: float, $top: float, $zNear: float, $zFar: float) : Matrix4x4
        /**
        * This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
        * @param left The X coordinate of the left side of the near projection plane in view space.
        * @param right The X coordinate of the right side of the near projection plane in view space.
        * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
        * @param top The Y coordinate of the top side of the near projection plane in view space.
        * @param zNear Z distance to the near plane from the origin in view space.
        * @param zFar Z distance to the far plane from the origin in view space.
        * @param frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
        * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in.
        */
        public static Frustum ($fp: FrustumPlanes) : Matrix4x4
        public GetHashCode () : int
        public Equals ($other: any) : boolean
        public Equals ($other: Matrix4x4) : boolean
        /**
        * Get a column of the matrix.
        */
        public GetColumn ($index: int) : Vector4
        /**
        * Returns a row of the matrix.
        */
        public GetRow ($index: int) : Vector4
        /**
        * Get position vector from the matrix.
        */
        public GetPosition () : Vector3
        /**
        * Sets a column of the matrix.
        */
        public SetColumn ($index: int, $column: Vector4) : void
        /**
        * Sets a row of the matrix.
        */
        public SetRow ($index: int, $row: Vector4) : void
        /**
        * Transforms a position by this matrix (generic).
        */
        public MultiplyPoint ($point: Vector3) : Vector3
        /**
        * Transforms a position by this matrix (fast).
        */
        public MultiplyPoint3x4 ($point: Vector3) : Vector3
        /**
        * Transforms a direction by this matrix.
        */
        public MultiplyVector ($vector: Vector3) : Vector3
        /**
        * Returns a plane that is transformed in space.
        */
        public TransformPlane ($plane: Plane) : Plane
        /**
        * Creates a scaling matrix.
        */
        public static Scale ($vector: Vector3) : Matrix4x4
        /**
        * Creates a translation matrix.
        */
        public static Translate ($vector: Vector3) : Matrix4x4
        /**
        * Creates a rotation matrix.
        */
        public static Rotate ($q: Quaternion) : Matrix4x4
        /**
        * Returns a formatted string for this matrix.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this matrix.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this matrix.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        public get_Item ($index: int) : float
        public set_Item ($index: int, $value: float) : void
        /**
        * Multiplies two matrices.
        */
        public static op_Multiply ($lhs: Matrix4x4, $rhs: Matrix4x4) : Matrix4x4
        /**
        * Transforms a Vector4 by a matrix.
        */
        public static op_Multiply ($lhs: Matrix4x4, $vector: Vector4) : Vector4
        public static op_Equality ($lhs: Matrix4x4, $rhs: Matrix4x4) : boolean
        public static op_Inequality ($lhs: Matrix4x4, $rhs: Matrix4x4) : boolean
    }

    /**
    * This struct contains the view space coordinates of the near projection plane.
    */
    class FrustumPlanes extends System.ValueType {

        /**
        * Position in view space of the left side of the near projection plane.
        */
        public left : float
        /**
        * Position in view space of the right side of the near projection plane.
        */
        public right : float
        /**
        * Position in view space of the bottom side of the near projection plane.
        */
        public bottom : float
        /**
        * Position in view space of the top side of the near projection plane.
        */
        public top : float
        /**
        * Z distance from the origin of view space to the near projection plane.
        */
        public zNear : float
        /**
        * Z distance from the origin of view space to the far projection plane.
        */
        public zFar : float

    }

    /**
    * Representation of four-dimensional vectors.
    */
    class Vector4 extends System.ValueType implements System.IFormattable, System.IEquatable$1<Vector4> {

        public static kEpsilon : float
        /**
        * X component of the vector.
        */
        public x : float
        /**
        * Y component of the vector.
        */
        public y : float
        /**
        * Z component of the vector.
        */
        public z : float
        /**
        * W component of the vector.
        */
        public w : float
        /**
        * Returns a normalized vector based on the current vector. The normalized vector has a magnitude of 1 and is in the same direction as the current vector. Returns a zero vector If the current vector is too small to be normalized.
        */
        public get normalized(): Vector4;
        /**
        * Returns the length of this vector (Read Only).
        */
        public get magnitude(): float;
        /**
        * Returns the squared length of this vector (Read Only).
        */
        public get sqrMagnitude(): float;
        /**
        * Shorthand for writing Vector4(0,0,0,0).
        */
        public static get zero(): Vector4;
        /**
        * Shorthand for writing Vector4(1,1,1,1).
        */
        public static get one(): Vector4;
        /**
        * Shorthand for writing Vector4(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
        */
        public static get positiveInfinity(): Vector4;
        /**
        * Shorthand for writing Vector4(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
        */
        public static get negativeInfinity(): Vector4;

        /**
        * Creates a new vector with given x, y, z, w components.
        */
        public constructor ($x: float, $y: float, $z: float, $w: float)
        /**
        * Creates a new vector with given x, y, z components and sets w to zero.
        */
        public constructor ($x: float, $y: float, $z: float)
        /**
        * Creates a new vector with given x, y components and sets z and w to zero.
        */
        public constructor ($x: float, $y: float)
        /**
        * Set x, y, z and w components of an existing Vector4.
        */
        public Set ($newX: float, $newY: float, $newZ: float, $newW: float) : void
        /**
        * Linearly interpolates between two vectors.
        */
        public static Lerp ($a: Vector4, $b: Vector4, $t: float) : Vector4
        /**
        * Linearly interpolates between two vectors.
        */
        public static LerpUnclamped ($a: Vector4, $b: Vector4, $t: float) : Vector4
        /**
        * Moves a point current towards target.
        */
        public static MoveTowards ($current: Vector4, $target: Vector4, $maxDistanceDelta: float) : Vector4
        /**
        * Multiplies two vectors component-wise.
        */
        public static Scale ($a: Vector4, $b: Vector4) : Vector4
        /**
        * Multiplies every component of this vector by the same component of scale.
        */
        public Scale ($scale: Vector4) : void
        public GetHashCode () : int
        /**
        * Returns true if the given vector is exactly equal to this vector.
        */
        public Equals ($other: any) : boolean
        public Equals ($other: Vector4) : boolean
        /**
        * Returns a normalized vector based on the given vector. The normalized vector has a magnitude of 1 and is in the same direction as the given vector. Returns a zero vector If the given vector is too small to be normalized.
        * @param a The vector to be normalized.
        * @returns A new vector with the same direction as the original vector but with a magnitude of 1.0.
        */
        public static Normalize ($a: Vector4) : Vector4
        /**
        * Makes this vector have a magnitude of 1.
        */
        public Normalize () : void
        /**
        * Dot Product of two vectors.
        */
        public static Dot ($a: Vector4, $b: Vector4) : float
        /**
        * Projects a vector onto another vector.
        */
        public static Project ($a: Vector4, $b: Vector4) : Vector4
        /**
        * Returns the distance between a and b.
        */
        public static Distance ($a: Vector4, $b: Vector4) : float
        public static Magnitude ($a: Vector4) : float
        /**
        * Returns a vector that is made from the smallest components of two vectors.
        */
        public static Min ($lhs: Vector4, $rhs: Vector4) : Vector4
        /**
        * Returns a vector that is made from the largest components of two vectors.
        */
        public static Max ($lhs: Vector4, $rhs: Vector4) : Vector4
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        public static SqrMagnitude ($a: Vector4) : float
        public SqrMagnitude () : float
        public get_Item ($index: int) : float
        public set_Item ($index: int, $value: float) : void
        public static op_Addition ($a: Vector4, $b: Vector4) : Vector4
        public static op_Subtraction ($a: Vector4, $b: Vector4) : Vector4
        public static op_UnaryNegation ($a: Vector4) : Vector4
        /**
        * Multiplies a vector by a number.
        * @methodSwap op_Multiply_EBB7509C_B266FC40
        */
        public static op_Multiply ($a: Vector4, $d: float) : Vector4
        /**
        * Multiplies a vector by a number.
        * @methodSwap op_Multiply_EBB7509C_H6B445232
        */
        public static op_Multiply ($d: float, $a: Vector4) : Vector4
        public static op_Division ($a: Vector4, $d: float) : Vector4
        public static op_Equality ($lhs: Vector4, $rhs: Vector4) : boolean
        public static op_Inequality ($lhs: Vector4, $rhs: Vector4) : boolean
        public static op_Implicit ($v: Vector3) : Vector4
        public static op_Implicit ($v: Vector4) : Vector3
        public static op_Implicit ($v: Vector2) : Vector4
        public static op_Implicit ($v: Vector4) : Vector2
    }

    /**
    * Representation of 2D vectors and points.
    */
    class Vector2 extends System.ValueType implements System.IFormattable, System.IEquatable$1<Vector2> {

        /**
        * X component of the vector.
        */
        public x : float
        /**
        * Y component of the vector.
        */
        public y : float
        public static kEpsilon : float
        public static kEpsilonNormalSqrt : float
        /**
        * Returns a normalized vector based on the current vector. The normalized vector has a magnitude of 1 and is in the same direction as the current vector. Returns a zero vector If the current vector is too small to be normalized.
        */
        public get normalized(): Vector2;
        /**
        * Returns the length of this vector (Read Only).
        */
        public get magnitude(): float;
        /**
        * Returns the squared length of this vector (Read Only).
        */
        public get sqrMagnitude(): float;
        /**
        * Shorthand for writing Vector2(0, 0).
        */
        public static get zero(): Vector2;
        /**
        * Shorthand for writing Vector2(1, 1).
        */
        public static get one(): Vector2;
        /**
        * Shorthand for writing Vector2(0, 1).
        */
        public static get up(): Vector2;
        /**
        * Shorthand for writing Vector2(0, -1).
        */
        public static get down(): Vector2;
        /**
        * Shorthand for writing Vector2(-1, 0).
        */
        public static get left(): Vector2;
        /**
        * Shorthand for writing Vector2(1, 0).
        */
        public static get right(): Vector2;
        /**
        * Shorthand for writing Vector2(float.PositiveInfinity, float.PositiveInfinity).
        */
        public static get positiveInfinity(): Vector2;
        /**
        * Shorthand for writing Vector2(float.NegativeInfinity, float.NegativeInfinity).
        */
        public static get negativeInfinity(): Vector2;

        /**
        * Constructs a new vector with given x, y components.
        */
        public constructor ($x: float, $y: float)
        /**
        * Set x and y components of an existing Vector2.
        */
        public Set ($newX: float, $newY: float) : void
        /**
        * Linearly interpolates between vectors a and b by t.
        */
        public static Lerp ($a: Vector2, $b: Vector2, $t: float) : Vector2
        /**
        * Linearly interpolates between vectors a and b by t.
        */
        public static LerpUnclamped ($a: Vector2, $b: Vector2, $t: float) : Vector2
        /**
        * Moves a point current towards target.
        */
        public static MoveTowards ($current: Vector2, $target: Vector2, $maxDistanceDelta: float) : Vector2
        /**
        * Multiplies two vectors component-wise.
        */
        public static Scale ($a: Vector2, $b: Vector2) : Vector2
        /**
        * Multiplies every component of this vector by the same component of scale.
        */
        public Scale ($scale: Vector2) : void
        /**
        * Makes this vector have a magnitude of 1.
        */
        public Normalize () : void
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        public GetHashCode () : int
        /**
        * Returns true if the given vector is exactly equal to this vector.
        */
        public Equals ($other: any) : boolean
        public Equals ($other: Vector2) : boolean
        /**
        * Reflects a vector off the surface defined by a normal.
        * @param inDirection The direction vector towards the surface.
        * @param inNormal The normal vector that defines the surface.
        */
        public static Reflect ($inDirection: Vector2, $inNormal: Vector2) : Vector2
        /**
        * Returns the 2D vector perpendicular to this 2D vector. The result is always rotated 90-degrees in a counter-clockwise direction for a 2D coordinate system where the positive Y axis goes up.
        * @param inDirection The input direction.
        * @returns The perpendicular direction.
        */
        public static Perpendicular ($inDirection: Vector2) : Vector2
        /**
        * Dot Product of two vectors.
        */
        public static Dot ($lhs: Vector2, $rhs: Vector2) : float
        /**
        * Gets the unsigned angle in degrees between from and to.
        * @param from The vector from which the angular difference is measured.
        * @param to The vector to which the angular difference is measured.
        * @returns The unsigned angle in degrees between the two vectors.
        */
        public static Angle ($from: Vector2, $to: Vector2) : float
        /**
        * Gets the signed angle in degrees between from and to.
        * @param from The vector from which the angular difference is measured.
        * @param to The vector to which the angular difference is measured.
        * @returns The signed angle in degrees between the two vectors.
        */
        public static SignedAngle ($from: Vector2, $to: Vector2) : float
        /**
        * Returns the distance between a and b.
        */
        public static Distance ($a: Vector2, $b: Vector2) : float
        /**
        * Returns a copy of vector with its magnitude clamped to maxLength.
        */
        public static ClampMagnitude ($vector: Vector2, $maxLength: float) : Vector2
        public static SqrMagnitude ($a: Vector2) : float
        public SqrMagnitude () : float
        /**
        * Returns a vector that is made from the smallest components of two vectors.
        */
        public static Min ($lhs: Vector2, $rhs: Vector2) : Vector2
        /**
        * Returns a vector that is made from the largest components of two vectors.
        */
        public static Max ($lhs: Vector2, $rhs: Vector2) : Vector2
        /**
        * Gradually changes a vector towards a desired goal over time.
        * @param current The current position.
        * @param target The position we are trying to reach.
        * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
        * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
        * @param maxSpeed Optionally allows you to clamp the maximum speed.
        * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
        * @methodSwap SmoothDamp_EBB7509C_H9A9A7C86
        */
        public static SmoothDamp ($current: Vector2, $target: Vector2, $currentVelocity: $Ref<Vector2>, $smoothTime: float, $maxSpeed: float) : Vector2
        /**
        * Gradually changes a vector towards a desired goal over time.
        * @param current The current position.
        * @param target The position we are trying to reach.
        * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
        * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
        * @param maxSpeed Optionally allows you to clamp the maximum speed.
        * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
        * @methodSwap SmoothDamp_EBB7509C_B56F2819
        */
        public static SmoothDamp ($current: Vector2, $target: Vector2, $currentVelocity: $Ref<Vector2>, $smoothTime: float) : Vector2
        /**
        * Gradually changes a vector towards a desired goal over time.
        * @param current The current position.
        * @param target The position we are trying to reach.
        * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
        * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
        * @param maxSpeed Optionally allows you to clamp the maximum speed.
        * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
        * @methodSwap SmoothDamp_EBB7509C_ADA89C9F
        */
        public static SmoothDamp ($current: Vector2, $target: Vector2, $currentVelocity: $Ref<Vector2>, $smoothTime: float, $maxSpeed: float, $deltaTime: float) : Vector2
        public get_Item ($index: int) : float
        public set_Item ($index: int, $value: float) : void
        public static op_Addition ($a: Vector2, $b: Vector2) : Vector2
        public static op_Subtraction ($a: Vector2, $b: Vector2) : Vector2
        /**
        * Multiplies a vector by another vector.
        */
        public static op_Multiply ($a: Vector2, $b: Vector2) : Vector2
        public static op_Division ($a: Vector2, $b: Vector2) : Vector2
        public static op_UnaryNegation ($a: Vector2) : Vector2
        /**
        * Multiplies a vector by a number.
        * @methodSwap op_Multiply_EBB7509C_A1ECE456
        */
        public static op_Multiply ($a: Vector2, $d: float) : Vector2
        /**
        * Multiplies a vector by a number.
        * @methodSwap op_Multiply_EBB7509C_H654448C0
        */
        public static op_Multiply ($d: float, $a: Vector2) : Vector2
        /**
        * @methodSwap op_Division_EBB7509C_A1ECE456
        */
        public static op_Division ($a: Vector2, $d: float) : Vector2
        public static op_Equality ($lhs: Vector2, $rhs: Vector2) : boolean
        public static op_Inequality ($lhs: Vector2, $rhs: Vector2) : boolean
        public static op_Implicit ($v: Vector3) : Vector2
        public static op_Implicit ($v: Vector2) : Vector3
    }

    /**
    * Representation of a plane in 3D space.
    */
    class Plane extends System.ValueType implements System.IFormattable {

        /**
        * Normal vector of the plane.
        */
        public get normal(): Vector3;
        public set normal(value: Vector3);
        /**
        * The distance measured from the Plane to the origin, along the Plane's normal.
        */
        public get distance(): float;
        public set distance(value: float);
        /**
        * Returns a copy of the plane that faces in the opposite direction.
        */
        public get flipped(): Plane;

        /**
        * Creates a plane.
        */
        public constructor ($inNormal: Vector3, $inPoint: Vector3)
        /**
        * Creates a plane.
        */
        public constructor ($inNormal: Vector3, $d: float)
        /**
        * Creates a plane.
        */
        public constructor ($a: Vector3, $b: Vector3, $c: Vector3)
        /**
        * Sets a plane using a point that lies within it along with a normal to orient it.
        * @param inNormal The plane's normal vector.
        * @param inPoint A point that lies on the plane.
        */
        public SetNormalAndPosition ($inNormal: Vector3, $inPoint: Vector3) : void
        /**
        * Sets a plane using three points that lie within it.  The points go around clockwise as you look down on the top surface of the plane.
        * @param a First point in clockwise order.
        * @param b Second point in clockwise order.
        * @param c Third point in clockwise order.
        */
        public Set3Points ($a: Vector3, $b: Vector3, $c: Vector3) : void
        /**
        * Makes the plane face in the opposite direction.
        */
        public Flip () : void
        /**
        * Moves the plane in space by the translation vector.
        * @param translation The offset in space to move the plane with.
        */
        public Translate ($translation: Vector3) : void
        /**
        * Returns a copy of the given plane that is moved in space by the given translation.
        * @param plane The plane to move in space.
        * @param translation The offset in space to move the plane with.
        * @returns The translated plane.
        */
        public static Translate ($plane: Plane, $translation: Vector3) : Plane
        /**
        * For a given point returns the closest point on the plane.
        * @param point The point to project onto the plane.
        * @returns A point on the plane that is closest to point.
        */
        public ClosestPointOnPlane ($point: Vector3) : Vector3
        /**
        * Returns a signed distance from plane to point.
        */
        public GetDistanceToPoint ($point: Vector3) : float
        /**
        * Is a point on the positive side of the plane?
        */
        public GetSide ($point: Vector3) : boolean
        /**
        * Are two points on the same side of the plane?
        */
        public SameSide ($inPt0: Vector3, $inPt1: Vector3) : boolean
        /**
        * Intersects a ray with the plane.
        */
        public Raycast ($ray: Ray, $enter: $Ref<float>) : boolean
        public ToString () : string
        public ToString ($format: string) : string
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
    }

    /**
    * Representation of rays.
    */
    class Ray extends System.ValueType implements System.IFormattable {

        /**
        * The origin point of the ray.
        */
        public get origin(): Vector3;
        public set origin(value: Vector3);
        /**
        * The direction of the ray.
        */
        public get direction(): Vector3;
        public set direction(value: Vector3);

        /**
        * Creates a ray starting at origin along direction.
        */
        public constructor ($origin: Vector3, $direction: Vector3)
        /**
        * Returns a point at distance units along the ray.
        */
        public GetPoint ($distance: float) : Vector3
        /**
        * Returns a formatted string for this ray.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this ray.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this ray.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
    }

    /**
    * Base class for all entities in Unity Scenes.
    */
    class GameObject extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The layer the GameObject is in.
        */
        public get layer(): int;
        public set layer(value: int);
        /**
        * The local active state of this GameObject. (Read Only)
        */
        public get activeSelf(): boolean;
        /**
        * Defines whether the GameObject is active in the Scene.
        */
        public get activeInHierarchy(): boolean;
        /**
        * Gets and sets the GameObject's StaticEditorFlags.
        */
        public get isStatic(): boolean;
        public set isStatic(value: boolean);
        /**
        * The tag of this GameObject.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Scene that the GameObject is part of.
        */
        public get scene(): UnityEngine_SceneManagement.Scene;
        /**
        * Scene culling mask Unity uses to determine which scene to render the GameObject in.
        */
        public get sceneCullingMask(): bigint;
        public get gameObject(): GameObject;

        /**
        * Creates a new GameObject, named name.
        * @param name The name that the GameObject is created with.
        * @param components A list of Components to add to the GameObject on creation.
        */
        public constructor ($name: string)
        /**
        * Creates a new GameObject, named name.
        * @param name The name that the GameObject is created with.
        * @param components A list of Components to add to the GameObject on creation.
        */
        public constructor ()
        /**
        * Creates a new GameObject, named name.
        * @param name The name that the GameObject is created with.
        * @param components A list of Components to add to the GameObject on creation.
        */
        public constructor ($name: string, ...components: System.Type[])
        /**
        * Creates a GameObject with a primitive mesh renderer and appropriate collider.
        * @param type The type of primitive object to create.
        */
        public static CreatePrimitive ($type: PrimitiveType) : GameObject
        /**
        * Gets a reference to a component of type T on the specified GameObject.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The non-generic version of this method.
        * @param type The type of Component to search for.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to search for.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * This is the non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A component of the matching type, if found.
        */
        public GetComponentInChildren ($type: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A component of the matching type, if found.
        */
        public GetComponentInChildren ($type: System.Type) : Component
        public GetComponentInChildren<T> () : T
        /**
        * Gets a reference to a component of type T on the specified GameObject, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($type: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($type: System.Type) : Component
        public GetComponentInParent<T> () : T
        /**
        * Gets a reference to a component of type T on the specified GameObject, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the specified GameObject.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($type: System.Type) : Component[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($type: System.Type, $includeInactive: boolean) : Component[]
        /**
        * Gets references to all components of type T on the specified GameObject, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the specified GameObject, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        public GetComponentsInParent ($type: System.Type) : Component[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($type: System.Type, $includeInactive: boolean) : Component[]
        /**
        * Gets references to all components of type T on the specified GameObject, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the specified GameObject, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        /**
        * Returns one active GameObject tagged tag. Returns null if no GameObject was found.
        * @param tag The tag to search for.
        */
        public static FindWithTag ($tag: string) : GameObject
        /**
        * Adds a component class of type componentType to the GameObject. C# Users can use a generic version.
        */
        public AddComponent ($componentType: System.Type) : Component
        /**
        * Generic version of this method.
        */
        public AddComponent<T extends Component> () : T
        /**
        * Returns the number of components on this GameObject.
        * @returns The number of components.
        */
        public GetComponentCount () : int
        /**
        * Gets a reference to a component of type T at a specific index on the specified GameObject.
        * @param index The component index.
        * @returns A reference to a component of the type T at an index. Otherwise, returns null.
        * @methodSwap GetComponentAtIndex_EBB7509C_F92D023A
        */
        public GetComponentAtIndex ($index: int) : Component
        /**
        * Gets a reference to a component of type T at a specific index on the specified GameObject.
        * @param index The component index.
        * @returns A reference to a component of the type T at an index. Otherwise, returns null.
        * @methodSwap GetComponentAtIndex_EBB7509C_F92D023A
        */
        public GetComponentAtIndex<T extends Component> ($index: int) : T
        /**
        * Gets the index of the component specified on the specified GameObject.
        * @param component The component to search for.
        * @returns The component index. Otherwise, returns -1.
        */
        public GetComponentIndex ($component: Component) : int
        /**
        * ActivatesDeactivates the GameObject, depending on the given true or false/ value.
        * @param value Activate or deactivate the object, where true activates the GameObject and false deactivates the GameObject.
        */
        public SetActive ($value: boolean) : void
        /**
        * Is this GameObject tagged with tag ?
        * @param tag The tag to compare.
        */
        public CompareTag ($tag: string) : boolean
        public static FindGameObjectWithTag ($tag: string) : GameObject
        /**
        * Returns an array of active GameObjects tagged tag. Returns empty array if no GameObject was found.
        * @param tag The name of the tag to search GameObjects for.
        */
        public static FindGameObjectsWithTag ($tag: string) : GameObject[]
        /**
        * Finds a GameObject by name and returns it.
        */
        public static Find ($name: string) : GameObject
        public static SetGameObjectsActive ($instanceIDs: Unity_Collections.NativeArray$1<int>, $active: boolean) : void
        public static InstantiateGameObjects ($sourceInstanceID: int, $count: int, $newInstanceIDs: Unity_Collections.NativeArray$1<int>, $newTransformInstanceIDs: Unity_Collections.NativeArray$1<int>, $destinationScene?: UnityEngine_SceneManagement.Scene) : void
        /**
        * Returns the Scene of a GameObject given by instance ID.
        * @param instanceID The instance ID of a GameObject.
        * @returns Scene of GameObject of instance ID.
        */
        public static GetScene ($instanceID: int) : UnityEngine_SceneManagement.Scene
    }

    /**
    * Options to specify if and how to sort objects returned by a function.
    */
    enum FindObjectsSortMode {
        None = 0,
        InstanceID = 1 
    }

    /**
    * Options to control whether object find functions return inactive objects.
    */
    enum FindObjectsInactive {
        Exclude = 0,
        Include = 1 
    }

    /**
    * Bit mask that controls object destruction, saving and visibility in inspectors.
    */
    enum HideFlags {
        None = 0,
        HideInHierarchy = 1,
        HideInInspector = 2,
        DontSaveInEditor = 4,
        NotEditable = 8,
        DontSaveInBuild = 16,
        DontUnloadUnusedAsset = 32,
        DontSave = 52,
        HideAndDontSave = 61 
    }

    /**
    * Shader scripts used for all rendering.
    */
    class Shader extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Sets the limit on the number of shader variant chunks Unity loads and keeps in memory.
        */
        public static get maximumChunksOverride(): int;
        public static set maximumChunksOverride(value: int);
        /**
        * Shader LOD level for this shader.
        */
        public get maximumLOD(): int;
        public set maximumLOD(value: int);
        /**
        * Shader LOD level for all shaders.
        */
        public static get globalMaximumLOD(): int;
        public static set globalMaximumLOD(value: int);
        /**
        * Can this shader run on the end-users graphics card? (Read Only)
        */
        public get isSupported(): boolean;
        /**
        * Render pipeline currently in use.
        */
        public static get globalRenderPipeline(): string;
        public static set globalRenderPipeline(value: string);
        /**
        * An array containing the global shader keywords that are currently enabled.
        */
        public static get enabledGlobalKeywords(): UnityEngine_Rendering.GlobalKeyword[];
        /**
        * An array containing the global shader keywords that currently exist. This includes enabled and disabled global shader keywords.
        */
        public static get globalKeywords(): UnityEngine_Rendering.GlobalKeyword[];
        /**
        * The local keyword space of this shader.
        */
        public get keywordSpace(): UnityEngine_Rendering.LocalKeywordSpace;
        /**
        * Render queue of this shader. (Read Only)
        */
        public get renderQueue(): int;
        /**
        * Returns the number of shader passes on the active SubShader.
        */
        public get passCount(): int;
        /**
        * Returns the number of SubShaders in this shader.
        */
        public get subshaderCount(): int;

        /**
        * Finds a shader with the given name. Returns null if the shader is not found.
        */
        public static Find ($name: string) : Shader
        /**
        * Enables a global shader keyword.
        * @param keyword The name of the Rendering.GlobalKeyword to enable.
        */
        public static EnableKeyword ($keyword: string) : void
        /**
        * Disables a global shader keyword.
        * @param keyword The name of the Rendering.GlobalKeyword to disable.
        */
        public static DisableKeyword ($keyword: string) : void
        /**
        * Checks whether a global shader keyword is enabled.
        * @param keyword The name of the Rendering.GlobalKeyword to check.
        * @returns Returns true if a global shader keyword with the given name exists, and is enabled. Otherwise, returns false.
        */
        public static IsKeywordEnabled ($keyword: string) : boolean
        /**
        * Enables a global shader keyword.
        * @param keyword The name of the Rendering.GlobalKeyword to enable.
        */
        public static EnableKeyword ($keyword: $Ref<UnityEngine_Rendering.GlobalKeyword>) : void
        /**
        * Disables a global shader keyword.
        * @param keyword The name of the Rendering.GlobalKeyword to disable.
        */
        public static DisableKeyword ($keyword: $Ref<UnityEngine_Rendering.GlobalKeyword>) : void
        /**
        * Sets the state of a global shader keyword.
        * @param keyword The Rendering.GlobalKeyword to enable or disable.
        * @param value The desired keyword state.
        */
        public static SetKeyword ($keyword: $Ref<UnityEngine_Rendering.GlobalKeyword>, $value: boolean) : void
        /**
        * Checks whether a global shader keyword is enabled.
        * @param keyword The Rendering.GlobalKeyword to check.
        * @returns Returns true if the given global shader keyword is enabled. Otherwise, returns false.
        */
        public static IsKeywordEnabled ($keyword: $Ref<UnityEngine_Rendering.GlobalKeyword>) : boolean
        /**
        * Prewarms all shader variants of all Shaders currently in memory.
        */
        public static WarmupAllShaders () : void
        /**
        * Gets unique identifier for a shader property name.
        * @param name Shader property name.
        * @returns Unique integer for the name.
        */
        public static PropertyToID ($name: string) : int
        /**
        * Returns the dependency shader.
        * @param name The name of the dependency to query.
        */
        public GetDependency ($name: string) : Shader
        /**
        * Returns the number of passes in the given SubShader.
        * @param subshaderIndex The index of the SubShader.
        */
        public GetPassCountInSubshader ($subshaderIndex: int) : int
        /**
        * Searches for the tag specified by tagName on the shader's active SubShader and returns the value of the tag.
        * @param passIndex The index of the pass.
        * @param tagName The name of the tag.
        * @methodSwap FindPassTagValue_EBB7509C_H534A44B
        */
        public FindPassTagValue ($passIndex: int, $tagName: UnityEngine_Rendering.ShaderTagId) : UnityEngine_Rendering.ShaderTagId
        /**
        * Searches for the tag specified by tagName on the SubShader specified by subshaderIndex and returns the value of the tag.
        * @param subshaderIndex The index of the SubShader.
        * @param passIndex The index of the pass.
        * @param tagName The name of the tag.
        * @methodSwap FindPassTagValue_EBB7509C_E3DA861A
        */
        public FindPassTagValue ($subshaderIndex: int, $passIndex: int, $tagName: UnityEngine_Rendering.ShaderTagId) : UnityEngine_Rendering.ShaderTagId
        /**
        * Searches for the tag specified by tagName on the SubShader specified by subshaderIndex and returns the value of the tag.
        * @param subshaderIndex The index of the SubShader.
        * @param tagName The name of the tag.
        */
        public FindSubshaderTagValue ($subshaderIndex: int, $tagName: UnityEngine_Rendering.ShaderTagId) : UnityEngine_Rendering.ShaderTagId
        /**
        * This method is deprecated. Use SetGlobalFloat or SetGlobalInteger instead.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalInt_EBB7509C_H72D17FE0
        */
        public static SetGlobalInt ($name: string, $value: int) : void
        /**
        * This method is deprecated. Use SetGlobalFloat or SetGlobalInteger instead.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalInt_EBB7509C_H2CFB2EE5
        */
        public static SetGlobalInt ($nameID: int, $value: int) : void
        /**
        * Sets a global float property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalFloat_EBB7509C_H45FF9778
        */
        public static SetGlobalFloat ($name: string, $value: float) : void
        /**
        * Sets a global float property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalFloat_EBB7509C_A137D5B3
        */
        public static SetGlobalFloat ($nameID: int, $value: float) : void
        /**
        * Sets a global integer property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalInteger_EBB7509C_H72D17FE0
        */
        public static SetGlobalInteger ($name: string, $value: int) : void
        /**
        * Sets a global integer property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalInteger_EBB7509C_H2CFB2EE5
        */
        public static SetGlobalInteger ($nameID: int, $value: int) : void
        /**
        * Sets a global vector property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static SetGlobalVector ($name: string, $value: Vector4) : void
        /**
        * Sets a global vector property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalVector_EBB7509C_H9F0E6FE
        */
        public static SetGlobalVector ($nameID: int, $value: Vector4) : void
        /**
        * Sets a global color property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static SetGlobalColor ($name: string, $value: Color) : void
        /**
        * Sets a global color property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalColor_EBB7509C_H9F453824
        */
        public static SetGlobalColor ($nameID: int, $value: Color) : void
        /**
        * Sets a global matrix property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static SetGlobalMatrix ($name: string, $value: Matrix4x4) : void
        /**
        * Sets a global matrix property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalMatrix_EBB7509C_A704EAE0
        */
        public static SetGlobalMatrix ($nameID: int, $value: Matrix4x4) : void
        /**
        * Sets a global texture property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        */
        public static SetGlobalTexture ($name: string, $value: Texture) : void
        /**
        * Sets a global texture property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetGlobalTexture_EBB7509C_BEB5CD50
        */
        public static SetGlobalTexture ($nameID: int, $value: Texture) : void
        /**
        * Sets a global texture property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        */
        public static SetGlobalTexture ($name: string, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement) : void
        /**
        * Sets a global texture property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetGlobalTexture_EBB7509C_H63044826
        */
        public static SetGlobalTexture ($nameID: int, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement) : void
        /**
        * Sets a global buffer property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The buffer to set.
        */
        public static SetGlobalBuffer ($name: string, $value: ComputeBuffer) : void
        /**
        * Sets a global buffer property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The buffer to set.
        * @methodSwap SetGlobalBuffer_EBB7509C_E83D65D0
        */
        public static SetGlobalBuffer ($nameID: int, $value: ComputeBuffer) : void
        /**
        * Sets a global buffer property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The buffer to set.
        */
        public static SetGlobalBuffer ($name: string, $value: GraphicsBuffer) : void
        /**
        * Sets a global buffer property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The buffer to set.
        * @methodSwap SetGlobalBuffer_EBB7509C_EA6F5EB6
        */
        public static SetGlobalBuffer ($nameID: int, $value: GraphicsBuffer) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
        * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
        * @param name The name of the constant buffer to override.
        * @param value The buffer to override the constant buffer values with, or null to remove binding.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetGlobalConstantBuffer_EBB7509C_H1515F92F
        */
        public static SetGlobalConstantBuffer ($name: string, $value: ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
        * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
        * @param name The name of the constant buffer to override.
        * @param value The buffer to override the constant buffer values with, or null to remove binding.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetGlobalConstantBuffer_EBB7509C_H2CE47D04
        */
        public static SetGlobalConstantBuffer ($nameID: int, $value: ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
        * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
        * @param name The name of the constant buffer to override.
        * @param value The buffer to override the constant buffer values with, or null to remove binding.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetGlobalConstantBuffer_EBB7509C_H369B14DB
        */
        public static SetGlobalConstantBuffer ($name: string, $value: GraphicsBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
        * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
        * @param name The name of the constant buffer to override.
        * @param value The buffer to override the constant buffer values with, or null to remove binding.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetGlobalConstantBuffer_EBB7509C_H30D518B2
        */
        public static SetGlobalConstantBuffer ($nameID: int, $value: GraphicsBuffer, $offset: int, $size: int) : void
        public static SetGlobalFloatArray ($name: string, $values: System_Collections_Generic.List$1<float>) : void
        /**
        * @methodSwap SetGlobalFloatArray_EBB7509C_E8859065
        */
        public static SetGlobalFloatArray ($nameID: int, $values: System_Collections_Generic.List$1<float>) : void
        /**
        * Sets a global float array property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static SetGlobalFloatArray ($name: string, $values: float[]) : void
        /**
        * Sets a global float array property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalFloatArray_EBB7509C_H4A792FF
        */
        public static SetGlobalFloatArray ($nameID: int, $values: float[]) : void
        public static SetGlobalVectorArray ($name: string, $values: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * @methodSwap SetGlobalVectorArray_EBB7509C_H5C64F93A
        */
        public static SetGlobalVectorArray ($nameID: int, $values: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * Sets a global vector array property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static SetGlobalVectorArray ($name: string, $values: Vector4[]) : void
        /**
        * Sets a global vector array property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalVectorArray_EBB7509C_H500372C6
        */
        public static SetGlobalVectorArray ($nameID: int, $values: Vector4[]) : void
        public static SetGlobalMatrixArray ($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * @methodSwap SetGlobalMatrixArray_EBB7509C_H73E77D48
        */
        public static SetGlobalMatrixArray ($nameID: int, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * Sets a global matrix array property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static SetGlobalMatrixArray ($name: string, $values: Matrix4x4[]) : void
        /**
        * Sets a global matrix array property for all shaders.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap SetGlobalMatrixArray_EBB7509C_H4B572A74
        */
        public static SetGlobalMatrixArray ($nameID: int, $values: Matrix4x4[]) : void
        /**
        * This method is deprecated. Use GetGlobalFloat or GetGlobalInteger instead.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static GetGlobalInt ($name: string) : int
        /**
        * This method is deprecated. Use GetGlobalFloat or GetGlobalInteger instead.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetGlobalInt_EBB7509C_F92D023A
        */
        public static GetGlobalInt ($nameID: int) : int
        /**
        * Gets a global float property for all shaders previously set using SetGlobalFloat.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static GetGlobalFloat ($name: string) : float
        /**
        * Gets a global float property for all shaders previously set using SetGlobalFloat.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetGlobalFloat_EBB7509C_F92D023A
        */
        public static GetGlobalFloat ($nameID: int) : float
        /**
        * Gets a global integer property for all shaders previously set using SetGlobalInteger.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static GetGlobalInteger ($name: string) : int
        /**
        * Gets a global integer property for all shaders previously set using SetGlobalInteger.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetGlobalInteger_EBB7509C_F92D023A
        */
        public static GetGlobalInteger ($nameID: int) : int
        /**
        * Gets a global vector property for all shaders previously set using SetGlobalVector.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static GetGlobalVector ($name: string) : Vector4
        /**
        * Gets a global vector property for all shaders previously set using SetGlobalVector.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetGlobalVector_EBB7509C_F92D023A
        */
        public static GetGlobalVector ($nameID: int) : Vector4
        /**
        * Gets a global color property for all shaders previously set using SetGlobalColor.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static GetGlobalColor ($name: string) : Color
        /**
        * Gets a global color property for all shaders previously set using SetGlobalColor.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetGlobalColor_EBB7509C_F92D023A
        */
        public static GetGlobalColor ($nameID: int) : Color
        /**
        * Gets a global matrix property for all shaders previously set using SetGlobalMatrix.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static GetGlobalMatrix ($name: string) : Matrix4x4
        /**
        * Gets a global matrix property for all shaders previously set using SetGlobalMatrix.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetGlobalMatrix_EBB7509C_F92D023A
        */
        public static GetGlobalMatrix ($nameID: int) : Matrix4x4
        /**
        * Gets a global texture property for all shaders previously set using SetGlobalTexture.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static GetGlobalTexture ($name: string) : Texture
        /**
        * Gets a global texture property for all shaders previously set using SetGlobalTexture.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetGlobalTexture_EBB7509C_F92D023A
        */
        public static GetGlobalTexture ($nameID: int) : Texture
        /**
        * Gets a global float array for all shaders previously set using SetGlobalFloatArray.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static GetGlobalFloatArray ($name: string) : float[]
        /**
        * Gets a global float array for all shaders previously set using SetGlobalFloatArray.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetGlobalFloatArray_EBB7509C_F92D023A
        */
        public static GetGlobalFloatArray ($nameID: int) : float[]
        /**
        * Gets a global vector array for all shaders previously set using SetGlobalVectorArray.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static GetGlobalVectorArray ($name: string) : Vector4[]
        /**
        * Gets a global vector array for all shaders previously set using SetGlobalVectorArray.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetGlobalVectorArray_EBB7509C_F92D023A
        */
        public static GetGlobalVectorArray ($nameID: int) : Vector4[]
        /**
        * Gets a global matrix array for all shaders previously set using SetGlobalMatrixArray.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public static GetGlobalMatrixArray ($name: string) : Matrix4x4[]
        /**
        * Gets a global matrix array for all shaders previously set using SetGlobalMatrixArray.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetGlobalMatrixArray_EBB7509C_F92D023A
        */
        public static GetGlobalMatrixArray ($nameID: int) : Matrix4x4[]
        public static GetGlobalFloatArray ($name: string, $values: System_Collections_Generic.List$1<float>) : void
        /**
        * @methodSwap GetGlobalFloatArray_EBB7509C_E8859065
        */
        public static GetGlobalFloatArray ($nameID: int, $values: System_Collections_Generic.List$1<float>) : void
        public static GetGlobalVectorArray ($name: string, $values: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * @methodSwap GetGlobalVectorArray_EBB7509C_H5C64F93A
        */
        public static GetGlobalVectorArray ($nameID: int, $values: System_Collections_Generic.List$1<Vector4>) : void
        public static GetGlobalMatrixArray ($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * @methodSwap GetGlobalMatrixArray_EBB7509C_H73E77D48
        */
        public static GetGlobalMatrixArray ($nameID: int, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * Returns the number of properties in this Shader.
        */
        public GetPropertyCount () : int
        /**
        * Finds the index of a shader property by its name.
        * @param propertyName The name of the shader property.
        */
        public FindPropertyIndex ($propertyName: string) : int
        /**
        * Returns the name of the shader property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyName ($propertyIndex: int) : string
        /**
        * Returns the nameId of the shader property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyNameId ($propertyIndex: int) : int
        /**
        * Returns the ShaderPropertyType of the property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyType ($propertyIndex: int) : UnityEngine_Rendering.ShaderPropertyType
        /**
        * Returns the description string of the shader property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyDescription ($propertyIndex: int) : string
        /**
        * Returns the ShaderPropertyFlags of the shader property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyFlags ($propertyIndex: int) : UnityEngine_Rendering.ShaderPropertyFlags
        /**
        * Returns an array of strings containing attributes of the shader property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyAttributes ($propertyIndex: int) : string[]
        /**
        * Returns the default float value of the shader property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyDefaultFloatValue ($propertyIndex: int) : float
        /**
        * Returns the default Vector4 value of the shader property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyDefaultVectorValue ($propertyIndex: int) : Vector4
        /**
        * Returns the min and max limits for a <a href="Rendering.ShaderPropertyType.Range.html">Range</a> property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyRangeLimits ($propertyIndex: int) : Vector2
        /**
        * Returns the default int value of the shader property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyDefaultIntValue ($propertyIndex: int) : int
        /**
        * Returns the TextureDimension of a <a href="Rendering.ShaderPropertyType.Texture.html">Texture</a> shader property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyTextureDimension ($propertyIndex: int) : UnityEngine_Rendering.TextureDimension
        /**
        * Returns the default Texture name of a <a href="Rendering.ShaderPropertyType.Texture.html">Texture</a> shader property at the specified index.
        * @param propertyIndex The index of the shader property.
        */
        public GetPropertyTextureDefaultName ($propertyIndex: int) : string
        /**
        * Find the name of a texture stack a texture belongs too.
        * @param propertyIndex Index of the property.
        * @param stackName On exit, contanis the name of the stack if one was found.
        * @param layerIndex On exit, contains the stack layer index of the texture property.
        * @returns True, if a stack was found for the given texture property, false if not.
        */
        public FindTextureStack ($propertyIndex: int, $stackName: $Ref<string>, $layerIndex: $Ref<int>) : boolean
    }

    /**
    * Representation of RGBA colors.
    */
    class Color extends System.ValueType implements System.IFormattable, System.IEquatable$1<Color> {

        /**
        * Red component of the color.
        */
        public r : float
        /**
        * Green component of the color.
        */
        public g : float
        /**
        * Blue component of the color.
        */
        public b : float
        /**
        * Alpha component of the color (0 is transparent, 1 is opaque).
        */
        public a : float
        /**
        * Solid red. RGBA is (1, 0, 0, 1).
        */
        public static get red(): Color;
        /**
        * Solid green. RGBA is (0, 1, 0, 1).
        */
        public static get green(): Color;
        /**
        * Solid blue. RGBA is (0, 0, 1, 1).
        */
        public static get blue(): Color;
        /**
        * Solid white. RGBA is (1, 1, 1, 1).
        */
        public static get white(): Color;
        /**
        * Solid black. RGBA is (0, 0, 0, 1).
        */
        public static get black(): Color;
        /**
        * Yellow. RGBA is (1, 0.92, 0.016, 1), but the color is nice to look at!
        */
        public static get yellow(): Color;
        /**
        * Cyan. RGBA is (0, 1, 1, 1).
        */
        public static get cyan(): Color;
        /**
        * Magenta. RGBA is (1, 0, 1, 1).
        */
        public static get magenta(): Color;
        /**
        * Gray. RGBA is (0.5, 0.5, 0.5, 1).
        */
        public static get gray(): Color;
        /**
        * English spelling for gray. RGBA is the same (0.5, 0.5, 0.5, 1).
        */
        public static get grey(): Color;
        /**
        * Completely transparent. RGBA is (0, 0, 0, 0).
        */
        public static get clear(): Color;
        /**
        * The grayscale value of the color. (Read Only)
        */
        public get grayscale(): float;
        /**
        * A linear value of an sRGB color.
        */
        public get linear(): Color;
        /**
        * A version of the color that has had the gamma curve applied.
        */
        public get gamma(): Color;
        /**
        * Returns the maximum color component value: Max(r,g,b).
        */
        public get maxColorComponent(): float;

        /**
        * Constructs a new Color with given r,g,b,a components.
        * @param r Red component.
        * @param g Green component.
        * @param b Blue component.
        * @param a Alpha component.
        */
        public constructor ($r: float, $g: float, $b: float, $a: float)
        /**
        * Constructs a new Color with given r,g,b components and sets a to 1.
        * @param r Red component.
        * @param g Green component.
        * @param b Blue component.
        */
        public constructor ($r: float, $g: float, $b: float)
        /**
        * Returns a formatted string of this color.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string of this color.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string of this color.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        public GetHashCode () : int
        public Equals ($other: any) : boolean
        public Equals ($other: Color) : boolean
        /**
        * Linearly interpolates between colors a and b by t.
        * @param a Color a.
        * @param b Color b.
        * @param t Float for combining a and b.
        */
        public static Lerp ($a: Color, $b: Color, $t: float) : Color
        /**
        * Linearly interpolates between colors a and b by t.
        */
        public static LerpUnclamped ($a: Color, $b: Color, $t: float) : Color
        /**
        * Calculates the hue, saturation and value of an RGB input color.
        * @param rgbColor An input color.
        * @param H Output variable for hue.
        * @param S Output variable for saturation.
        * @param V Output variable for value.
        */
        public static RGBToHSV ($rgbColor: Color, $H: $Ref<float>, $S: $Ref<float>, $V: $Ref<float>) : void
        /**
        * Creates an RGB colour from HSV input.
        * @param H Hue [0..1].
        * @param S Saturation [0..1].
        * @param V Brightness value [0..1].
        * @param hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
        * @returns An opaque colour with HSV matching the input.
        * @methodSwap HSVToRGB_EBB7509C_E4172388
        */
        public static HSVToRGB ($H: float, $S: float, $V: float) : Color
        /**
        * Creates an RGB colour from HSV input.
        * @param H Hue [0..1].
        * @param S Saturation [0..1].
        * @param V Brightness value [0..1].
        * @param hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
        * @returns An opaque colour with HSV matching the input.
        * @methodSwap HSVToRGB_EBB7509C_D759CB93
        */
        public static HSVToRGB ($H: float, $S: float, $V: float, $hdr: boolean) : Color
        public get_Item ($index: int) : float
        public set_Item ($index: int, $value: float) : void
        public static op_Addition ($a: Color, $b: Color) : Color
        public static op_Subtraction ($a: Color, $b: Color) : Color
        /**
        * Multiplies two colors together. Each component is multiplied separately.
        */
        public static op_Multiply ($a: Color, $b: Color) : Color
        /**
        * Multiplies color a by the float b. Each color component is scaled separately.
        * @methodSwap op_Multiply_EBB7509C_ADA1E93A
        */
        public static op_Multiply ($a: Color, $b: float) : Color
        /**
        * Multiplies color a by the float b. Each color component is scaled separately.
        * @methodSwap op_Multiply_EBB7509C_H80CC07E8
        */
        public static op_Multiply ($b: float, $a: Color) : Color
        public static op_Division ($a: Color, $b: float) : Color
        public static op_Equality ($lhs: Color, $rhs: Color) : boolean
        public static op_Inequality ($lhs: Color, $rhs: Color) : boolean
        public static op_Implicit ($c: Color) : Vector4
        public static op_Implicit ($v: Vector4) : Color
    }

    /**
    * Base class for Texture handling.
    */
    class Texture extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
        */
        public static GenerateAllMips : int
        /**
        * How many mipmap levels are in this Texture (Read Only).
        */
        public get mipmapCount(): int;
        public static get anisotropicFiltering(): AnisotropicFiltering;
        public static set anisotropicFiltering(value: AnisotropicFiltering);
        /**
        * Returns the GraphicsFormat format or color format of a Texture object.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
        * Width of the Texture in pixels (Read Only).
        */
        public get width(): int;
        public set width(value: int);
        /**
        * Height of the Texture in pixels (Read Only).
        */
        public get height(): int;
        public set height(value: int);
        /**
        * Dimensionality (type) of the Texture (Read Only).
        */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
        * Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
        */
        public get isReadable(): boolean;
        /**
        * Texture coordinate wrapping mode.
        */
        public get wrapMode(): TextureWrapMode;
        public set wrapMode(value: TextureWrapMode);
        /**
        * Texture U coordinate wrapping mode.
        */
        public get wrapModeU(): TextureWrapMode;
        public set wrapModeU(value: TextureWrapMode);
        /**
        * Texture V coordinate wrapping mode.
        */
        public get wrapModeV(): TextureWrapMode;
        public set wrapModeV(value: TextureWrapMode);
        /**
        * Texture W coordinate wrapping mode for Texture3D.
        */
        public get wrapModeW(): TextureWrapMode;
        public set wrapModeW(value: TextureWrapMode);
        /**
        * Filtering mode of the Texture.
        */
        public get filterMode(): FilterMode;
        public set filterMode(value: FilterMode);
        /**
        * Defines the anisotropic filtering level of the Texture.
        */
        public get anisoLevel(): int;
        public set anisoLevel(value: int);
        /**
        * The mipmap bias of the Texture.
        */
        public get mipMapBias(): float;
        public set mipMapBias(value: float);
        public get texelSize(): Vector2;
        /**
        * This counter is incremented when the Texture is updated.
        */
        public get updateCount(): uint;
        /**
        * Returns true if the texture pixel data is in sRGB color space (Read Only).
        */
        public get isDataSRGB(): boolean;
        /**
        * The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0.
        * This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually.
        * To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`.
        * `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get totalTextureMemory(): bigint;
        /**
        * The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.
        * For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.
        * The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
        */
        public static get desiredTextureMemory(): bigint;
        /**
        * The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get targetTextureMemory(): bigint;
        /**
        * The amount of memory that all Textures in the scene use.
        */
        public static get currentTextureMemory(): bigint;
        /**
        * The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureMemory(): bigint;
        /**
        * How many times has a Texture been uploaded due to Texture mipmap streaming.
        */
        public static get streamingMipmapUploadCount(): bigint;
        /**
        * Number of renderers registered with the Texture streaming system.
        */
        public static get streamingRendererCount(): bigint;
        /**
        * Number of streaming Textures.
        */
        public static get streamingTextureCount(): bigint;
        /**
        * The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureCount(): bigint;
        /**
        * Number of streaming Textures with outstanding mipmaps to be loaded.
        */
        public static get streamingTexturePendingLoadCount(): bigint;
        /**
        * Number of streaming Textures with mipmaps currently loading.
        */
        public static get streamingTextureLoadingCount(): bigint;
        /**
        * Force streaming Textures to load all mipmap levels.
        */
        public static get streamingTextureForceLoadAll(): boolean;
        public static set streamingTextureForceLoadAll(value: boolean);
        /**
        * This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
        */
        public static get streamingTextureDiscardUnusedMips(): boolean;
        public static set streamingTextureDiscardUnusedMips(value: boolean);
        /**
        * Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
        */
        public static get allowThreadedTextureCreation(): boolean;
        public static set allowThreadedTextureCreation(value: boolean);

        /**
        * Sets Anisotropic limits.
        */
        public static SetGlobalAnisotropicFilteringLimits ($forcedMin: int, $globalMax: int) : void
        /**
        * Retrieve a native (underlying graphics API) pointer to the Texture resource.
        * @returns Pointer to an underlying graphics API Texture resource.
        */
        public GetNativeTexturePtr () : System.IntPtr
        /**
        * Increment the update counter.
        */
        public IncrementUpdateCount () : void
        /**
        * This function sets mipmap streaming debug properties on any materials that use this Texture through the mipmap streaming system.
        */
        public static SetStreamingTextureMaterialDebugProperties () : void
    }

    /**
    * Anisotropic filtering mode.
    */
    enum AnisotropicFiltering {
        Disable = 0,
        Enable = 1,
        ForceEnable = 2 
    }

    /**
    * Wrap mode for textures.
    */
    enum TextureWrapMode {
        Repeat = 0,
        Clamp = 1,
        Mirror = 2,
        MirrorOnce = 3 
    }

    /**
    * Filtering mode for textures. Corresponds to the settings in a.
    */
    enum FilterMode {
        Point = 0,
        Bilinear = 1,
        Trilinear = 2 
    }

    /**
    * Render textures are textures that can be rendered to.
    */
    class RenderTexture extends Texture {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
        */
        public static GenerateAllMips : int
        /**
        * How many mipmap levels are in this Texture (Read Only).
        */
        public get mipmapCount(): int;
        public static get anisotropicFiltering(): AnisotropicFiltering;
        public static set anisotropicFiltering(value: AnisotropicFiltering);
        /**
        * Returns the GraphicsFormat format or color format of a Texture object.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
        * Width of the Texture in pixels (Read Only).
        */
        public get width(): int;
        public set width(value: int);
        /**
        * Height of the Texture in pixels (Read Only).
        */
        public get height(): int;
        public set height(value: int);
        /**
        * Dimensionality (type) of the Texture (Read Only).
        */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
        * Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
        */
        public get isReadable(): boolean;
        /**
        * Texture coordinate wrapping mode.
        */
        public get wrapMode(): TextureWrapMode;
        public set wrapMode(value: TextureWrapMode);
        /**
        * Texture U coordinate wrapping mode.
        */
        public get wrapModeU(): TextureWrapMode;
        public set wrapModeU(value: TextureWrapMode);
        /**
        * Texture V coordinate wrapping mode.
        */
        public get wrapModeV(): TextureWrapMode;
        public set wrapModeV(value: TextureWrapMode);
        /**
        * Texture W coordinate wrapping mode for Texture3D.
        */
        public get wrapModeW(): TextureWrapMode;
        public set wrapModeW(value: TextureWrapMode);
        /**
        * Filtering mode of the Texture.
        */
        public get filterMode(): FilterMode;
        public set filterMode(value: FilterMode);
        /**
        * Defines the anisotropic filtering level of the Texture.
        */
        public get anisoLevel(): int;
        public set anisoLevel(value: int);
        /**
        * The mipmap bias of the Texture.
        */
        public get mipMapBias(): float;
        public set mipMapBias(value: float);
        public get texelSize(): Vector2;
        /**
        * This counter is incremented when the Texture is updated.
        */
        public get updateCount(): uint;
        /**
        * Returns true if the texture pixel data is in sRGB color space (Read Only).
        */
        public get isDataSRGB(): boolean;
        /**
        * The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0.
        * This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually.
        * To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`.
        * `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get totalTextureMemory(): bigint;
        /**
        * The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.
        * For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.
        * The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
        */
        public static get desiredTextureMemory(): bigint;
        /**
        * The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get targetTextureMemory(): bigint;
        /**
        * The amount of memory that all Textures in the scene use.
        */
        public static get currentTextureMemory(): bigint;
        /**
        * The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureMemory(): bigint;
        /**
        * How many times has a Texture been uploaded due to Texture mipmap streaming.
        */
        public static get streamingMipmapUploadCount(): bigint;
        /**
        * Number of renderers registered with the Texture streaming system.
        */
        public static get streamingRendererCount(): bigint;
        /**
        * Number of streaming Textures.
        */
        public static get streamingTextureCount(): bigint;
        /**
        * The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureCount(): bigint;
        /**
        * Number of streaming Textures with outstanding mipmaps to be loaded.
        */
        public static get streamingTexturePendingLoadCount(): bigint;
        /**
        * Number of streaming Textures with mipmaps currently loading.
        */
        public static get streamingTextureLoadingCount(): bigint;
        /**
        * Force streaming Textures to load all mipmap levels.
        */
        public static get streamingTextureForceLoadAll(): boolean;
        public static set streamingTextureForceLoadAll(value: boolean);
        /**
        * This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
        */
        public static get streamingTextureDiscardUnusedMips(): boolean;
        public static set streamingTextureDiscardUnusedMips(value: boolean);
        /**
        * Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
        */
        public static get allowThreadedTextureCreation(): boolean;
        public static set allowThreadedTextureCreation(value: boolean);
        /**
        * Render texture has mipmaps when this flag is set.
        */
        public get useMipMap(): boolean;
        public set useMipMap(value: boolean);
        /**
        * Does this render texture use sRGB read/write conversions? (Read Only).
        */
        public get sRGB(): boolean;
        /**
        * If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any.
        */
        public get vrUsage(): VRTextureUsage;
        public set vrUsage(value: VRTextureUsage);
        /**
        * The render texture memoryless mode property.
        */
        public get memorylessMode(): RenderTextureMemoryless;
        public set memorylessMode(value: RenderTextureMemoryless);
        public get format(): RenderTextureFormat;
        public set format(value: RenderTextureFormat);
        /**
        * The format of the stencil data that you can encapsulate within a RenderTexture.
        * Specifying this property creates a stencil element for the RenderTexture and sets its format.
        * This allows for stencil data to be bound as a Texture to all shader types for the platforms that support it.
        * This property does not specify the format of the stencil buffer, which is constrained by the depth buffer format specified in RenderTexture.depth.
        * Currently, most platforms only support R8_UInt (DirectX11, DirectX12), while PS4 also supports R8_UNorm.
        */
        public get stencilFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set stencilFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
        * The format of the depth/stencil buffer.
        */
        public get depthStencilFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set depthStencilFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
        * Mipmap levels are generated automatically when this flag is set.
        */
        public get autoGenerateMips(): boolean;
        public set autoGenerateMips(value: boolean);
        /**
        * Volume extent of a 3D render texture or number of slices of array texture.
        */
        public get volumeDepth(): int;
        public set volumeDepth(value: int);
        /**
        * The antialiasing level for the RenderTexture.
        */
        public get antiAliasing(): int;
        public set antiAliasing(value: int);
        /**
        * If true and antiAliasing is greater than 1, the render texture will not be resolved by default.  Use this if the render texture needs to be bound as a multisampled texture in a shader.
        */
        public get bindTextureMS(): boolean;
        public set bindTextureMS(value: boolean);
        /**
        * Enable random access write into this render texture on Shader Model 5.0 level shaders.
        */
        public get enableRandomWrite(): boolean;
        public set enableRandomWrite(value: boolean);
        /**
        * Is the render texture marked to be scaled by the.
        */
        public get useDynamicScale(): boolean;
        public set useDynamicScale(value: boolean);
        public get isPowerOfTwo(): boolean;
        public set isPowerOfTwo(value: boolean);
        /**
        * Currently active render texture.
        */
        public static get active(): RenderTexture;
        public static set active(value: RenderTexture);
        /**
        * Color buffer of the render texture (Read Only).
        */
        public get colorBuffer(): RenderBuffer;
        /**
        * Depth/stencil buffer of the render texture (Read Only).
        */
        public get depthBuffer(): RenderBuffer;
        /**
        * The precision of the render texture's depth buffer in bits (0, 16, 24 and 32 are supported).
        */
        public get depth(): int;
        public set depth(value: int);
        /**
        * This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties.
        */
        public get descriptor(): RenderTextureDescriptor;
        public set descriptor(value: RenderTextureDescriptor);

        /**
        * Creates a new RenderTexture object.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param depth Number of bits in depth buffer (0, 16, 24 or 32). Note that only 24 and 32 bit depth have stencil buffer support.
        * @param format Texture color format.
        * @param colorFormat The color format for the RenderTexture.
        * @param depthStencilFormat The depth stencil format for the RenderTexture.
        * @param mipCount Amount of mips to allocate for the RenderTexture.
        * @param readWrite How color space conversions are applied on texture read/write.
        * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
        * @param textureToCopy Copy the settings from another RenderTexture.
        */
        public constructor ($desc: RenderTextureDescriptor)
        /**
        * Creates a new RenderTexture object.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param depth Number of bits in depth buffer (0, 16, 24 or 32). Note that only 24 and 32 bit depth have stencil buffer support.
        * @param format Texture color format.
        * @param colorFormat The color format for the RenderTexture.
        * @param depthStencilFormat The depth stencil format for the RenderTexture.
        * @param mipCount Amount of mips to allocate for the RenderTexture.
        * @param readWrite How color space conversions are applied on texture read/write.
        * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
        * @param textureToCopy Copy the settings from another RenderTexture.
        */
        public constructor ($textureToCopy: RenderTexture)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: int)
        public constructor ($width: int, $height: int, $colorFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: int)
        public constructor ($width: int, $height: int, $colorFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine_Experimental_Rendering.GraphicsFormat)
        /**
        * Creates a new RenderTexture object.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param depth Number of bits in depth buffer (0, 16, 24 or 32). Note that only 24 and 32 bit depth have stencil buffer support.
        * @param format Texture color format.
        * @param colorFormat The color format for the RenderTexture.
        * @param depthStencilFormat The depth stencil format for the RenderTexture.
        * @param mipCount Amount of mips to allocate for the RenderTexture.
        * @param readWrite How color space conversions are applied on texture read/write.
        * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
        * @param textureToCopy Copy the settings from another RenderTexture.
        */
        public constructor ($width: int, $height: int, $depth: int, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite)
        /**
        * Creates a new RenderTexture object.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param depth Number of bits in depth buffer (0, 16, 24 or 32). Note that only 24 and 32 bit depth have stencil buffer support.
        * @param format Texture color format.
        * @param colorFormat The color format for the RenderTexture.
        * @param depthStencilFormat The depth stencil format for the RenderTexture.
        * @param mipCount Amount of mips to allocate for the RenderTexture.
        * @param readWrite How color space conversions are applied on texture read/write.
        * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
        * @param textureToCopy Copy the settings from another RenderTexture.
        */
        public constructor ($width: int, $height: int, $depth: int, $format: RenderTextureFormat)
        /**
        * Creates a new RenderTexture object.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param depth Number of bits in depth buffer (0, 16, 24 or 32). Note that only 24 and 32 bit depth have stencil buffer support.
        * @param format Texture color format.
        * @param colorFormat The color format for the RenderTexture.
        * @param depthStencilFormat The depth stencil format for the RenderTexture.
        * @param mipCount Amount of mips to allocate for the RenderTexture.
        * @param readWrite How color space conversions are applied on texture read/write.
        * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
        * @param textureToCopy Copy the settings from another RenderTexture.
        */
        public constructor ($width: int, $height: int, $depth: int)
        public constructor ($width: int, $height: int, $depth: int, $format: RenderTextureFormat, $mipCount: int)
        /**
        * Retrieve a native (underlying graphics API) pointer to the depth buffer resource.
        * @returns Pointer to an underlying graphics API depth buffer resource.
        */
        public GetNativeDepthBufferPtr () : System.IntPtr
        /**
        * Hint the GPU driver that the contents of the RenderTexture will not be used.
        * @param discardColor Should the colour buffer be discarded?
        * @param discardDepth Should the depth buffer be discarded?
        */
        public DiscardContents ($discardColor: boolean, $discardDepth: boolean) : void
        /**
        * Hint the GPU driver that the contents of the RenderTexture will not be used.
        * @param discardColor Should the colour buffer be discarded?
        * @param discardDepth Should the depth buffer be discarded?
        */
        public DiscardContents () : void
        /**
        * Force an antialiased render texture to be resolved.
        * @param target The render texture to resolve into.  If set, the target render texture must have the same dimensions and format as the source.
        */
        public ResolveAntiAliasedSurface () : void
        /**
        * Force an antialiased render texture to be resolved.
        * @param target The render texture to resolve into.  If set, the target render texture must have the same dimensions and format as the source.
        */
        public ResolveAntiAliasedSurface ($target: RenderTexture) : void
        /**
        * Assigns this RenderTexture as a global shader property named propertyName.
        */
        public SetGlobalShaderProperty ($propertyName: string) : void
        /**
        * Actually creates the RenderTexture.
        * @returns True if the texture is created, else false.
        */
        public Create () : boolean
        /**
        * Releases the RenderTexture.
        */
        public Release () : void
        /**
        * Is the render texture actually created?
        */
        public IsCreated () : boolean
        /**
        * Generate mipmap levels of a render texture.
        */
        public GenerateMips () : void
        /**
        * Converts the render texture to equirectangular format (both stereoscopic or monoscopic equirect).
        * The left eye will occupy the top half and the right eye will occupy the bottom. The monoscopic version will occupy the whole texture.
        * Texture dimension must be of type TextureDimension.Cube.
        * @param equirect RenderTexture to render the equirect format to.
        * @param eye A Camera eye corresponding to the left or right eye for stereoscopic rendering, or neither for monoscopic rendering.
        */
        public ConvertToEquirect ($equirect: RenderTexture, $eye?: UnityEngine_Camera.MonoOrStereoscopicEye) : void
        /**
        * Does a RenderTexture have stencil buffer?
        * @param rt Render texture, or null for main screen.
        */
        public static SupportsStencil ($rt: RenderTexture) : boolean
        /**
        * Release a temporary texture allocated with GetTemporary.
        */
        public static ReleaseTemporary ($temp: RenderTexture) : void
        /**
        * Allocate a temporary render texture.
        * @param width Width in pixels.
        * @param height Height in pixels.
        * @param depthBuffer Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
        * @param format Render texture format.
        * @param readWrite Color space conversion mode.
        * @param antiAliasing Number of antialiasing samples to store in the texture. Valid values are 1, 2, 4, and 8. Throws an exception if any other value is passed.
        * @param memorylessMode Render texture memoryless mode.
        * @param vrUsage How Unity uses the RenderTexture as a VR eye texture. The default is VRTextureUsage.None.
        * @param useDynamicScale Determines whether Unity scales the render texture using. The default is false.
        * @param desc Use this RenderTextureDesc for the settings when creating the temporary RenderTexture.
        */
        public static GetTemporary ($desc: RenderTextureDescriptor) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_H2AA7764E
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: int, $memorylessMode: RenderTextureMemoryless, $vrUsage: VRTextureUsage, $useDynamicScale: boolean) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_EB297D21
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: int, $memorylessMode: RenderTextureMemoryless, $vrUsage: VRTextureUsage) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_H24260160
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: int, $memorylessMode: RenderTextureMemoryless) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_C2545C7C
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: int) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_H12B3389B
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat) : RenderTexture
        /**
        * Allocate a temporary render texture.
        * @param width Width in pixels.
        * @param height Height in pixels.
        * @param depthBuffer Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
        * @param format Render texture format.
        * @param readWrite Color space conversion mode.
        * @param antiAliasing Number of antialiasing samples to store in the texture. Valid values are 1, 2, 4, and 8. Throws an exception if any other value is passed.
        * @param memorylessMode Render texture memoryless mode.
        * @param vrUsage How Unity uses the RenderTexture as a VR eye texture. The default is VRTextureUsage.None.
        * @param useDynamicScale Determines whether Unity scales the render texture using. The default is false.
        * @param desc Use this RenderTextureDesc for the settings when creating the temporary RenderTexture.
        * @methodSwap GetTemporary_EBB7509C_H9DDD9271
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite, $antiAliasing: int, $memorylessMode: RenderTextureMemoryless, $vrUsage: VRTextureUsage, $useDynamicScale: boolean) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_H9BA2D132
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite, $antiAliasing: int, $memorylessMode: RenderTextureMemoryless, $vrUsage: VRTextureUsage) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_H932D6C9B
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite, $antiAliasing: int, $memorylessMode: RenderTextureMemoryless) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_H54A595E9
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite, $antiAliasing: int) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_H5FC81EB6
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_H88EA33B7
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int, $format: RenderTextureFormat) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_H71E348A6
        */
        public static GetTemporary ($width: int, $height: int, $depthBuffer: int) : RenderTexture
        /**
        * @methodSwap GetTemporary_EBB7509C_H2CFB2EE5
        */
        public static GetTemporary ($width: int, $height: int) : RenderTexture
        public constructor ()
    }

    /**
    * This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties. Avoid using the default constructor as it does not initialize some flags with the recommended values.
    */
    class RenderTextureDescriptor extends System.ValueType {

        /**
        * The width of the render texture in pixels.
        */
        public get width(): int;
        public set width(value: int);
        /**
        * The height of the render texture in pixels.
        */
        public get height(): int;
        public set height(value: int);
        /**
        * The multisample antialiasing level for the RenderTexture.
        * Additional resources: RenderTexture.antiAliasing.
        */
        public get msaaSamples(): int;
        public set msaaSamples(value: int);
        /**
        * Volume extent of a 3D render texture.
        */
        public get volumeDepth(): int;
        public set volumeDepth(value: int);
        /**
        * User-defined mipmap count.
        */
        public get mipCount(): int;
        public set mipCount(value: int);
        /**
        * The color format for the RenderTexture. You can set this format to None to achieve depth-only rendering.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set graphicsFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
        * The format of the stencil data that you can encapsulate within a RenderTexture.
        * Specifying this property creates a stencil element for the RenderTexture and sets its format.
        * This allows for stencil data to be bound as a Texture to all shader types for the platforms that support it.
        * This property does not specify the format of the stencil buffer, which is constrained by the depth buffer format specified in RenderTexture.depth.
        * Currently, most platforms only support R8_UInt (DirectX11, DirectX12), while PS4 also supports R8_UNorm.
        */
        public get stencilFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set stencilFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
        * The desired format of the depth/stencil buffer.
        */
        public get depthStencilFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set depthStencilFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
        * The format of the RenderTarget is expressed as a RenderTextureFormat. Internally, this format is stored as a GraphicsFormat compatible with the current system (see SystemInfo.GetCompatibleFormat). Therefore, if you set a format and immediately get it again, it may return a different result from the one just set.
        */
        public get colorFormat(): RenderTextureFormat;
        public set colorFormat(value: RenderTextureFormat);
        /**
        * This flag causes the render texture uses sRGB read/write conversions.
        */
        public get sRGB(): boolean;
        public set sRGB(value: boolean);
        /**
        * The precision of the render texture's depth buffer in bits (0, 16, 24 and 32 are supported).
        */
        public get depthBufferBits(): int;
        public set depthBufferBits(value: int);
        /**
        * Dimensionality (type) of the render texture.
        * Additional resources: RenderTexture.dimension.
        */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
        * Determines how the RenderTexture is sampled if it is used as a shadow map.
        * Additional resources: ShadowSamplingMode for more details.
        */
        public get shadowSamplingMode(): UnityEngine_Rendering.ShadowSamplingMode;
        public set shadowSamplingMode(value: UnityEngine_Rendering.ShadowSamplingMode);
        /**
        * If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any. Instead of setting this manually, use the value returned by XR.XRSettings.eyeTextureDesc|eyeTextureDesc or other VR functions returning a RenderTextureDescriptor.
        */
        public get vrUsage(): VRTextureUsage;
        public set vrUsage(value: VRTextureUsage);
        /**
        * A set of RenderTextureCreationFlags that control how the texture is created.
        */
        public get flags(): RenderTextureCreationFlags;
        /**
        * The render texture memoryless mode property.
        */
        public get memoryless(): RenderTextureMemoryless;
        public set memoryless(value: RenderTextureMemoryless);
        /**
        * Render texture has mipmaps when this flag is set.
        * Additional resources: RenderTexture.useMipMap.
        */
        public get useMipMap(): boolean;
        public set useMipMap(value: boolean);
        /**
        * Mipmap levels are generated automatically when this flag is set.
        */
        public get autoGenerateMips(): boolean;
        public set autoGenerateMips(value: boolean);
        /**
        * Enable random access write into this render texture on Shader Model 5.0 level shaders.
        * Additional resources: RenderTexture.enableRandomWrite.
        */
        public get enableRandomWrite(): boolean;
        public set enableRandomWrite(value: boolean);
        /**
        * If true and msaaSamples is greater than 1, the render texture will not be resolved by default.  Use this if the render texture needs to be bound as a multisampled texture in a shader.
        */
        public get bindMS(): boolean;
        public set bindMS(value: boolean);
        /**
        * Set to true to enable dynamic resolution scaling on this render texture.
        * Additional resources: RenderTexture.useDynamicScale.
        */
        public get useDynamicScale(): boolean;
        public set useDynamicScale(value: boolean);

        public constructor ($width: int, $height: int)
        public constructor ($width: int, $height: int, $colorFormat: RenderTextureFormat)
        public constructor ($width: int, $height: int, $colorFormat: RenderTextureFormat, $depthBufferBits: int)
        public constructor ($width: int, $height: int, $colorFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $depthBufferBits: int)
        public constructor ($width: int, $height: int, $colorFormat: RenderTextureFormat, $depthBufferBits: int, $mipCount: int)
        /**
        * Create a RenderTextureDescriptor with default values, or a certain width, height, and format.
        * @param width Width of the RenderTexture in pixels.
        * @param height Height of the RenderTexture in pixels.
        * @param colorFormat The color format for the RenderTexture.
        * @param depthStencilFormat The depth stencil format for the RenderTexture.
        * @param depthBufferBits The number of bits to use for the depth buffer.
        * @param mipCount Amount of mips to allocate for the RenderTexture.
        * @param readWrite How color space conversions are applied on texture read/write.
        */
        public constructor ($width: int, $height: int, $colorFormat: RenderTextureFormat, $depthBufferBits: int, $mipCount: int, $readWrite: RenderTextureReadWrite)
        public constructor ($width: int, $height: int, $colorFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $depthBufferBits: int, $mipCount: int)
        public constructor ($width: int, $height: int, $colorFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine_Experimental_Rendering.GraphicsFormat)
        public constructor ($width: int, $height: int, $colorFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: int)
    }

    /**
    * Format of a RenderTexture.
    */
    enum RenderTextureFormat {
        ARGB32 = 0,
        Depth = 1,
        ARGBHalf = 2,
        Shadowmap = 3,
        RGB565 = 4,
        ARGB4444 = 5,
        ARGB1555 = 6,
        Default = 7,
        ARGB2101010 = 8,
        DefaultHDR = 9,
        ARGB64 = 10,
        ARGBFloat = 11,
        RGFloat = 12,
        RGHalf = 13,
        RFloat = 14,
        RHalf = 15,
        R8 = 16,
        ARGBInt = 17,
        RGInt = 18,
        RInt = 19,
        BGRA32 = 20,
        RGB111110Float = 22,
        RG32 = 23,
        RGBAUShort = 24,
        RG16 = 25,
        BGRA10101010_XR = 26,
        BGR101010_XR = 27,
        R16 = 28 
    }

    /**
    * Color space conversion mode of a RenderTexture.
    */
    enum RenderTextureReadWrite {
        Default = 0,
        Linear = 1,
        sRGB = 2 
    }

    /**
    * This enum describes how the RenderTexture is used as a VR eye texture. Instead of using the values of this enum manually, use the value returned by XR.XRSettings.eyeTextureDesc|eyeTextureDesc or other VR functions returning a RenderTextureDescriptor.
    */
    enum VRTextureUsage {
        None = 0,
        OneEye = 1,
        TwoEyes = 2,
        DeviceSpecific = 3 
    }

    /**
    * Set of flags that control the state of a newly-created RenderTexture.
    */
    enum RenderTextureCreationFlags {
        MipMap = 1,
        AutoGenerateMips = 2,
        SRGB = 4,
        EyeTexture = 8,
        EnableRandomWrite = 16,
        CreatedFromScript = 32,
        AllowVerticalFlip = 128,
        NoResolvedColorSurface = 256,
        DynamicallyScalable = 1024,
        BindMS = 2048 
    }

    /**
    * Flags enumeration of the render texture memoryless modes.
    */
    enum RenderTextureMemoryless {
        None = 0,
        Color = 1,
        Depth = 2,
        MSAA = 4 
    }

    /**
    * Color or depth buffer part of a RenderTexture.
    */
    class RenderBuffer extends System.ValueType {

        /**
        * Returns native RenderBuffer. Be warned this is not native Texture, but rather pointer to unity struct that can be used with native unity API. Currently such API exists only on iOS.
        */
        public GetNativeRenderBufferPtr () : System.IntPtr
    }

    /**
    * GPU data buffer, mostly for use with compute shaders.
    */
    class ComputeBuffer extends System.Object implements System.IDisposable {

        /**
        * Number of elements in the buffer (Read Only).
        */
        public get count(): int;
        /**
        * Size of one element in the buffer in bytes (Read Only).
        */
        public get stride(): int;
        /**
        * The debug label for the compute buffer (setter only).
        */
        public set name(value: string);

        /**
        * Create a Compute Buffer.
        * @param count Number of elements in the buffer.
        * @param stride Size of one element in the buffer, in bytes. Must be a multiple of 4 and less than 2048, and match the size of the buffer type in the shader. See for cross-platform compatibility information.
        * @param type Type of the buffer, default is ComputeBufferType.Default (structured buffer).
        * @param usage Usage mode of the buffer, default is ComputeBufferModeImmutable.
        */
        public constructor ($count: int, $stride: int)
        /**
        * Create a Compute Buffer.
        * @param count Number of elements in the buffer.
        * @param stride Size of one element in the buffer, in bytes. Must be a multiple of 4 and less than 2048, and match the size of the buffer type in the shader. See for cross-platform compatibility information.
        * @param type Type of the buffer, default is ComputeBufferType.Default (structured buffer).
        * @param usage Usage mode of the buffer, default is ComputeBufferModeImmutable.
        */
        public constructor ($count: int, $stride: int, $type: ComputeBufferType)
        /**
        * Create a Compute Buffer.
        * @param count Number of elements in the buffer.
        * @param stride Size of one element in the buffer, in bytes. Must be a multiple of 4 and less than 2048, and match the size of the buffer type in the shader. See for cross-platform compatibility information.
        * @param type Type of the buffer, default is ComputeBufferType.Default (structured buffer).
        * @param usage Usage mode of the buffer, default is ComputeBufferModeImmutable.
        */
        public constructor ($count: int, $stride: int, $type: ComputeBufferType, $usage: ComputeBufferMode)
        public Dispose () : void
        /**
        * Release a Compute Buffer.
        */
        public Release () : void
        /**
        * Returns true if this compute buffer is valid and false otherwise.
        */
        public IsValid () : boolean
        /**
        * Set the buffer with values from an array.
        * @param data Array of values to fill the buffer.
        */
        public SetData ($data: System.Array) : void
        public SetData<T> ($data: System_Collections_Generic.List$1<T>) : void
        public SetData<T> ($data: Unity_Collections.NativeArray$1<T>) : void
        /**
        * Partial copy of data values from an array into the buffer.
        * @param data Array of values to fill the buffer.
        * @param managedBufferStartIndex The first element index in data to copy to the compute buffer.
        * @param computeBufferStartIndex The first element index in compute buffer to receive the data.
        * @param count The number of elements to copy.
        * @methodSwap SetData_EBB7509C_H7AD849AC
        */
        public SetData ($data: System.Array, $managedBufferStartIndex: int, $computeBufferStartIndex: int, $count: int) : void
        /**
        * @methodSwap SetData_EBB7509C_H7097CF04
        */
        public SetData<T> ($data: System_Collections_Generic.List$1<T>, $managedBufferStartIndex: int, $computeBufferStartIndex: int, $count: int) : void
        /**
        * @methodSwap SetData_EBB7509C_H2855E7A5
        */
        public SetData<T> ($data: Unity_Collections.NativeArray$1<T>, $nativeBufferStartIndex: int, $computeBufferStartIndex: int, $count: int) : void
        /**
        * Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
        * @param data An array to receive the data.
        */
        public GetData ($data: System.Array) : void
        /**
        * Partial read of data values from the buffer into an array.
        * @param data An array to receive the data.
        * @param managedBufferStartIndex The first element index in data where retrieved elements are copied.
        * @param computeBufferStartIndex The first element index of the compute buffer from which elements are read.
        * @param count The number of elements to retrieve.
        * @methodSwap GetData_EBB7509C_H7AD849AC
        */
        public GetData ($data: System.Array, $managedBufferStartIndex: int, $computeBufferStartIndex: int, $count: int) : void
        /**
        * Begins a write operation to the buffer
        * @param computeBufferStartIndex Offset in number of elements to which the write operation will occur
        * @param count Maximum number of elements which will be written
        * @returns A NativeArray of size count
        */
        public BeginWrite<T> ($computeBufferStartIndex: int, $count: int) : Unity_Collections.NativeArray$1<T>
        /**
        * Ends a write operation to the buffer
        * @param countWritten Number of elements written to the buffer. Counted from the first element.
        */
        public EndWrite<T> ($countWritten: int) : void
        /**
        * Sets counter value of append/consume buffer.
        * @param counterValue Value of the append/consume counter.
        */
        public SetCounterValue ($counterValue: uint) : void
        /**
        * Copy counter value of append/consume buffer into another buffer.
        * @param src Append/consume buffer to copy the counter from.
        * @param dst A buffer to copy the counter to.
        * @param dstOffsetBytes Target byte offset in dst.
        */
        public static CopyCount ($src: ComputeBuffer, $dst: ComputeBuffer, $dstOffsetBytes: int) : void
        /**
        * Retrieve a native (underlying graphics API) pointer to the buffer.
        * @returns Pointer to the underlying graphics API buffer.
        */
        public GetNativeBufferPtr () : System.IntPtr
    }

    /**
    * ComputeBuffer type.
    */
    enum ComputeBufferType {
        Default = 0,
        Raw = 1,
        Append = 2,
        Counter = 4,
        Constant = 8,
        Structured = 16,
        DrawIndirect = 256,
        IndirectArguments = 256,
        GPUMemory = 512 
    }

    /**
    * Intended usage of the buffer.
    */
    enum ComputeBufferMode {
        Immutable = 0,
        Dynamic = 1,
        Circular = 2,
        StreamOut = 3,
        SubUpdates = 4 
    }

    /**
    * GPU graphics data buffer, for working with geometry or compute shader data.
    */
    class GraphicsBuffer extends System.Object implements System.IDisposable {

        /**
        * Number of elements in the buffer (Read Only).
        */
        public get count(): int;
        /**
        * Size of one element in the buffer. For index buffers, this must be either 2 or 4 bytes (Read Only).
        */
        public get stride(): int;
        /**
        * Target, which specifies the intended target(s) of this GraphicsBuffer (Read Only).
        */
        public get target(): UnityEngine_GraphicsBuffer.Target;
        /**
        * The flags that specify how this GraphicsBuffer can be used or updated (Read Only).
        */
        public get usageFlags(): UnityEngine_GraphicsBuffer.UsageFlags;
        /**
        * The internal handle of this GraphicsBuffer. Only valid until the buffer is disposed of. (Read Only)
        */
        public get bufferHandle(): GraphicsBufferHandle;
        /**
        * The debug label for the graphics buffer (setter only).
        */
        public set name(value: string);

        /**
        * Create a Graphics Buffer.
        * @param target Specify how this buffer can be used within the graphics pipeline.
        * @param count Number of elements in the buffer.
        * @param stride Size of one element in the buffer. For index buffers, this must be either 2 or 4 bytes.
        */
        public constructor ($target: UnityEngine_GraphicsBuffer.Target, $count: int, $stride: int)
        /**
        * Create a Graphics Buffer.
        * @param target Specify how this buffer can be used within the graphics pipeline.
        * @param usageFlags Select what kind of update mode the buffer will have.
        * @param count Number of elements in the buffer.
        * @param stride Size of one element in the buffer. For index buffers, this must be either 2 or 4 bytes.
        */
        public constructor ($target: UnityEngine_GraphicsBuffer.Target, $usageFlags: UnityEngine_GraphicsBuffer.UsageFlags, $count: int, $stride: int)
        public Dispose () : void
        /**
        * Release a Graphics Buffer.
        */
        public Release () : void
        /**
        * Returns true if this graphics buffer is valid, or false otherwise.
        */
        public IsValid () : boolean
        /**
        * Set the buffer with values from an array.
        * @param data Array of values to fill the buffer.
        */
        public SetData ($data: System.Array) : void
        public SetData<T> ($data: System_Collections_Generic.List$1<T>) : void
        public SetData<T> ($data: Unity_Collections.NativeArray$1<T>) : void
        /**
        * Partial copy of data values from an array into the buffer.
        * @param data Array of values to fill the buffer.
        * @param managedBufferStartIndex The first element index in data to copy to the graphics buffer.
        * @param count The number of elements to copy.
        * @param graphicsBufferStartIndex The first element index in the graphics buffer to receive the data.
        * @methodSwap SetData_EBB7509C_H7AD849AC
        */
        public SetData ($data: System.Array, $managedBufferStartIndex: int, $graphicsBufferStartIndex: int, $count: int) : void
        /**
        * @methodSwap SetData_EBB7509C_H7097CF04
        */
        public SetData<T> ($data: System_Collections_Generic.List$1<T>, $managedBufferStartIndex: int, $graphicsBufferStartIndex: int, $count: int) : void
        /**
        * @methodSwap SetData_EBB7509C_H2855E7A5
        */
        public SetData<T> ($data: Unity_Collections.NativeArray$1<T>, $nativeBufferStartIndex: int, $graphicsBufferStartIndex: int, $count: int) : void
        /**
        * Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
        * @param data An array to receive the data.
        * @param managedBufferStartIndex The first element index in data where retrieved elements are copied.
        * @param computeBufferStartIndex The first element index of the buffer from which elements are read.
        * @param count The number of elements to retrieve.
        */
        public GetData ($data: System.Array) : void
        /**
        * Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
        * @param data An array to receive the data.
        * @param managedBufferStartIndex The first element index in data where retrieved elements are copied.
        * @param computeBufferStartIndex The first element index of the buffer from which elements are read.
        * @param count The number of elements to retrieve.
        * @methodSwap GetData_EBB7509C_H7AD849AC
        */
        public GetData ($data: System.Array, $managedBufferStartIndex: int, $computeBufferStartIndex: int, $count: int) : void
        /**
        * Retrieve a native (underlying graphics API) pointer to the buffer.
        * @returns Pointer to the underlying graphics API buffer.
        */
        public GetNativeBufferPtr () : System.IntPtr
        /**
        * Begins a write operation to the buffer
        * @param bufferStartIndex The index of an element where the write operation begins.
        * @param count Maximum number of elements which will be written
        * @returns A NativeArray of size count
        */
        public LockBufferForWrite<T> ($bufferStartIndex: int, $count: int) : Unity_Collections.NativeArray$1<T>
        /**
        * Ends a write operation to the buffer
        * @param countWritten Number of elements written to the buffer. Counted from the first element.
        */
        public UnlockBufferAfterWrite<T> ($countWritten: int) : void
        /**
        * Sets counter value of append/consume buffer.
        * @param counterValue Value of the append/consume counter.
        */
        public SetCounterValue ($counterValue: uint) : void
        /**
        * Copy the counter value of a GraphicsBuffer into another buffer.
        * @param src The source GraphicsBuffer.
        * @param dst The destination GraphicsBuffer.
        * @param dstOffsetBytes The destination buffer offset in bytes.
        * @methodSwap CopyCount_EBB7509C_BB45AFE2
        */
        public static CopyCount ($src: ComputeBuffer, $dst: ComputeBuffer, $dstOffsetBytes: int) : void
        /**
        * Copy the counter value of a GraphicsBuffer into another buffer.
        * @param src The source GraphicsBuffer.
        * @param dst The destination GraphicsBuffer.
        * @param dstOffsetBytes The destination buffer offset in bytes.
        * @methodSwap CopyCount_EBB7509C_FAE93792
        */
        public static CopyCount ($src: GraphicsBuffer, $dst: ComputeBuffer, $dstOffsetBytes: int) : void
        /**
        * Copy the counter value of a GraphicsBuffer into another buffer.
        * @param src The source GraphicsBuffer.
        * @param dst The destination GraphicsBuffer.
        * @param dstOffsetBytes The destination buffer offset in bytes.
        * @methodSwap CopyCount_EBB7509C_F1B2B38A
        */
        public static CopyCount ($src: ComputeBuffer, $dst: GraphicsBuffer, $dstOffsetBytes: int) : void
        /**
        * Copy the counter value of a GraphicsBuffer into another buffer.
        * @param src The source GraphicsBuffer.
        * @param dst The destination GraphicsBuffer.
        * @param dstOffsetBytes The destination buffer offset in bytes.
        * @methodSwap CopyCount_EBB7509C_E0BB6D9A
        */
        public static CopyCount ($src: GraphicsBuffer, $dst: GraphicsBuffer, $dstOffsetBytes: int) : void
    }

    /**
    * Represents the internal handle/id of a GraphicsBuffer.
    */
    class GraphicsBufferHandle extends System.ValueType implements System.IEquatable$1<GraphicsBufferHandle> {

        public value : uint

        public GetHashCode () : int
        public Equals ($obj: any) : boolean
        public Equals ($other: GraphicsBufferHandle) : boolean
        public CompareTo ($other: GraphicsBufferHandle) : int
        public static op_Equality ($a: GraphicsBufferHandle, $b: GraphicsBufferHandle) : boolean
        public static op_Inequality ($a: GraphicsBufferHandle, $b: GraphicsBufferHandle) : boolean
    }

    /**
    * Compute Shader asset.
    */
    class ComputeShader extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The local keyword space of this compute shader.
        */
        public get keywordSpace(): UnityEngine_Rendering.LocalKeywordSpace;
        /**
        * An array containing names of the local shader keywords that are currently enabled for this compute shader.
        */
        public get shaderKeywords(): string[];
        public set shaderKeywords(value: string[]);
        /**
        * An array containing the local shader keywords that are currently enabled for this compute shader.
        */
        public get enabledKeywords(): UnityEngine_Rendering.LocalKeyword[];
        public set enabledKeywords(value: UnityEngine_Rendering.LocalKeyword[]);

        /**
        * Find ComputeShader kernel index.
        * @param name Name of kernel function.
        * @returns The Kernel index. If the kernel is not found, Unity logs a "FindKernel failed" error message and raises an ArgumentException.
        */
        public FindKernel ($name: string) : int
        /**
        * Checks whether a shader contains a given kernel.
        * @param name The name of the kernel to look for.
        * @returns True if the kernel is found, false otherwise.
        */
        public HasKernel ($name: string) : boolean
        /**
        * Set a float parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param val Value to set.
        * @methodSwap SetFloat_EBB7509C_A137D5B3
        */
        public SetFloat ($nameID: int, $val: float) : void
        /**
        * Set an integer parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param val Value to set.
        * @methodSwap SetInt_EBB7509C_H2CFB2EE5
        */
        public SetInt ($nameID: int, $val: int) : void
        /**
        * Set a vector parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param val Value to set.
        * @methodSwap SetVector_EBB7509C_H9F0E6FE
        */
        public SetVector ($nameID: int, $val: Vector4) : void
        /**
        * Set a Matrix parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param val Value to set.
        * @methodSwap SetMatrix_EBB7509C_A704EAE0
        */
        public SetMatrix ($nameID: int, $val: Matrix4x4) : void
        /**
        * Set a vector array parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param values Value to set.
        * @methodSwap SetVectorArray_EBB7509C_H500372C6
        */
        public SetVectorArray ($nameID: int, $values: Vector4[]) : void
        /**
        * Set a Matrix array parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param values Value to set.
        * @methodSwap SetMatrixArray_EBB7509C_H4B572A74
        */
        public SetMatrixArray ($nameID: int, $values: Matrix4x4[]) : void
        /**
        * Set a texture parameter.
        * @param kernelIndex For which kernel the texture is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param texture Texture to set.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetTexture_EBB7509C_C8A7054A
        */
        public SetTexture ($kernelIndex: int, $nameID: int, $texture: Texture, $mipLevel: int) : void
        /**
        * Set a texture parameter from a global texture property.
        * @param kernelIndex For which kernel the texture is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param globalTextureName Global texture property to assign to shader.
        * @param globalTextureNameID Property name ID, use Shader.PropertyToID to get it.
        * @methodSwap SetTextureFromGlobal_EBB7509C_H71E348A6
        */
        public SetTextureFromGlobal ($kernelIndex: int, $nameID: int, $globalTextureNameID: int) : void
        /**
        * Sets an input or output compute buffer.
        * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param buffer Buffer to set.
        * @methodSwap SetBuffer_EBB7509C_H20EFEFB9
        */
        public SetBuffer ($kernelIndex: int, $nameID: int, $buffer: ComputeBuffer) : void
        /**
        * Sets an input or output compute buffer.
        * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param buffer Buffer to set.
        * @methodSwap SetBuffer_EBB7509C_H7618BE61
        */
        public SetBuffer ($kernelIndex: int, $nameID: int, $buffer: GraphicsBuffer) : void
        /**
        * Get kernel thread group sizes.
        * @param kernelIndex Which kernel to query. A single compute shader asset can have multiple kernel entry points.
        * @param x Thread group size in the X dimension.
        * @param y Thread group size in the Y dimension.
        * @param z Thread group size in the Z dimension.
        */
        public GetKernelThreadGroupSizes ($kernelIndex: int, $x: $Ref<uint>, $y: $Ref<uint>, $z: $Ref<uint>) : void
        /**
        * Execute a compute shader.
        * @param kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
        * @param threadGroupsX Number of work groups in the X dimension.
        * @param threadGroupsY Number of work groups in the Y dimension.
        * @param threadGroupsZ Number of work groups in the Z dimension.
        */
        public Dispatch ($kernelIndex: int, $threadGroupsX: int, $threadGroupsY: int, $threadGroupsZ: int) : void
        /**
        * Enables a local shader keyword for this compute shader.
        * @param keyword The name of the Rendering.LocalKeyword to enable.
        */
        public EnableKeyword ($keyword: string) : void
        /**
        * Disables a local shader keyword for this compute shader.
        * @param keyword The name of the Rendering.LocalKeyword to disable.
        */
        public DisableKeyword ($keyword: string) : void
        /**
        * Checks whether a local shader keyword is enabled for this compute shader.
        * @param keyword The name of the Rendering.LocalKeyword to check.
        * @returns Returns true if the given Rendering.LocalKeyword is enabled for this compute shader. Otherwise, returns false.
        */
        public IsKeywordEnabled ($keyword: string) : boolean
        /**
        * Enables a local shader keyword for this compute shader.
        * @param keyword The name of the Rendering.LocalKeyword to enable.
        */
        public EnableKeyword ($keyword: $Ref<UnityEngine_Rendering.LocalKeyword>) : void
        /**
        * Disables a local shader keyword for this compute shader.
        * @param keyword The name of the Rendering.LocalKeyword to disable.
        */
        public DisableKeyword ($keyword: $Ref<UnityEngine_Rendering.LocalKeyword>) : void
        /**
        * Sets the state of a local shader keyword for this compute shader.
        * @param keyword The Rendering.LocalKeyword keyword to enable or disable.
        * @param value The desired keyword state.
        */
        public SetKeyword ($keyword: $Ref<UnityEngine_Rendering.LocalKeyword>, $value: boolean) : void
        /**
        * Checks whether a local shader keyword is enabled for this compute shader.
        * @param keyword The name of the Rendering.LocalKeyword to check.
        * @returns Returns true if the given Rendering.LocalKeyword is enabled for this compute shader. Otherwise, returns false.
        */
        public IsKeywordEnabled ($keyword: $Ref<UnityEngine_Rendering.LocalKeyword>) : boolean
        /**
        * Allows you to check whether the current end user device supports the features required to run the specified compute shader kernel.
        * @param kernelIndex Which kernel to query.
        * @returns True if the specified compute kernel is able to run on the current end user device, false otherwise.
        */
        public IsSupported ($kernelIndex: int) : boolean
        /**
        * Set a float parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param val Value to set.
        * @methodSwap SetFloat_EBB7509C_H45FF9778
        */
        public SetFloat ($name: string, $val: float) : void
        /**
        * Set an integer parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param val Value to set.
        * @methodSwap SetInt_EBB7509C_H72D17FE0
        */
        public SetInt ($name: string, $val: int) : void
        /**
        * Set a vector parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param val Value to set.
        */
        public SetVector ($name: string, $val: Vector4) : void
        /**
        * Set a Matrix parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param val Value to set.
        */
        public SetMatrix ($name: string, $val: Matrix4x4) : void
        /**
        * Set a vector array parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param values Value to set.
        */
        public SetVectorArray ($name: string, $values: Vector4[]) : void
        /**
        * Set a Matrix array parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param values Value to set.
        */
        public SetMatrixArray ($name: string, $values: Matrix4x4[]) : void
        /**
        * Set multiple consecutive float parameters at once.
        * @param name Array variable name in the shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param values Value array to set.
        */
        public SetFloats ($name: string, ...values: float[]) : void
        /**
        * Set multiple consecutive float parameters at once.
        * @param name Array variable name in the shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param values Value array to set.
        * @methodSwap SetFloats_EBB7509C_A33DC2D
        */
        public SetFloats ($nameID: int, ...values: float[]) : void
        /**
        * Set multiple consecutive integer parameters at once.
        * @param name Array variable name in the shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param values Value array to set.
        */
        public SetInts ($name: string, ...values: int[]) : void
        /**
        * Set multiple consecutive integer parameters at once.
        * @param name Array variable name in the shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param values Value array to set.
        * @methodSwap SetInts_EBB7509C_DB020B57
        */
        public SetInts ($nameID: int, ...values: int[]) : void
        /**
        * Set a bool parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param val Value to set.
        */
        public SetBool ($name: string, $val: boolean) : void
        /**
        * Set a bool parameter.
        * @param name Variable name in shader code.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param val Value to set.
        * @methodSwap SetBool_EBB7509C_H5B11DF19
        */
        public SetBool ($nameID: int, $val: boolean) : void
        /**
        * Set a texture parameter.
        * @param kernelIndex For which kernel the texture is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param texture Texture to set.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetTexture_EBB7509C_H44A94D61
        */
        public SetTexture ($kernelIndex: int, $nameID: int, $texture: Texture) : void
        /**
        * Set a texture parameter.
        * @param kernelIndex For which kernel the texture is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param texture Texture to set.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetTexture_EBB7509C_D4FF094
        */
        public SetTexture ($kernelIndex: int, $name: string, $texture: Texture) : void
        /**
        * Set a texture parameter.
        * @param kernelIndex For which kernel the texture is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param texture Texture to set.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetTexture_EBB7509C_AC44DF8F
        */
        public SetTexture ($kernelIndex: int, $name: string, $texture: Texture, $mipLevel: int) : void
        /**
        * Set a texture parameter.
        * @param kernelIndex For which kernel the texture is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param texture Texture to set.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetTexture_EBB7509C_H6FE80B68
        */
        public SetTexture ($kernelIndex: int, $nameID: int, $texture: RenderTexture, $mipLevel: int, $element: UnityEngine_Rendering.RenderTextureSubElement) : void
        /**
        * Set a texture parameter.
        * @param kernelIndex For which kernel the texture is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param texture Texture to set.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetTexture_EBB7509C_H31E4D7B7
        */
        public SetTexture ($kernelIndex: int, $name: string, $texture: RenderTexture, $mipLevel: int, $element: UnityEngine_Rendering.RenderTextureSubElement) : void
        /**
        * Set a texture parameter from a global texture property.
        * @param kernelIndex For which kernel the texture is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param globalTextureName Global texture property to assign to shader.
        * @param globalTextureNameID Property name ID, use Shader.PropertyToID to get it.
        * @methodSwap SetTextureFromGlobal_EBB7509C_FBCB72BA
        */
        public SetTextureFromGlobal ($kernelIndex: int, $name: string, $globalTextureName: string) : void
        /**
        * Sets an input or output compute buffer.
        * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param buffer Buffer to set.
        * @methodSwap SetBuffer_EBB7509C_H3B93544
        */
        public SetBuffer ($kernelIndex: int, $name: string, $buffer: ComputeBuffer) : void
        /**
        * Sets an input or output compute buffer.
        * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Name of the buffer variable in shader code.
        * @param buffer Buffer to set.
        * @methodSwap SetBuffer_EBB7509C_DCAEC4A2
        */
        public SetBuffer ($kernelIndex: int, $name: string, $buffer: GraphicsBuffer) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the buffer to bind as constant buffer.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetConstantBuffer_EBB7509C_H2CE47D04
        */
        public SetConstantBuffer ($nameID: int, $buffer: ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the buffer to bind as constant buffer.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetConstantBuffer_EBB7509C_H1515F92F
        */
        public SetConstantBuffer ($name: string, $buffer: ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the buffer to bind as constant buffer.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetConstantBuffer_EBB7509C_H30D518B2
        */
        public SetConstantBuffer ($nameID: int, $buffer: GraphicsBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the buffer to bind as constant buffer.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetConstantBuffer_EBB7509C_H369B14DB
        */
        public SetConstantBuffer ($name: string, $buffer: GraphicsBuffer, $offset: int, $size: int) : void
        /**
        * Execute a compute shader.
        * @param kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
        * @param argsBuffer Buffer with dispatch arguments.
        * @param argsOffset The byte offset into the buffer, where the draw arguments start.
        * @methodSwap DispatchIndirect_EBB7509C_H87860050
        */
        public DispatchIndirect ($kernelIndex: int, $argsBuffer: ComputeBuffer, $argsOffset: uint) : void
        /**
        * @methodSwap DispatchIndirect_EBB7509C_E83D65D0
        */
        public DispatchIndirect ($kernelIndex: int, $argsBuffer: ComputeBuffer) : void
        /**
        * Execute a compute shader.
        * @param kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
        * @param argsBuffer Buffer with dispatch arguments.
        * @param argsOffset The byte offset into the buffer, where the draw arguments start.
        * @methodSwap DispatchIndirect_EBB7509C_H663940BA
        */
        public DispatchIndirect ($kernelIndex: int, $argsBuffer: GraphicsBuffer, $argsOffset: uint) : void
        /**
        * @methodSwap DispatchIndirect_EBB7509C_EA6F5EB6
        */
        public DispatchIndirect ($kernelIndex: int, $argsBuffer: GraphicsBuffer) : void
    }

    /**
    * A 2D Rectangle defined by X and Y position, width and height.
    */
    class Rect extends System.ValueType implements System.IFormattable, System.IEquatable$1<Rect> {

        /**
        * Shorthand for writing new Rect(0,0,0,0).
        */
        public static get zero(): Rect;
        /**
        * The X coordinate of the rectangle.
        */
        public get x(): float;
        public set x(value: float);
        /**
        * The Y coordinate of the rectangle.
        */
        public get y(): float;
        public set y(value: float);
        /**
        * The X and Y position of the rectangle.
        */
        public get position(): Vector2;
        public set position(value: Vector2);
        /**
        * The position of the center of the rectangle.
        */
        public get center(): Vector2;
        public set center(value: Vector2);
        /**
        * The position of the minimum corner of the rectangle.
        */
        public get min(): Vector2;
        public set min(value: Vector2);
        /**
        * The position of the maximum corner of the rectangle.
        */
        public get max(): Vector2;
        public set max(value: Vector2);
        /**
        * The width of the rectangle, measured from the X position.
        */
        public get width(): float;
        public set width(value: float);
        /**
        * The height of the rectangle, measured from the Y position.
        */
        public get height(): float;
        public set height(value: float);
        /**
        * The width and height of the rectangle.
        */
        public get size(): Vector2;
        public set size(value: Vector2);
        /**
        * The minimum X coordinate of the rectangle.
        */
        public get xMin(): float;
        public set xMin(value: float);
        /**
        * The minimum Y coordinate of the rectangle.
        */
        public get yMin(): float;
        public set yMin(value: float);
        /**
        * The maximum X coordinate of the rectangle.
        */
        public get xMax(): float;
        public set xMax(value: float);
        /**
        * The maximum Y coordinate of the rectangle.
        */
        public get yMax(): float;
        public set yMax(value: float);

        /**
        * Creates a new rectangle.
        * @param x The X value the rect is measured from.
        * @param y The Y value the rect is measured from.
        * @param width The width of the rectangle.
        * @param height The height of the rectangle.
        */
        public constructor ($x: float, $y: float, $width: float, $height: float)
        /**
        * Creates a rectangle given a size and position.
        * @param position The position of the minimum corner of the rect.
        * @param size The width and height of the rect.
        */
        public constructor ($position: Vector2, $size: Vector2)
        /**
        */
        public constructor ($source: Rect)
        /**
        * Creates a rectangle from min/max coordinate values.
        * @param xmin The minimum X coordinate.
        * @param ymin The minimum Y coordinate.
        * @param xmax The maximum X coordinate.
        * @param ymax The maximum Y coordinate.
        * @returns A rectangle matching the specified coordinates.
        */
        public static MinMaxRect ($xmin: float, $ymin: float, $xmax: float, $ymax: float) : Rect
        /**
        * Set components of an existing Rect.
        */
        public Set ($x: float, $y: float, $width: float, $height: float) : void
        /**
        * Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
        * @param point Point to test.
        * @param allowInverse Does the test allow the Rect's width and height to be negative?
        * @returns True if the point lies within the specified rectangle.
        */
        public Contains ($point: Vector2) : boolean
        /**
        * Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
        * @param point Point to test.
        * @param allowInverse Does the test allow the Rect's width and height to be negative?
        * @returns True if the point lies within the specified rectangle.
        */
        public Contains ($point: Vector3) : boolean
        /**
        * Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
        * @param point Point to test.
        * @param allowInverse Does the test allow the Rect's width and height to be negative?
        * @returns True if the point lies within the specified rectangle.
        */
        public Contains ($point: Vector3, $allowInverse: boolean) : boolean
        /**
        * Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
        * @param other Other rectangle to test overlapping with.
        * @param allowInverse Does the test allow the widths and heights of the Rects to be negative?
        */
        public Overlaps ($other: Rect) : boolean
        /**
        * Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
        * @param other Other rectangle to test overlapping with.
        * @param allowInverse Does the test allow the widths and heights of the Rects to be negative?
        */
        public Overlaps ($other: Rect, $allowInverse: boolean) : boolean
        /**
        * Returns a point inside a rectangle, given normalized coordinates.
        * @param rectangle Rectangle to get a point inside.
        * @param normalizedRectCoordinates Normalized coordinates to get a point for.
        */
        public static NormalizedToPoint ($rectangle: Rect, $normalizedRectCoordinates: Vector2) : Vector2
        /**
        * Returns the normalized coordinates cooresponding the the point.
        * @param rectangle Rectangle to get normalized coordinates inside.
        * @param point A point inside the rectangle to get normalized coordinates for.
        */
        public static PointToNormalized ($rectangle: Rect, $point: Vector2) : Vector2
        public GetHashCode () : int
        public Equals ($other: any) : boolean
        public Equals ($other: Rect) : boolean
        /**
        * Returns a formatted string for this Rect.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this Rect.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this Rect.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        public static op_Inequality ($lhs: Rect, $rhs: Rect) : boolean
        public static op_Equality ($lhs: Rect, $rhs: Rect) : boolean
    }

    /**
    * Class for handling cube maps, Use this to create or modify existing.
    */
    class Cubemap extends Texture {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
        */
        public static GenerateAllMips : int
        /**
        * How many mipmap levels are in this Texture (Read Only).
        */
        public get mipmapCount(): int;
        public static get anisotropicFiltering(): AnisotropicFiltering;
        public static set anisotropicFiltering(value: AnisotropicFiltering);
        /**
        * Returns the GraphicsFormat format or color format of a Texture object.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
        * Width of the Texture in pixels (Read Only).
        */
        public get width(): int;
        public set width(value: int);
        /**
        * Height of the Texture in pixels (Read Only).
        */
        public get height(): int;
        public set height(value: int);
        /**
        * Dimensionality (type) of the Texture (Read Only).
        */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
        * Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
        */
        public get isReadable(): boolean;
        /**
        * Texture coordinate wrapping mode.
        */
        public get wrapMode(): TextureWrapMode;
        public set wrapMode(value: TextureWrapMode);
        /**
        * Texture U coordinate wrapping mode.
        */
        public get wrapModeU(): TextureWrapMode;
        public set wrapModeU(value: TextureWrapMode);
        /**
        * Texture V coordinate wrapping mode.
        */
        public get wrapModeV(): TextureWrapMode;
        public set wrapModeV(value: TextureWrapMode);
        /**
        * Texture W coordinate wrapping mode for Texture3D.
        */
        public get wrapModeW(): TextureWrapMode;
        public set wrapModeW(value: TextureWrapMode);
        /**
        * Filtering mode of the Texture.
        */
        public get filterMode(): FilterMode;
        public set filterMode(value: FilterMode);
        /**
        * Defines the anisotropic filtering level of the Texture.
        */
        public get anisoLevel(): int;
        public set anisoLevel(value: int);
        /**
        * The mipmap bias of the Texture.
        */
        public get mipMapBias(): float;
        public set mipMapBias(value: float);
        public get texelSize(): Vector2;
        /**
        * This counter is incremented when the Texture is updated.
        */
        public get updateCount(): uint;
        /**
        * Returns true if the texture pixel data is in sRGB color space (Read Only).
        */
        public get isDataSRGB(): boolean;
        /**
        * The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0.
        * This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually.
        * To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`.
        * `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get totalTextureMemory(): bigint;
        /**
        * The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.
        * For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.
        * The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
        */
        public static get desiredTextureMemory(): bigint;
        /**
        * The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get targetTextureMemory(): bigint;
        /**
        * The amount of memory that all Textures in the scene use.
        */
        public static get currentTextureMemory(): bigint;
        /**
        * The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureMemory(): bigint;
        /**
        * How many times has a Texture been uploaded due to Texture mipmap streaming.
        */
        public static get streamingMipmapUploadCount(): bigint;
        /**
        * Number of renderers registered with the Texture streaming system.
        */
        public static get streamingRendererCount(): bigint;
        /**
        * Number of streaming Textures.
        */
        public static get streamingTextureCount(): bigint;
        /**
        * The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureCount(): bigint;
        /**
        * Number of streaming Textures with outstanding mipmaps to be loaded.
        */
        public static get streamingTexturePendingLoadCount(): bigint;
        /**
        * Number of streaming Textures with mipmaps currently loading.
        */
        public static get streamingTextureLoadingCount(): bigint;
        /**
        * Force streaming Textures to load all mipmap levels.
        */
        public static get streamingTextureForceLoadAll(): boolean;
        public static set streamingTextureForceLoadAll(value: boolean);
        /**
        * This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
        */
        public static get streamingTextureDiscardUnusedMips(): boolean;
        public static set streamingTextureDiscardUnusedMips(value: boolean);
        /**
        * Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
        */
        public static get allowThreadedTextureCreation(): boolean;
        public static set allowThreadedTextureCreation(value: boolean);
        /**
        * The format of the pixel data in the texture (Read Only).
        */
        public get format(): TextureFormat;
        /**
        * Determines whether mipmap streaming is enabled for this Texture.
        */
        public get streamingMipmaps(): boolean;
        /**
        * Sets the relative priority for this Texture when reducing memory size to fit within the memory budget.
        */
        public get streamingMipmapsPriority(): int;
        /**
        * The mipmap level to load.
        */
        public get requestedMipmapLevel(): int;
        public set requestedMipmapLevel(value: int);
        /**
        * The mipmap level that the streaming system would load before memory budgets are applied.
        */
        public get desiredMipmapLevel(): int;
        /**
        * The mipmap level that the mipmap streaming system is in the process of loading.
        */
        public get loadingMipmapLevel(): int;
        /**
        * The mipmap level that is currently loaded by the streaming system.
        */
        public get loadedMipmapLevel(): int;

        public constructor ($width: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: int)
        public constructor ($width: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: int)
        /**
        * Create a new empty cubemap texture.
        * @param format Pixel data format to be used for the Cubemap.
        * @param width Width/height of a cube face in pixels.
        * @param textureFormat Pixel data format to be used for the Cubemap.
        * @param mipChain Should mipmaps be created?
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        * @param mipCount Number of mipmaps to be created. Use TextureCreationFlags.MipChain to generate a full mipchain.
        */
        public constructor ($width: int, $textureFormat: TextureFormat, $mipChain: boolean)
        /**
        * Create a new empty cubemap texture.
        * @param format Pixel data format to be used for the Cubemap.
        * @param width Width/height of a cube face in pixels.
        * @param textureFormat Pixel data format to be used for the Cubemap.
        * @param mipChain Should mipmaps be created?
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        * @param mipCount Number of mipmaps to be created. Use TextureCreationFlags.MipChain to generate a full mipchain.
        */
        public constructor ($width: int, $textureFormat: TextureFormat, $mipChain: boolean, $createUninitialized: boolean)
        /**
        * Create a new empty cubemap texture.
        * @param format Pixel data format to be used for the Cubemap.
        * @param width Width/height of a cube face in pixels.
        * @param textureFormat Pixel data format to be used for the Cubemap.
        * @param mipChain Should mipmaps be created?
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        * @param mipCount Number of mipmaps to be created. Use TextureCreationFlags.MipChain to generate a full mipchain.
        */
        public constructor ($width: int, $format: TextureFormat, $mipCount: int)
        /**
        * Create a new empty cubemap texture.
        * @param format Pixel data format to be used for the Cubemap.
        * @param width Width/height of a cube face in pixels.
        * @param textureFormat Pixel data format to be used for the Cubemap.
        * @param mipChain Should mipmaps be created?
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        * @param mipCount Number of mipmaps to be created. Use TextureCreationFlags.MipChain to generate a full mipchain.
        */
        public constructor ($width: int, $format: TextureFormat, $mipCount: int, $createUninitialized: boolean)
        /**
        * Updates Unity cubemap to use different native cubemap texture object.
        * @param nativeTexture Native cubemap texture object.
        */
        public UpdateExternalTexture ($nativeTexture: System.IntPtr) : void
        /**
        * Performs smoothing of near edge regions.
        * @param smoothRegionWidthInPixels Pixel distance at edges over which to apply smoothing.
        * @methodSwap SmoothEdges_EBB7509C_F92D023A
        */
        public SmoothEdges ($smoothRegionWidthInPixels: int) : void
        public SmoothEdges () : void
        /**
        * Gets the pixel color data for a mipmap level of a face as Color structs.
        * @param face The CubemapFace to read from.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels_EBB7509C_H748E2F61
        */
        public GetPixels ($face: CubemapFace, $miplevel: int) : Color[]
        /**
        * Gets the pixel color data for a mipmap level of a face as Color structs.
        * @param face The CubemapFace to read from.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        */
        public GetPixels ($face: CubemapFace) : Color[]
        /**
        * Sets the pixel colors of an entire mipmap level of a face.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param face The CubemapFace to write colors to.
        * @methodSwap SetPixels_EBB7509C_H78407925
        */
        public SetPixels ($colors: Color[], $face: CubemapFace, $miplevel: int) : void
        /**
        * Sets the pixel colors of an entire mipmap level of a face.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param face The CubemapFace to write colors to.
        */
        public SetPixels ($colors: Color[], $face: CubemapFace) : void
        /**
        * Resets the requestedMipmapLevel field.
        */
        public ClearRequestedMipmapLevel () : void
        /**
        * Checks to see whether the mipmap level set by requestedMipmapLevel has finished loading.
        * @returns True if the mipmap level requested by requestedMipmapLevel has finished loading.
        */
        public IsRequestedMipmapLevelLoaded () : boolean
        /**
        * Creates a Unity cubemap out of externally created native cubemap object.
        * @param size The width and height of each face of the cubemap should be the same.
        * @param format Format of underlying cubemap object.
        * @param mipmap Does the cubemap have mipmaps?
        * @param nativeTex Native cubemap texture object.
        */
        public static CreateExternalTexture ($width: int, $format: TextureFormat, $mipmap: boolean, $nativeTex: System.IntPtr) : Cubemap
        /**
        * @methodSwap SetPixelData_EBB7509C_H8E668B70
        */
        public SetPixelData<T> ($data: T[], $mipLevel: int, $face: CubemapFace, $sourceDataStartIndex?: int) : void
        /**
        * @methodSwap SetPixelData_EBB7509C_H2A1B3D21
        */
        public SetPixelData<T> ($data: Unity_Collections.NativeArray$1<T>, $mipLevel: int, $face: CubemapFace, $sourceDataStartIndex?: int) : void
        /**
        * Gets the raw data from a texture.
        * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param face The CubemapFace to read from.
        * @returns A native array that points directly to the texture's data buffer in CPU memory.
        */
        public GetPixelData<T> ($mipLevel: int, $face: CubemapFace) : Unity_Collections.NativeArray$1<T>
        /**
        * Sets the pixel color at coordinates (x,y).
        * @param x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
        * @param y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
        * @param color The color to set.
        * @param mip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param face The CubemapFace to write to.
        * @methodSwap SetPixel_EBB7509C_H116BBB54
        */
        public SetPixel ($face: CubemapFace, $x: int, $y: int, $color: Color) : void
        /**
        * Sets the pixel color at coordinates (x,y).
        * @param x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
        * @param y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
        * @param color The color to set.
        * @param mip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param face The CubemapFace to write to.
        * @methodSwap SetPixel_EBB7509C_H52FE7ECF
        */
        public SetPixel ($face: CubemapFace, $x: int, $y: int, $color: Color, $mip: int) : void
        /**
        * Gets the pixel color at coordinates (x, y).
        * @param x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
        * @param y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
        * @param mip The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param face The CubemapFace to sample.
        * @returns The pixel color.
        * @methodSwap GetPixel_EBB7509C_H6FD174A
        */
        public GetPixel ($face: CubemapFace, $x: int, $y: int) : Color
        /**
        * Gets the pixel color at coordinates (x, y).
        * @param x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
        * @param y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
        * @param mip The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param face The CubemapFace to sample.
        * @returns The pixel color.
        * @methodSwap GetPixel_EBB7509C_B66FF895
        */
        public GetPixel ($face: CubemapFace, $x: int, $y: int, $mip: int) : Color
        /**
        * Copies changes you've made in a CPU texture to the GPU.
        * @param updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
        * @param makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
        */
        public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
        public Apply ($updateMipmaps: boolean) : void
        public Apply () : void
        public constructor ()
    }

    /**
    * Cubemap face.
    */
    enum CubemapFace {
        Unknown = -1,
        PositiveX = 0,
        NegativeX = 1,
        PositiveY = 2,
        NegativeY = 3,
        PositiveZ = 4,
        NegativeZ = 5 
    }

    /**
    * Format used when creating textures from scripts.
    */
    enum TextureFormat {
        Alpha8 = 1,
        ARGB4444 = 2,
        RGB24 = 3,
        RGBA32 = 4,
        ARGB32 = 5,
        RGB565 = 7,
        R16 = 9,
        DXT1 = 10,
        DXT5 = 12,
        RGBA4444 = 13,
        BGRA32 = 14,
        RHalf = 15,
        RGHalf = 16,
        RGBAHalf = 17,
        RFloat = 18,
        RGFloat = 19,
        RGBAFloat = 20,
        YUY2 = 21,
        RGB9e5Float = 22,
        BC4 = 26,
        BC5 = 27,
        BC6H = 24,
        BC7 = 25,
        DXT1Crunched = 28,
        DXT5Crunched = 29,
        PVRTC_RGB2 = 30,
        PVRTC_RGBA2 = 31,
        PVRTC_RGB4 = 32,
        PVRTC_RGBA4 = 33,
        ETC_RGB4 = 34,
        ATC_RGB4 = -127,
        ATC_RGBA8 = -127,
        EAC_R = 41,
        EAC_R_SIGNED = 42,
        EAC_RG = 43,
        EAC_RG_SIGNED = 44,
        ETC2_RGB = 45,
        ETC2_RGBA1 = 46,
        ETC2_RGBA8 = 47,
        ASTC_4x4 = 48,
        ASTC_5x5 = 49,
        ASTC_6x6 = 50,
        ASTC_8x8 = 51,
        ASTC_10x10 = 52,
        ASTC_12x12 = 53,
        ETC_RGB4_3DS = 60,
        ETC_RGBA8_3DS = 61,
        RG16 = 62,
        R8 = 63,
        ETC_RGB4Crunched = 64,
        ETC2_RGBA8Crunched = 65,
        ASTC_HDR_4x4 = 66,
        ASTC_HDR_5x5 = 67,
        ASTC_HDR_6x6 = 68,
        ASTC_HDR_8x8 = 69,
        ASTC_HDR_10x10 = 70,
        ASTC_HDR_12x12 = 71,
        RG32 = 72,
        RGB48 = 73,
        RGBA64 = 74,
        ASTC_RGB_4x4 = 48,
        ASTC_RGB_5x5 = 49,
        ASTC_RGB_6x6 = 50,
        ASTC_RGB_8x8 = 51,
        ASTC_RGB_10x10 = 52,
        ASTC_RGB_12x12 = 53,
        ASTC_RGBA_4x4 = 54,
        ASTC_RGBA_5x5 = 55,
        ASTC_RGBA_6x6 = 56,
        ASTC_RGBA_8x8 = 57,
        ASTC_RGBA_10x10 = 58,
        ASTC_RGBA_12x12 = 59,
        PVRTC_2BPP_RGB = -127,
        PVRTC_2BPP_RGBA = -127,
        PVRTC_4BPP_RGB = -127,
        PVRTC_4BPP_RGBA = -127 
    }

    /**
    * The material class.
    */
    class Material extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The shader used by the material.
        */
        public get shader(): Shader;
        public set shader(value: Shader);
        /**
        * The main color of the Material.
        */
        public get color(): Color;
        public set color(value: Color);
        /**
        * The main texture.
        */
        public get mainTexture(): Texture;
        public set mainTexture(value: Texture);
        /**
        * The offset of the main texture.
        */
        public get mainTextureOffset(): Vector2;
        public set mainTextureOffset(value: Vector2);
        /**
        * The scale of the main texture.
        */
        public get mainTextureScale(): Vector2;
        public set mainTextureScale(value: Vector2);
        /**
        * Render queue of this material.
        */
        public get renderQueue(): int;
        public set renderQueue(value: int);
        /**
        * An array containing the local shader keywords that are currently enabled for this material.
        */
        public get enabledKeywords(): UnityEngine_Rendering.LocalKeyword[];
        public set enabledKeywords(value: UnityEngine_Rendering.LocalKeyword[]);
        /**
        * Defines how the material should interact with lightmaps and lightprobes.
        */
        public get globalIlluminationFlags(): MaterialGlobalIlluminationFlags;
        public set globalIlluminationFlags(value: MaterialGlobalIlluminationFlags);
        /**
        * Gets and sets whether the Double Sided Global Illumination setting is enabled for this material.
        */
        public get doubleSidedGI(): boolean;
        public set doubleSidedGI(value: boolean);
        /**
        * Gets and sets whether GPU instancing is enabled for this material.
        */
        public get enableInstancing(): boolean;
        public set enableInstancing(value: boolean);
        /**
        * How many passes are in this material (Read Only).
        */
        public get passCount(): int;
        /**
        * An array containing names of the local shader keywords that are currently enabled for this material.
        */
        public get shaderKeywords(): string[];
        public set shaderKeywords(value: string[]);

        /**
        * Create a temporary Material.
        * @param shader Create a material with a given Shader.
        * @param source Create a material by copying all properties from another material.
        */
        public constructor ($shader: Shader)
        /**
        * Create a temporary Material.
        * @param shader Create a material with a given Shader.
        * @param source Create a material by copying all properties from another material.
        */
        public constructor ($source: Material)
        /**
        * Checks if the ShaderLab file assigned to the Material has a property with the given name.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        * @methodSwap HasProperty_EBB7509C_F92D023A
        */
        public HasProperty ($nameID: int) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a property with the given name.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        */
        public HasProperty ($name: string) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a Float property with the given name. This also works with the Float Array property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        */
        public HasFloat ($name: string) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a Float property with the given name. This also works with the Float Array property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        * @methodSwap HasFloat_EBB7509C_F92D023A
        */
        public HasFloat ($nameID: int) : boolean
        /**
        * This method is deprecated. Use HasFloat or HasInteger instead.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        */
        public HasInt ($name: string) : boolean
        /**
        * This method is deprecated. Use HasFloat or HasInteger instead.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        * @methodSwap HasInt_EBB7509C_F92D023A
        */
        public HasInt ($nameID: int) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has an Integer property with the given name.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        */
        public HasInteger ($name: string) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has an Integer property with the given name.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        * @methodSwap HasInteger_EBB7509C_F92D023A
        */
        public HasInteger ($nameID: int) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a Texture property with the given name.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        */
        public HasTexture ($name: string) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a Texture property with the given name.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        * @methodSwap HasTexture_EBB7509C_F92D023A
        */
        public HasTexture ($nameID: int) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a Matrix property with the given name. This also works with the Matrix Array property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        */
        public HasMatrix ($name: string) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a Matrix property with the given name. This also works with the Matrix Array property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        * @methodSwap HasMatrix_EBB7509C_F92D023A
        */
        public HasMatrix ($nameID: int) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a Vector property with the given name. This also works with the Vector Array property.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        */
        public HasVector ($name: string) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a Vector property with the given name. This also works with the Vector Array property.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        * @methodSwap HasVector_EBB7509C_F92D023A
        */
        public HasVector ($nameID: int) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a Color property with the given name.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        */
        public HasColor ($name: string) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a Color property with the given name.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        * @methodSwap HasColor_EBB7509C_F92D023A
        */
        public HasColor ($nameID: int) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a ComputeBuffer property with the given name.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        */
        public HasBuffer ($name: string) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a ComputeBuffer property with the given name.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        * @methodSwap HasBuffer_EBB7509C_F92D023A
        */
        public HasBuffer ($nameID: int) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a ConstantBuffer property with the given name.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        */
        public HasConstantBuffer ($name: string) : boolean
        /**
        * Checks if the ShaderLab file assigned to the Material has a ConstantBuffer property with the given name.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if the ShaderLab file assigned to the Material has this property.
        * @methodSwap HasConstantBuffer_EBB7509C_F92D023A
        */
        public HasConstantBuffer ($nameID: int) : boolean
        /**
        * Enables a local shader keyword for this material.
        * @param keyword The name of the Rendering.LocalKeyword to enable.
        */
        public EnableKeyword ($keyword: string) : void
        /**
        * Disables a local shader keyword for this material.
        * @param keyword The name of the Rendering.LocalKeyword to disable.
        */
        public DisableKeyword ($keyword: string) : void
        /**
        * Checks whether a local shader keyword is enabled for this material.
        * @param keyword The name of the Rendering.LocalKeyword to check.
        * @returns Returns true if a Rendering.LocalKeyword with the given name is enabled  for this material.
        */
        public IsKeywordEnabled ($keyword: string) : boolean
        /**
        * Enables a local shader keyword for this material.
        * @param keyword The name of the Rendering.LocalKeyword to enable.
        */
        public EnableKeyword ($keyword: $Ref<UnityEngine_Rendering.LocalKeyword>) : void
        /**
        * Disables a local shader keyword for this material.
        * @param keyword The name of the Rendering.LocalKeyword to disable.
        */
        public DisableKeyword ($keyword: $Ref<UnityEngine_Rendering.LocalKeyword>) : void
        /**
        * Sets the state of a local shader keyword for this material.
        * @param keyword The Rendering.LocalKeyword to enable or disable.
        * @param value The desired keyword state.
        */
        public SetKeyword ($keyword: $Ref<UnityEngine_Rendering.LocalKeyword>, $value: boolean) : void
        /**
        * Checks whether a local shader keyword is enabled for this material.
        * @param keyword The name of the Rendering.LocalKeyword to check.
        * @returns Returns true if a Rendering.LocalKeyword with the given name is enabled  for this material.
        */
        public IsKeywordEnabled ($keyword: $Ref<UnityEngine_Rendering.LocalKeyword>) : boolean
        /**
        * Enables or disables a Shader pass on a per-Material level.
        * @param passName Shader pass name (case insensitive).
        * @param enabled Flag indicating whether this Shader pass should be enabled.
        */
        public SetShaderPassEnabled ($passName: string, $enabled: boolean) : void
        /**
        * Checks whether a given Shader pass is enabled on this Material.
        * @param passName Shader pass name (case insensitive).
        * @returns True if the Shader pass is enabled.
        */
        public GetShaderPassEnabled ($passName: string) : boolean
        /**
        * Returns the name of the shader pass at index pass.
        */
        public GetPassName ($pass: int) : string
        /**
        * Returns the index of the pass passName.
        */
        public FindPass ($passName: string) : int
        /**
        * Sets an override tag/value on the material.
        * @param tag Name of the tag to set.
        * @param val Name of the value to set. Empty string to clear the override flag.
        */
        public SetOverrideTag ($tag: string, $val: string) : void
        /**
        * Get the value of material's shader tag.
        */
        public GetTag ($tag: string, $searchFallbacks: boolean, $defaultValue: string) : string
        /**
        * Get the value of material's shader tag.
        */
        public GetTag ($tag: string, $searchFallbacks: boolean) : string
        /**
        * Interpolate properties between two materials.
        */
        public Lerp ($start: Material, $end: Material, $t: float) : void
        /**
        * Activate the given pass for rendering.
        * @param pass Shader pass number to setup.
        * @returns If false is returned, no rendering should be done.
        */
        public SetPass ($pass: int) : boolean
        /**
        * Copy properties from other material into this material.
        */
        public CopyPropertiesFromMaterial ($mat: Material) : void
        /**
        * Copies properties, keyword states and settings from mat to this material, but only if they exist in both materials.
        * @param mat The Material to copy from.
        */
        public CopyMatchingPropertiesFromMaterial ($mat: Material) : void
        /**
        * Computes a CRC hash value from the content of the material.
        */
        public ComputeCRC () : int
        /**
        * Returns the names of all texture properties exposed on this material.
        * @param outNames Names of all texture properties exposed on this material.
        * @returns Names of all texture properties exposed on this material.
        */
        public GetTexturePropertyNames () : string[]
        /**
        * Return the name IDs of all texture properties exposed on this material.
        * @param outNames IDs of all texture properties exposed on this material.
        * @returns IDs of all texture properties exposed on this material.
        */
        public GetTexturePropertyNameIDs () : int[]
        public GetTexturePropertyNames ($outNames: System_Collections_Generic.List$1<string>) : void
        public GetTexturePropertyNameIDs ($outNames: System_Collections_Generic.List$1<int>) : void
        /**
        * This method is deprecated. Use SetFloat or SetInteger instead.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param value Integer value to set.
        * @param name Property name, e.g. "_SrcBlend".
        * @methodSwap SetInt_EBB7509C_H72D17FE0
        */
        public SetInt ($name: string, $value: int) : void
        /**
        * This method is deprecated. Use SetFloat or SetInteger instead.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param value Integer value to set.
        * @param name Property name, e.g. "_SrcBlend".
        * @methodSwap SetInt_EBB7509C_H2CFB2EE5
        */
        public SetInt ($nameID: int, $value: int) : void
        /**
        * Sets a named float value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param value Float value to set.
        * @param name Property name, e.g. "_Glossiness".
        * @methodSwap SetFloat_EBB7509C_H45FF9778
        */
        public SetFloat ($name: string, $value: float) : void
        /**
        * Sets a named float value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param value Float value to set.
        * @param name Property name, e.g. "_Glossiness".
        * @methodSwap SetFloat_EBB7509C_A137D5B3
        */
        public SetFloat ($nameID: int, $value: float) : void
        /**
        * Sets a named integer value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param value Integer value to set.
        * @param name Property name, e.g. "_SrcBlend".
        * @methodSwap SetInteger_EBB7509C_H72D17FE0
        */
        public SetInteger ($name: string, $value: int) : void
        /**
        * Sets a named integer value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param value Integer value to set.
        * @param name Property name, e.g. "_SrcBlend".
        * @methodSwap SetInteger_EBB7509C_H2CFB2EE5
        */
        public SetInteger ($nameID: int, $value: int) : void
        /**
        * Sets a color value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_Color".
        * @param value Color value to set.
        */
        public SetColor ($name: string, $value: Color) : void
        /**
        * Sets a color value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_Color".
        * @param value Color value to set.
        * @methodSwap SetColor_EBB7509C_H9F453824
        */
        public SetColor ($nameID: int, $value: Color) : void
        /**
        * Sets a named vector value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_WaveAndDistance".
        * @param value Vector value to set.
        */
        public SetVector ($name: string, $value: Vector4) : void
        /**
        * Sets a named vector value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_WaveAndDistance".
        * @param value Vector value to set.
        * @methodSwap SetVector_EBB7509C_H9F0E6FE
        */
        public SetVector ($nameID: int, $value: Vector4) : void
        /**
        * Sets a named matrix for the shader.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_CubemapRotation".
        * @param value Matrix value to set.
        */
        public SetMatrix ($name: string, $value: Matrix4x4) : void
        /**
        * Sets a named matrix for the shader.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_CubemapRotation".
        * @param value Matrix value to set.
        * @methodSwap SetMatrix_EBB7509C_A704EAE0
        */
        public SetMatrix ($nameID: int, $value: Matrix4x4) : void
        /**
        * Sets a named texture.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_MainTex".
        * @param value Texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        */
        public SetTexture ($name: string, $value: Texture) : void
        /**
        * Sets a named texture.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_MainTex".
        * @param value Texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetTexture_EBB7509C_BEB5CD50
        */
        public SetTexture ($nameID: int, $value: Texture) : void
        /**
        * Sets a named texture.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_MainTex".
        * @param value Texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        */
        public SetTexture ($name: string, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement) : void
        /**
        * Sets a named texture.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_MainTex".
        * @param value Texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetTexture_EBB7509C_H63044826
        */
        public SetTexture ($nameID: int, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement) : void
        /**
        * Sets a named buffer value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name.
        * @param value The ComputeBuffer or GraphicsBuffer value to set.
        */
        public SetBuffer ($name: string, $value: ComputeBuffer) : void
        /**
        * Sets a named buffer value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name.
        * @param value The ComputeBuffer or GraphicsBuffer value to set.
        * @methodSwap SetBuffer_EBB7509C_E83D65D0
        */
        public SetBuffer ($nameID: int, $value: ComputeBuffer) : void
        /**
        * Sets a named buffer value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name.
        * @param value The ComputeBuffer or GraphicsBuffer value to set.
        */
        public SetBuffer ($name: string, $value: GraphicsBuffer) : void
        /**
        * Sets a named buffer value.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name.
        * @param value The ComputeBuffer or GraphicsBuffer value to set.
        * @methodSwap SetBuffer_EBB7509C_EA6F5EB6
        */
        public SetBuffer ($nameID: int, $value: GraphicsBuffer) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
        * @param name The name of the constant buffer to override.
        * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @param nameID The shader property ID of the constant buffer to override.
        * @methodSwap SetConstantBuffer_EBB7509C_H1515F92F
        */
        public SetConstantBuffer ($name: string, $value: ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
        * @param name The name of the constant buffer to override.
        * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @param nameID The shader property ID of the constant buffer to override.
        * @methodSwap SetConstantBuffer_EBB7509C_H2CE47D04
        */
        public SetConstantBuffer ($nameID: int, $value: ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
        * @param name The name of the constant buffer to override.
        * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @param nameID The shader property ID of the constant buffer to override.
        * @methodSwap SetConstantBuffer_EBB7509C_H369B14DB
        */
        public SetConstantBuffer ($name: string, $value: GraphicsBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
        * @param name The name of the constant buffer to override.
        * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @param nameID The shader property ID of the constant buffer to override.
        * @methodSwap SetConstantBuffer_EBB7509C_H30D518B2
        */
        public SetConstantBuffer ($nameID: int, $value: GraphicsBuffer, $offset: int, $size: int) : void
        public SetFloatArray ($name: string, $values: System_Collections_Generic.List$1<float>) : void
        /**
        * @methodSwap SetFloatArray_EBB7509C_E8859065
        */
        public SetFloatArray ($nameID: int, $values: System_Collections_Generic.List$1<float>) : void
        /**
        * Sets a float array property.
        * @param name Property name.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Array of values to set.
        */
        public SetFloatArray ($name: string, $values: float[]) : void
        /**
        * Sets a float array property.
        * @param name Property name.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Array of values to set.
        * @methodSwap SetFloatArray_EBB7509C_H4A792FF
        */
        public SetFloatArray ($nameID: int, $values: float[]) : void
        public SetColorArray ($name: string, $values: System_Collections_Generic.List$1<Color>) : void
        /**
        * @methodSwap SetColorArray_EBB7509C_H90245058
        */
        public SetColorArray ($nameID: int, $values: System_Collections_Generic.List$1<Color>) : void
        /**
        * Sets a color array property.
        * @param name Property name.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param values Array of values to set.
        */
        public SetColorArray ($name: string, $values: Color[]) : void
        /**
        * Sets a color array property.
        * @param name Property name.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param values Array of values to set.
        * @methodSwap SetColorArray_EBB7509C_H5E4E5210
        */
        public SetColorArray ($nameID: int, $values: Color[]) : void
        public SetVectorArray ($name: string, $values: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * @methodSwap SetVectorArray_EBB7509C_H5C64F93A
        */
        public SetVectorArray ($nameID: int, $values: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * Sets a vector array property.
        * @param name Property name.
        * @param values Array of values to set.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        */
        public SetVectorArray ($name: string, $values: Vector4[]) : void
        /**
        * Sets a vector array property.
        * @param name Property name.
        * @param values Array of values to set.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @methodSwap SetVectorArray_EBB7509C_H500372C6
        */
        public SetVectorArray ($nameID: int, $values: Vector4[]) : void
        public SetMatrixArray ($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * @methodSwap SetMatrixArray_EBB7509C_H73E77D48
        */
        public SetMatrixArray ($nameID: int, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * Sets a matrix array property.
        * @param name Property name.
        * @param values Array of values to set.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        */
        public SetMatrixArray ($name: string, $values: Matrix4x4[]) : void
        /**
        * Sets a matrix array property.
        * @param name Property name.
        * @param values Array of values to set.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @methodSwap SetMatrixArray_EBB7509C_H4B572A74
        */
        public SetMatrixArray ($nameID: int, $values: Matrix4x4[]) : void
        /**
        * This method is deprecated. Use GetFloat or GetInteger instead.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetInt ($name: string) : int
        /**
        * This method is deprecated. Use GetFloat or GetInteger instead.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetInt_EBB7509C_F92D023A
        */
        public GetInt ($nameID: int) : int
        /**
        * Get a named float value.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetFloat ($name: string) : float
        /**
        * Get a named float value.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetFloat_EBB7509C_F92D023A
        */
        public GetFloat ($nameID: int) : float
        /**
        * Get a named integer value.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetInteger ($name: string) : int
        /**
        * Get a named integer value.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetInteger_EBB7509C_F92D023A
        */
        public GetInteger ($nameID: int) : int
        /**
        * Get a named color value.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetColor ($name: string) : Color
        /**
        * Get a named color value.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetColor_EBB7509C_F92D023A
        */
        public GetColor ($nameID: int) : Color
        /**
        * Get a named vector value.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetVector ($name: string) : Vector4
        /**
        * Get a named vector value.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetVector_EBB7509C_F92D023A
        */
        public GetVector ($nameID: int) : Vector4
        /**
        * Get a named matrix value from the shader.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetMatrix ($name: string) : Matrix4x4
        /**
        * Get a named matrix value from the shader.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetMatrix_EBB7509C_F92D023A
        */
        public GetMatrix ($nameID: int) : Matrix4x4
        /**
        * Get a named texture.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetTexture ($name: string) : Texture
        /**
        * Get a named texture.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetTexture_EBB7509C_F92D023A
        */
        public GetTexture ($nameID: int) : Texture
        /**
        * Get a named Graphics Buffer value.
        * @param name The name of the graphics buffer resource property to return.
        * @returns Returns the handle of the graphics buffer resource property.
        */
        public GetBuffer ($name: string) : GraphicsBufferHandle
        /**
        * Get a named Constant Buffer value.
        * @param name The name of the constant buffer property to return.
        * @returns Returns the handle of the constant buffer graphics resource.
        */
        public GetConstantBuffer ($name: string) : GraphicsBufferHandle
        /**
        * Get a named float array.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        */
        public GetFloatArray ($name: string) : float[]
        /**
        * Get a named float array.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @methodSwap GetFloatArray_EBB7509C_F92D023A
        */
        public GetFloatArray ($nameID: int) : float[]
        /**
        * Get a named color array.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetColorArray ($name: string) : Color[]
        /**
        * Get a named color array.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetColorArray_EBB7509C_F92D023A
        */
        public GetColorArray ($nameID: int) : Color[]
        /**
        * Get a named vector array.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        */
        public GetVectorArray ($name: string) : Vector4[]
        /**
        * Get a named vector array.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @methodSwap GetVectorArray_EBB7509C_F92D023A
        */
        public GetVectorArray ($nameID: int) : Vector4[]
        /**
        * Get a named matrix array.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        */
        public GetMatrixArray ($name: string) : Matrix4x4[]
        /**
        * Get a named matrix array.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @methodSwap GetMatrixArray_EBB7509C_F92D023A
        */
        public GetMatrixArray ($nameID: int) : Matrix4x4[]
        public GetFloatArray ($name: string, $values: System_Collections_Generic.List$1<float>) : void
        /**
        * @methodSwap GetFloatArray_EBB7509C_E8859065
        */
        public GetFloatArray ($nameID: int, $values: System_Collections_Generic.List$1<float>) : void
        public GetColorArray ($name: string, $values: System_Collections_Generic.List$1<Color>) : void
        /**
        * @methodSwap GetColorArray_EBB7509C_H90245058
        */
        public GetColorArray ($nameID: int, $values: System_Collections_Generic.List$1<Color>) : void
        public GetVectorArray ($name: string, $values: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * @methodSwap GetVectorArray_EBB7509C_H5C64F93A
        */
        public GetVectorArray ($nameID: int, $values: System_Collections_Generic.List$1<Vector4>) : void
        public GetMatrixArray ($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * @methodSwap GetMatrixArray_EBB7509C_H73E77D48
        */
        public GetMatrixArray ($nameID: int, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * Sets the placement offset of a given texture. The name parameter is defined in the shader. This method creates a new Material instance.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name The name of the texture property as defined in the shader. For example: "_MainTex".
        * @param value Texture placement offset.
        */
        public SetTextureOffset ($name: string, $value: Vector2) : void
        /**
        * Sets the placement offset of a given texture. The name parameter is defined in the shader. This method creates a new Material instance.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name The name of the texture property as defined in the shader. For example: "_MainTex".
        * @param value Texture placement offset.
        * @methodSwap SetTextureOffset_EBB7509C_BF0EA24
        */
        public SetTextureOffset ($nameID: int, $value: Vector2) : void
        /**
        * Sets the placement scale of texture propertyName.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_MainTex".
        * @param value Texture placement scale.
        */
        public SetTextureScale ($name: string, $value: Vector2) : void
        /**
        * Sets the placement scale of texture propertyName.
        * @param nameID Property name ID, use Shader.PropertyToID to get it.
        * @param name Property name, e.g. "_MainTex".
        * @param value Texture placement scale.
        * @methodSwap SetTextureScale_EBB7509C_BF0EA24
        */
        public SetTextureScale ($nameID: int, $value: Vector2) : void
        /**
        * Gets the placement offset of texture propertyName.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetTextureOffset ($name: string) : Vector2
        /**
        * Gets the placement offset of texture propertyName.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetTextureOffset_EBB7509C_F92D023A
        */
        public GetTextureOffset ($nameID: int) : Vector2
        /**
        * Gets the placement scale of texture propertyName.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetTextureScale ($name: string) : Vector2
        /**
        * Gets the placement scale of texture propertyName.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetTextureScale_EBB7509C_F92D023A
        */
        public GetTextureScale ($nameID: int) : Vector2
        /**
        * Retrieves a list of the named properties in the material that match the input property type.
        * @param type The type to use to query the material for named properties.
        */
        public GetPropertyNames ($type: MaterialPropertyType) : string[]
        public constructor ()
    }

    /**
    * The type of a given material property.
    */
    enum MaterialPropertyType {
        Float = 0,
        Int = 1,
        Vector = 2,
        Matrix = 3,
        Texture = 4,
        ConstantBuffer = 5,
        ComputeBuffer = 6 
    }

    /**
    * How the material interacts with lightmaps and lightprobes.
    */
    enum MaterialGlobalIlluminationFlags {
        None = 0,
        RealtimeEmissive = 1,
        BakedEmissive = 2,
        EmissiveIsBlack = 4,
        AnyEmissive = 3 
    }

    /**
    * Fully describes setup of RenderTarget.
    */
    class RenderTargetSetup extends System.ValueType {

        /**
        * Color Buffers to set.
        */
        public color : RenderBuffer[]
        /**
        * Depth Buffer to set.
        */
        public depth : RenderBuffer
        /**
        * Mip Level to render to.
        */
        public mipLevel : int
        /**
        * Cubemap face to render to.
        */
        public cubemapFace : CubemapFace
        /**
        * Slice of a Texture3D or Texture2DArray to set as a render target.
        */
        public depthSlice : int
        /**
        * Load Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.
        */
        public colorLoad : UnityEngine_Rendering.RenderBufferLoadAction[]
        /**
        * Store Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.
        */
        public colorStore : UnityEngine_Rendering.RenderBufferStoreAction[]
        /**
        * Load Action for Depth Buffer. It will override any actions set on RenderBuffer itself.
        */
        public depthLoad : UnityEngine_Rendering.RenderBufferLoadAction
        /**
        * Store Actions for Depth Buffer. It will override any actions set on RenderBuffer itself.
        */
        public depthStore : UnityEngine_Rendering.RenderBufferStoreAction

        public constructor ($color: RenderBuffer[], $depth: RenderBuffer, $mip: int, $face: CubemapFace, $colorLoad: UnityEngine_Rendering.RenderBufferLoadAction[], $colorStore: UnityEngine_Rendering.RenderBufferStoreAction[], $depthLoad: UnityEngine_Rendering.RenderBufferLoadAction, $depthStore: UnityEngine_Rendering.RenderBufferStoreAction)
        /**
        * Constructs RenderTargetSetup.
        * @param color Color Buffer(s) to set.
        * @param depth Depth Buffer to set.
        * @param mipLevel Mip Level to render to.
        * @param face Cubemap face to render to.
        */
        public constructor ($color: RenderBuffer, $depth: RenderBuffer)
        /**
        * Constructs RenderTargetSetup.
        * @param color Color Buffer(s) to set.
        * @param depth Depth Buffer to set.
        * @param mipLevel Mip Level to render to.
        * @param face Cubemap face to render to.
        */
        public constructor ($color: RenderBuffer, $depth: RenderBuffer, $mipLevel: int)
        /**
        * Constructs RenderTargetSetup.
        * @param color Color Buffer(s) to set.
        * @param depth Depth Buffer to set.
        * @param mipLevel Mip Level to render to.
        * @param face Cubemap face to render to.
        */
        public constructor ($color: RenderBuffer, $depth: RenderBuffer, $mipLevel: int, $face: CubemapFace)
        public constructor ($color: RenderBuffer, $depth: RenderBuffer, $mipLevel: int, $face: CubemapFace, $depthSlice: int)
        /**
        * Constructs RenderTargetSetup.
        * @param color Color Buffer(s) to set.
        * @param depth Depth Buffer to set.
        * @param mipLevel Mip Level to render to.
        * @param face Cubemap face to render to.
        */
        public constructor ($color: RenderBuffer[], $depth: RenderBuffer)
        /**
        * Constructs RenderTargetSetup.
        * @param color Color Buffer(s) to set.
        * @param depth Depth Buffer to set.
        * @param mipLevel Mip Level to render to.
        * @param face Cubemap face to render to.
        */
        public constructor ($color: RenderBuffer[], $depth: RenderBuffer, $mipLevel: int)
        /**
        * Constructs RenderTargetSetup.
        * @param color Color Buffer(s) to set.
        * @param depth Depth Buffer to set.
        * @param mipLevel Mip Level to render to.
        * @param face Cubemap face to render to.
        */
        public constructor ($color: RenderBuffer[], $depth: RenderBuffer, $mip: int, $face: CubemapFace)
    }

    /**
    * A class that allows you to create or modify meshes.
    */
    class Mesh extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Format of the mesh index buffer data.
        */
        public get indexFormat(): UnityEngine_Rendering.IndexFormat;
        public set indexFormat(value: UnityEngine_Rendering.IndexFormat);
        /**
        * Gets the number of vertex buffers present in the Mesh. (Read Only)
        */
        public get vertexBufferCount(): int;
        /**
        * The intended target usage of the Mesh GPU vertex buffer.
        */
        public get vertexBufferTarget(): UnityEngine_GraphicsBuffer.Target;
        public set vertexBufferTarget(value: UnityEngine_GraphicsBuffer.Target);
        /**
        * The intended target usage of the Mesh GPU index buffer.
        */
        public get indexBufferTarget(): UnityEngine_GraphicsBuffer.Target;
        public set indexBufferTarget(value: UnityEngine_GraphicsBuffer.Target);
        /**
        * Returns BlendShape count on this mesh.
        */
        public get blendShapeCount(): int;
        /**
        * The number of bindposes in the Mesh.
        */
        public get bindposeCount(): int;
        /**
        * The bind poses. The bind pose at each index refers to the bone with the same index.
        */
        public get bindposes(): Matrix4x4[];
        public set bindposes(value: Matrix4x4[]);
        /**
        * Returns true if the Mesh is read/write enabled, or false if it is not.
        */
        public get isReadable(): boolean;
        /**
        * Returns the number of vertices in the Mesh (Read Only).
        */
        public get vertexCount(): int;
        /**
        * The number of sub-meshes inside the Mesh object.
        */
        public get subMeshCount(): int;
        public set subMeshCount(value: int);
        /**
        * The bounding volume of the Mesh.
        */
        public get bounds(): Bounds;
        public set bounds(value: Bounds);
        /**
        * Returns a copy of the vertex positions or assigns a new vertex positions array.
        */
        public get vertices(): Vector3[];
        public set vertices(value: Vector3[]);
        /**
        * The normals of the Mesh.
        */
        public get normals(): Vector3[];
        public set normals(value: Vector3[]);
        /**
        * The tangents of the Mesh.
        */
        public get tangents(): Vector4[];
        public set tangents(value: Vector4[]);
        /**
        * The texture coordinates (UVs) in the first channel.
        */
        public get uv(): Vector2[];
        public set uv(value: Vector2[]);
        /**
        * The texture coordinates (UVs) in the second channel.
        */
        public get uv2(): Vector2[];
        public set uv2(value: Vector2[]);
        /**
        * The texture coordinates (UVs) in the third channel.
        */
        public get uv3(): Vector2[];
        public set uv3(value: Vector2[]);
        /**
        * The texture coordinates (UVs) in the fourth channel.
        */
        public get uv4(): Vector2[];
        public set uv4(value: Vector2[]);
        /**
        * The texture coordinates (UVs) in the fifth channel.
        */
        public get uv5(): Vector2[];
        public set uv5(value: Vector2[]);
        /**
        * The texture coordinates (UVs) in the sixth channel.
        */
        public get uv6(): Vector2[];
        public set uv6(value: Vector2[]);
        /**
        * The texture coordinates (UVs) in the seventh channel.
        */
        public get uv7(): Vector2[];
        public set uv7(value: Vector2[]);
        /**
        * The texture coordinates (UVs) in the eighth channel.
        */
        public get uv8(): Vector2[];
        public set uv8(value: Vector2[]);
        /**
        * Vertex colors of the Mesh.
        */
        public get colors(): Color[];
        public set colors(value: Color[]);
        /**
        * Vertex colors of the Mesh.
        */
        public get colors32(): Color32[];
        public set colors32(value: Color32[]);
        /**
        * Returns the number of vertex attributes that the mesh has. (Read Only)
        */
        public get vertexAttributeCount(): int;
        /**
        * An array containing all triangles in the Mesh.
        */
        public get triangles(): int[];
        public set triangles(value: int[]);
        /**
        * The BoneWeight for each vertex in the Mesh, which represents 4 bones per vertex.
        */
        public get boneWeights(): BoneWeight[];
        public set boneWeights(value: BoneWeight[]);
        /**
        * The dimension of data in the bone weight buffer.
        */
        public get skinWeightBufferLayout(): SkinWeights;

        /**
        * Creates an empty Mesh.
        */
        public constructor ()
        /**
        * Sets the index buffer size and format.
        * @param indexCount Size of index buffer.
        * @param format Format of the indices.
        */
        public SetIndexBufferParams ($indexCount: int, $format: UnityEngine_Rendering.IndexFormat) : void
        /**
        * Returns information about a vertex attribute based on its index.
        * @param index The vertex attribute index (0 to vertexAttributeCount-1).
        * @returns Information about the vertex attribute.
        */
        public GetVertexAttribute ($index: int) : UnityEngine_Rendering.VertexAttributeDescriptor
        /**
        * Checks if a specific vertex data attribute exists on this Mesh.
        * @param attr Vertex data attribute to check for.
        * @returns Returns true if the data attribute is present in the mesh.
        */
        public HasVertexAttribute ($attr: UnityEngine_Rendering.VertexAttribute) : boolean
        /**
        * Get dimension of a specific vertex data attribute on this Mesh.
        * @param attr Vertex data attribute to check for.
        * @returns Dimensionality of the data attribute, or zero if it is not present.
        */
        public GetVertexAttributeDimension ($attr: UnityEngine_Rendering.VertexAttribute) : int
        /**
        * Get format of a specific vertex data attribute on this Mesh.
        * @param attr Vertex data attribute to check for.
        * @returns Format of the data attribute.
        */
        public GetVertexAttributeFormat ($attr: UnityEngine_Rendering.VertexAttribute) : UnityEngine_Rendering.VertexAttributeFormat
        /**
        * Gets the vertex buffer stream index of a specific vertex data attribute on this Mesh.
        * @param attr The vertex data attribute to check for.
        * @returns Stream index of the data attribute, or -1 if it is not present.
        */
        public GetVertexAttributeStream ($attr: UnityEngine_Rendering.VertexAttribute) : int
        /**
        * Get offset within a vertex buffer stream of a specific vertex data attribute on this Mesh.
        * @param attr The vertex data attribute to check for.
        * @returns The byte offset within a atream of the data attribute, or -1 if it is not present.
        */
        public GetVertexAttributeOffset ($attr: UnityEngine_Rendering.VertexAttribute) : int
        /**
        * Get vertex buffer stream stride in bytes.
        * @param stream Vertex data stream index to check for.
        * @returns Vertex data size in bytes in this stream, or zero if the stream is not present.
        */
        public GetVertexBufferStride ($stream: int) : int
        /**
        * Retrieves a native (underlying graphics API) pointer to the vertex buffer.
        * @param index Which vertex buffer to get (some Meshes might have more than one). See vertexBufferCount.
        * @returns Pointer to the underlying graphics API vertex buffer.
        */
        public GetNativeVertexBufferPtr ($index: int) : System.IntPtr
        /**
        * Retrieves a native (underlying graphics API) pointer to the index buffer.
        * @returns Pointer to the underlying graphics API index buffer.
        */
        public GetNativeIndexBufferPtr () : System.IntPtr
        /**
        * Clears all blend shapes from Mesh.
        */
        public ClearBlendShapes () : void
        /**
        * Returns name of BlendShape by given index.
        */
        public GetBlendShapeName ($shapeIndex: int) : string
        /**
        * Returns index of BlendShape by given name.
        */
        public GetBlendShapeIndex ($blendShapeName: string) : int
        /**
        * Returns the frame count for a blend shape.
        * @param shapeIndex The shape index to get frame count from.
        */
        public GetBlendShapeFrameCount ($shapeIndex: int) : int
        /**
        * Returns the weight of a blend shape frame.
        * @param shapeIndex The shape index of the frame.
        * @param frameIndex The frame index to get the weight from.
        */
        public GetBlendShapeFrameWeight ($shapeIndex: int, $frameIndex: int) : float
        /**
        * Retreives deltaVertices, deltaNormals and deltaTangents of a blend shape frame.
        * @param shapeIndex The shape index of the frame.
        * @param frameIndex The frame index to get the weight from.
        * @param deltaVertices Delta vertices output array for the frame being retreived.
        * @param deltaNormals Delta normals output array for the frame being retreived.
        * @param deltaTangents Delta tangents output array for the frame being retreived.
        */
        public GetBlendShapeFrameVertices ($shapeIndex: int, $frameIndex: int, $deltaVertices: Vector3[], $deltaNormals: Vector3[], $deltaTangents: Vector3[]) : void
        /**
        * Adds a new blend shape frame.
        * @param shapeName Name of the blend shape to add a frame to.
        * @param frameWeight Weight for the frame being added.
        * @param deltaVertices Delta vertices for the frame being added.
        * @param deltaNormals Delta normals for the frame being added.
        * @param deltaTangents Delta tangents for the frame being added.
        */
        public AddBlendShapeFrame ($shapeName: string, $frameWeight: float, $deltaVertices: Vector3[], $deltaNormals: Vector3[], $deltaTangents: Vector3[]) : void
        public SetBoneWeights ($bonesPerVertex: Unity_Collections.NativeArray$1<byte>, $weights: Unity_Collections.NativeArray$1<BoneWeight1>) : void
        /**
        * Gets the bone weights for the Mesh.
        * @returns Returns all non-zero bone weights for the Mesh, in vertex index order.
        */
        public GetAllBoneWeights () : Unity_Collections.NativeArray$1<BoneWeight1>
        /**
        * The number of non-zero bone weights for each vertex.
        * @returns Returns the number of non-zero bone weights for each vertex.
        */
        public GetBonesPerVertex () : Unity_Collections.NativeArray$1<byte>
        /**
        * Gets the bind poses of the Mesh.
        * @returns The array of bindposes belonging to the Mesh.
        */
        public GetBindposes () : Unity_Collections.NativeArray$1<Matrix4x4>
        /**
        * Sets the information about a sub-mesh of the Mesh.
        * @param index Sub-mesh index. See subMeshCount. Out of range indices throw an exception.
        * @param desc Sub-mesh data.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        */
        public SetSubMesh ($index: int, $desc: UnityEngine_Rendering.SubMeshDescriptor, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Get information about a sub-mesh of the Mesh.
        * @param index Sub-mesh index. See subMeshCount. Out of range indices throw an exception.
        * @returns Sub-mesh data.
        */
        public GetSubMesh ($index: int) : UnityEngine_Rendering.SubMeshDescriptor
        /**
        * Notify Renderer components of mesh geometry change.
        */
        public MarkModified () : void
        /**
        * The UV distribution metric can be used to calculate the desired mipmap level based on the position of the camera.
        * @param uvSetIndex UV set index to return the UV distibution metric for. 0 for first.
        * @returns Average of triangle area / uv area.
        */
        public GetUVDistributionMetric ($uvSetIndex: int) : float
        public GetVertices ($vertices: System_Collections_Generic.List$1<Vector3>) : void
        public SetVertices ($inVertices: System_Collections_Generic.List$1<Vector3>) : void
        /**
        * @methodSwap SetVertices_EBB7509C_BB384656
        */
        public SetVertices ($inVertices: System_Collections_Generic.List$1<Vector3>, $start: int, $length: int) : void
        /**
        * @methodSwap SetVertices_EBB7509C_H8444A932
        */
        public SetVertices ($inVertices: System_Collections_Generic.List$1<Vector3>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Assigns a new vertex positions array.
        * @param inVertices Per-vertex positions.
        */
        public SetVertices ($inVertices: Vector3[]) : void
        /**
        * Sets the vertex positions of the Mesh, using a part of the input array.
        * @param inVertices Per-vertex positions.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetVertices_EBB7509C_H4D5EC09A
        */
        public SetVertices ($inVertices: Vector3[], $start: int, $length: int) : void
        /**
        * Sets the vertex positions of the Mesh, using a part of the input array.
        * @param inVertices Per-vertex positions.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetVertices_EBB7509C_H586066AE
        */
        public SetVertices ($inVertices: Vector3[], $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        public SetVertices<T> ($inVertices: Unity_Collections.NativeArray$1<T>) : void
        /**
        * @methodSwap SetVertices_EBB7509C_H51A2967A
        */
        public SetVertices<T> ($inVertices: Unity_Collections.NativeArray$1<T>, $start: int, $length: int) : void
        /**
        * @methodSwap SetVertices_EBB7509C_H463A3C8E
        */
        public SetVertices<T> ($inVertices: Unity_Collections.NativeArray$1<T>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        public GetNormals ($normals: System_Collections_Generic.List$1<Vector3>) : void
        public SetNormals ($inNormals: System_Collections_Generic.List$1<Vector3>) : void
        /**
        * @methodSwap SetNormals_EBB7509C_BB384656
        */
        public SetNormals ($inNormals: System_Collections_Generic.List$1<Vector3>, $start: int, $length: int) : void
        /**
        * @methodSwap SetNormals_EBB7509C_H8444A932
        */
        public SetNormals ($inNormals: System_Collections_Generic.List$1<Vector3>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Set the normals of the Mesh.
        * @param inNormals Per-vertex normals.
        */
        public SetNormals ($inNormals: Vector3[]) : void
        /**
        * Sets the vertex normals of the Mesh, using a part of the input array.
        * @param inNormals Per-vertex normals.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetNormals_EBB7509C_H4D5EC09A
        */
        public SetNormals ($inNormals: Vector3[], $start: int, $length: int) : void
        /**
        * Sets the vertex normals of the Mesh, using a part of the input array.
        * @param inNormals Per-vertex normals.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetNormals_EBB7509C_H586066AE
        */
        public SetNormals ($inNormals: Vector3[], $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        public SetNormals<T> ($inNormals: Unity_Collections.NativeArray$1<T>) : void
        /**
        * @methodSwap SetNormals_EBB7509C_H51A2967A
        */
        public SetNormals<T> ($inNormals: Unity_Collections.NativeArray$1<T>, $start: int, $length: int) : void
        /**
        * @methodSwap SetNormals_EBB7509C_H463A3C8E
        */
        public SetNormals<T> ($inNormals: Unity_Collections.NativeArray$1<T>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        public GetTangents ($tangents: System_Collections_Generic.List$1<Vector4>) : void
        public SetTangents ($inTangents: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * @methodSwap SetTangents_EBB7509C_H2CDB2565
        */
        public SetTangents ($inTangents: System_Collections_Generic.List$1<Vector4>, $start: int, $length: int) : void
        /**
        * @methodSwap SetTangents_EBB7509C_CE6A6557
        */
        public SetTangents ($inTangents: System_Collections_Generic.List$1<Vector4>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Set the tangents of the Mesh.
        * @param inTangents Per-vertex tangents.
        */
        public SetTangents ($inTangents: Vector4[]) : void
        /**
        * Sets the tangents of the Mesh, using a part of the input array.
        * @param inTangents Per-vertex tangents.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetTangents_EBB7509C_F5D926F
        */
        public SetTangents ($inTangents: Vector4[], $start: int, $length: int) : void
        /**
        * Sets the tangents of the Mesh, using a part of the input array.
        * @param inTangents Per-vertex tangents.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetTangents_EBB7509C_H9C6616D9
        */
        public SetTangents ($inTangents: Vector4[], $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        public SetTangents<T> ($inTangents: Unity_Collections.NativeArray$1<T>) : void
        /**
        * @methodSwap SetTangents_EBB7509C_H51A2967A
        */
        public SetTangents<T> ($inTangents: Unity_Collections.NativeArray$1<T>, $start: int, $length: int) : void
        /**
        * @methodSwap SetTangents_EBB7509C_H463A3C8E
        */
        public SetTangents<T> ($inTangents: Unity_Collections.NativeArray$1<T>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        public GetColors ($colors: System_Collections_Generic.List$1<Color>) : void
        public SetColors ($inColors: System_Collections_Generic.List$1<Color>) : void
        /**
        * @methodSwap SetColors_EBB7509C_H58F7D49B
        */
        public SetColors ($inColors: System_Collections_Generic.List$1<Color>, $start: int, $length: int) : void
        /**
        * @methodSwap SetColors_EBB7509C_H980C0C8D
        */
        public SetColors ($inColors: System_Collections_Generic.List$1<Color>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Set the per-vertex colors of the Mesh.
        * @param inColors Per-vertex colors.
        */
        public SetColors ($inColors: Color[]) : void
        /**
        * Sets the per-vertex colors of the Mesh, using a part of the input array.
        * @param inColors Per-vertex colors.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetColors_EBB7509C_H6C48EC51
        */
        public SetColors ($inColors: Color[], $start: int, $length: int) : void
        /**
        * Sets the per-vertex colors of the Mesh, using a part of the input array.
        * @param inColors Per-vertex colors.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetColors_EBB7509C_H4C9A6A2B
        */
        public SetColors ($inColors: Color[], $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        public GetColors ($colors: System_Collections_Generic.List$1<Color32>) : void
        public SetColors ($inColors: System_Collections_Generic.List$1<Color32>) : void
        /**
        * @methodSwap SetColors_EBB7509C_CE8514A4
        */
        public SetColors ($inColors: System_Collections_Generic.List$1<Color32>, $start: int, $length: int) : void
        /**
        * @methodSwap SetColors_EBB7509C_DB515678
        */
        public SetColors ($inColors: System_Collections_Generic.List$1<Color32>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Set the per-vertex colors of the Mesh.
        * @param inColors Per-vertex colors.
        */
        public SetColors ($inColors: Color32[]) : void
        /**
        * Sets the per-vertex colors of the Mesh, using a part of the input array.
        * @param inColors Per-vertex colors.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetColors_EBB7509C_E139A550
        */
        public SetColors ($inColors: Color32[], $start: int, $length: int) : void
        /**
        * Sets the per-vertex colors of the Mesh, using a part of the input array.
        * @param inColors Per-vertex colors.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetColors_EBB7509C_H100C0E4C
        */
        public SetColors ($inColors: Color32[], $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        public SetColors<T> ($inColors: Unity_Collections.NativeArray$1<T>) : void
        /**
        * @methodSwap SetColors_EBB7509C_H51A2967A
        */
        public SetColors<T> ($inColors: Unity_Collections.NativeArray$1<T>, $start: int, $length: int) : void
        /**
        * @methodSwap SetColors_EBB7509C_H463A3C8E
        */
        public SetColors<T> ($inColors: Unity_Collections.NativeArray$1<T>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * @methodSwap SetUVs_EBB7509C_H5C7403C4
        */
        public SetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector2>) : void
        /**
        * @methodSwap SetUVs_EBB7509C_H5E764581
        */
        public SetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector3>) : void
        /**
        * @methodSwap SetUVs_EBB7509C_H5C64F93A
        */
        public SetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * @methodSwap SetUVs_EBB7509C_E8FE1DD8
        */
        public SetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector2>, $start: int, $length: int) : void
        /**
        * @methodSwap SetUVs_EBB7509C_H93A09174
        */
        public SetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector2>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * @methodSwap SetUVs_EBB7509C_AF02D1B5
        */
        public SetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector3>, $start: int, $length: int) : void
        /**
        * @methodSwap SetUVs_EBB7509C_E4E6B247
        */
        public SetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector3>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * @methodSwap SetUVs_EBB7509C_H5E494FA6
        */
        public SetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector4>, $start: int, $length: int) : void
        /**
        * @methodSwap SetUVs_EBB7509C_E65D5362
        */
        public SetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector4>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Sets the texture coordinates (UVs) stored in a given channel.
        * @param channel The channel, in [0..7] range.
        * @param uvs The UV data to set.
        * @methodSwap SetUVs_EBB7509C_H278E5410
        */
        public SetUVs ($channel: int, $uvs: Vector2[]) : void
        /**
        * Sets the texture coordinates (UVs) stored in a given channel.
        * @param channel The channel, in [0..7] range.
        * @param uvs The UV data to set.
        * @methodSwap SetUVs_EBB7509C_H5417C19B
        */
        public SetUVs ($channel: int, $uvs: Vector3[]) : void
        /**
        * Sets the texture coordinates (UVs) stored in a given channel.
        * @param channel The channel, in [0..7] range.
        * @param uvs The UV data to set.
        * @methodSwap SetUVs_EBB7509C_H500372C6
        */
        public SetUVs ($channel: int, $uvs: Vector4[]) : void
        /**
        * Sets the UVs of the Mesh, using a part of the input array.
        * @param channel The UV channel, in [0..7] range.
        * @param uvs UVs to set for the given index.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetUVs_EBB7509C_H94E6E044
        */
        public SetUVs ($channel: int, $uvs: Vector2[], $start: int, $length: int) : void
        /**
        * Sets the UVs of the Mesh, using a part of the input array.
        * @param channel The UV channel, in [0..7] range.
        * @param uvs UVs to set for the given index.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetUVs_EBB7509C_ED4CD198
        */
        public SetUVs ($channel: int, $uvs: Vector2[], $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Sets the UVs of the Mesh, using a part of the input array.
        * @param channel The UV channel, in [0..7] range.
        * @param uvs UVs to set for the given index.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetUVs_EBB7509C_E09D19F7
        */
        public SetUVs ($channel: int, $uvs: Vector3[], $start: int, $length: int) : void
        /**
        * Sets the UVs of the Mesh, using a part of the input array.
        * @param channel The UV channel, in [0..7] range.
        * @param uvs UVs to set for the given index.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetUVs_EBB7509C_CDB4B1A1
        */
        public SetUVs ($channel: int, $uvs: Vector3[], $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Sets the UVs of the Mesh, using a part of the input array.
        * @param channel The UV channel, in [0..7] range.
        * @param uvs UVs to set for the given index.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetUVs_EBB7509C_H5388F142
        */
        public SetUVs ($channel: int, $uvs: Vector4[], $start: int, $length: int) : void
        /**
        * Sets the UVs of the Mesh, using a part of the input array.
        * @param channel The UV channel, in [0..7] range.
        * @param uvs UVs to set for the given index.
        * @param start Index of the first element to take from the input array.
        * @param length Number of elements to take from the input array.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetUVs_EBB7509C_H243DD9B6
        */
        public SetUVs ($channel: int, $uvs: Vector4[], $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * @methodSwap SetUVs_EBB7509C_BB85FF6F
        */
        public SetUVs<T> ($channel: int, $uvs: Unity_Collections.NativeArray$1<T>) : void
        /**
        * @methodSwap SetUVs_EBB7509C_H2E8BBD9B
        */
        public SetUVs<T> ($channel: int, $uvs: Unity_Collections.NativeArray$1<T>, $start: int, $length: int) : void
        /**
        * @methodSwap SetUVs_EBB7509C_B682FF8D
        */
        public SetUVs<T> ($channel: int, $uvs: Unity_Collections.NativeArray$1<T>, $start: int, $length: int, $flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * @methodSwap GetUVs_EBB7509C_H5C7403C4
        */
        public GetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector2>) : void
        /**
        * @methodSwap GetUVs_EBB7509C_H5E764581
        */
        public GetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector3>) : void
        /**
        * @methodSwap GetUVs_EBB7509C_H5C64F93A
        */
        public GetUVs ($channel: int, $uvs: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * Get information about vertex attributes of a Mesh.
        * @returns Array of vertex attribute information.
        */
        public GetVertexAttributes () : UnityEngine_Rendering.VertexAttributeDescriptor[]
        /**
        * Get information about vertex attributes of a Mesh, without memory allocations.
        * @param attributes Collection of vertex attributes to receive the results.
        * @returns The number of vertex attributes returned in the attributes container.
        */
        public GetVertexAttributes ($attributes: UnityEngine_Rendering.VertexAttributeDescriptor[]) : int
        public GetVertexAttributes ($attributes: System_Collections_Generic.List$1<UnityEngine_Rendering.VertexAttributeDescriptor>) : int
        /**
        * Sets the vertex buffer size and layout.
        * @param vertexCount The number of vertices in the Mesh.
        * @param attributes Layout of the vertex data -- which attributes are present, their data types and so on.
        * @methodSwap SetVertexBufferParams_EBB7509C_H271C9F3C
        */
        public SetVertexBufferParams ($vertexCount: int, ...attributes: UnityEngine_Rendering.VertexAttributeDescriptor[]) : void
        /**
        * @methodSwap SetVertexBufferParams_EBB7509C_H8491BD1
        */
        public SetVertexBufferParams ($vertexCount: int, $attributes: Unity_Collections.NativeArray$1<UnityEngine_Rendering.VertexAttributeDescriptor>) : void
        /**
        * @methodSwap SetVertexBufferData_EBB7509C_DC1C0DA2
        */
        public SetVertexBufferData<T> ($data: Unity_Collections.NativeArray$1<T>, $dataStart: int, $meshBufferStart: int, $count: int, $stream?: int, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * @methodSwap SetVertexBufferData_EBB7509C_E5E4AB1F
        */
        public SetVertexBufferData<T> ($data: T[], $dataStart: int, $meshBufferStart: int, $count: int, $stream?: int, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * @methodSwap SetVertexBufferData_EBB7509C_H80553B69
        */
        public SetVertexBufferData<T> ($data: System_Collections_Generic.List$1<T>, $dataStart: int, $meshBufferStart: int, $count: int, $stream?: int, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Gets a snapshot of Mesh data for read-only access.
        * @param mesh The input mesh.
        * @param meshes The input meshes.
        * @returns Returns a MeshDataArray containing read-only MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData.
        */
        public static AcquireReadOnlyMeshData ($mesh: Mesh) : UnityEngine_Mesh.MeshDataArray
        /**
        * Gets a snapshot of Mesh data for read-only access.
        * @param mesh The input mesh.
        * @param meshes The input meshes.
        * @returns Returns a MeshDataArray containing read-only MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData.
        */
        public static AcquireReadOnlyMeshData ($meshes: Mesh[]) : UnityEngine_Mesh.MeshDataArray
        public static AcquireReadOnlyMeshData ($meshes: System_Collections_Generic.List$1<Mesh>) : UnityEngine_Mesh.MeshDataArray
        /**
        * Allocates data structures for Mesh creation using C# Jobs.
        * @param meshCount The amount of meshes that will be created.
        * @returns Returns a MeshDataArray containing writeable MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData.
        */
        public static AllocateWritableMeshData ($meshCount: int) : UnityEngine_Mesh.MeshDataArray
        /**
        * Applies data defined in MeshData structs to Mesh objects.
        * @param data The mesh data array, see Mesh.MeshDataArray.
        * @param mesh The destination Mesh. Mesh data array must be of size 1.
        * @param meshes The destination Meshes. Must match the size of mesh data array.
        * @param flags The mesh data update flags, see MeshUpdateFlags.
        */
        public static ApplyAndDisposeWritableMeshData ($data: UnityEngine_Mesh.MeshDataArray, $mesh: Mesh, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Applies data defined in MeshData structs to Mesh objects.
        * @param data The mesh data array, see Mesh.MeshDataArray.
        * @param mesh The destination Mesh. Mesh data array must be of size 1.
        * @param meshes The destination Meshes. Must match the size of mesh data array.
        * @param flags The mesh data update flags, see MeshUpdateFlags.
        */
        public static ApplyAndDisposeWritableMeshData ($data: UnityEngine_Mesh.MeshDataArray, $meshes: Mesh[], $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        public static ApplyAndDisposeWritableMeshData ($data: UnityEngine_Mesh.MeshDataArray, $meshes: System_Collections_Generic.List$1<Mesh>, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Retrieves a GraphicsBuffer that provides direct acces to the GPU vertex buffer.
        * @param index Vertex data stream index to get the buffer for.
        * @returns The mesh vertex buffer as a GraphicsBuffer.
        */
        public GetVertexBuffer ($index: int) : GraphicsBuffer
        /**
        * Retrieves a GraphicsBuffer to the GPU index buffer.
        * @returns The mesh index buffer as a GraphicsBuffer.
        */
        public GetIndexBuffer () : GraphicsBuffer
        /**
        * Retrieves a GraphicsBuffer that provides direct read and write access to GPU bone weight data.
        * @param layout Which buffer to access, based on maximum bones per vertex.
        * @returns The bone weight data as a GraphicsBuffer.
        */
        public GetBoneWeightBuffer ($layout: SkinWeights) : GraphicsBuffer
        /**
        * Retrieves a GraphicsBuffer that provides direct read and write access to GPU blend shape vertex data.
        * @param layout Which buffer to access. The default value is Rendering.BlendShapeBufferLayout.PerShape.
        * @returns The blend shape vertex data as a GraphicsBuffer.
        */
        public GetBlendShapeBuffer ($layout: UnityEngine_Rendering.BlendShapeBufferLayout) : GraphicsBuffer
        /**
        * Retrieves a GraphicsBuffer that provides direct read and write access to GPU blend shape vertex data.
        * @param layout Which buffer to access. The default value is Rendering.BlendShapeBufferLayout.PerShape.
        * @returns The blend shape vertex data as a GraphicsBuffer.
        */
        public GetBlendShapeBuffer () : GraphicsBuffer
        /**
        * Get the location of blend shape vertex data for a given blend shape.
        * @param blendShapeIndex Which blend shape to locate the data for.
        * @returns A struct that describes the start and end index of the data for the given blend shape.
        */
        public GetBlendShapeBufferRange ($blendShapeIndex: int) : BlendShapeBufferRange
        /**
        * Fetches the triangle list for the specified sub-mesh on this object.
        * @param triangles A list of vertex indices to populate. Any existing items in the list are replaced.
        * @param submesh The sub-mesh index. See subMeshCount.
        * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
        * @methodSwap GetTriangles_EBB7509C_F92D023A
        */
        public GetTriangles ($submesh: int) : int[]
        /**
        * Fetches the triangle list for the specified sub-mesh on this object.
        * @param triangles A list of vertex indices to populate. Any existing items in the list are replaced.
        * @param submesh The sub-mesh index. See subMeshCount.
        * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
        * @methodSwap GetTriangles_EBB7509C_H5B11DF19
        */
        public GetTriangles ($submesh: int, $applyBaseVertex: boolean) : int[]
        /**
        * @methodSwap GetTriangles_EBB7509C_D450F175
        */
        public GetTriangles ($triangles: System_Collections_Generic.List$1<int>, $submesh: int) : void
        /**
        * @methodSwap GetTriangles_EBB7509C_H7EC0A5F2
        */
        public GetTriangles ($triangles: System_Collections_Generic.List$1<int>, $submesh: int, $applyBaseVertex: boolean) : void
        /**
        * @methodSwap GetTriangles_EBB7509C_H4274EE3
        */
        public GetTriangles ($triangles: System_Collections_Generic.List$1<ushort>, $submesh: int, $applyBaseVertex?: boolean) : void
        /**
        * Fetches the index list for the specified sub-mesh.
        * @param submesh The sub-mesh index. See subMeshCount.
        * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
        * @returns Array with face indices.
        * @methodSwap GetIndices_EBB7509C_F92D023A
        */
        public GetIndices ($submesh: int) : int[]
        /**
        * Fetches the index list for the specified sub-mesh.
        * @param submesh The sub-mesh index. See subMeshCount.
        * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
        * @returns Array with face indices.
        * @methodSwap GetIndices_EBB7509C_H5B11DF19
        */
        public GetIndices ($submesh: int, $applyBaseVertex: boolean) : int[]
        /**
        * @methodSwap GetIndices_EBB7509C_D450F175
        */
        public GetIndices ($indices: System_Collections_Generic.List$1<int>, $submesh: int) : void
        /**
        * @methodSwap GetIndices_EBB7509C_H7EC0A5F2
        */
        public GetIndices ($indices: System_Collections_Generic.List$1<int>, $submesh: int, $applyBaseVertex: boolean) : void
        /**
        * @methodSwap GetIndices_EBB7509C_H4274EE3
        */
        public GetIndices ($indices: System_Collections_Generic.List$1<ushort>, $submesh: int, $applyBaseVertex?: boolean) : void
        /**
        * @methodSwap SetIndexBufferData_EBB7509C_F573B397
        */
        public SetIndexBufferData<T> ($data: Unity_Collections.NativeArray$1<T>, $dataStart: int, $meshBufferStart: int, $count: int, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * @methodSwap SetIndexBufferData_EBB7509C_A3E7BD6
        */
        public SetIndexBufferData<T> ($data: T[], $dataStart: int, $meshBufferStart: int, $count: int, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * @methodSwap SetIndexBufferData_EBB7509C_H32607D58
        */
        public SetIndexBufferData<T> ($data: System_Collections_Generic.List$1<T>, $dataStart: int, $meshBufferStart: int, $count: int, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Gets the starting index location within the Mesh's index buffer, for the given sub-mesh.
        */
        public GetIndexStart ($submesh: int) : uint
        /**
        * Gets the index count of the given sub-mesh.
        */
        public GetIndexCount ($submesh: int) : uint
        /**
        * Gets the base vertex index of the given sub-mesh.
        * @param submesh The sub-mesh index. See subMeshCount.
        * @returns The offset applied to all vertex indices of this sub-mesh.
        */
        public GetBaseVertex ($submesh: int) : uint
        /**
        * Sets the triangle list for the sub-mesh.
        * @param triangles The list of indices that define the triangles.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
        * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
        * @methodSwap SetTriangles_EBB7509C_H7AB58BF5
        */
        public SetTriangles ($triangles: int[], $submesh: int) : void
        /**
        * Sets the triangle list for the sub-mesh.
        * @param triangles The list of indices that define the triangles.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
        * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
        * @methodSwap SetTriangles_EBB7509C_C040E072
        */
        public SetTriangles ($triangles: int[], $submesh: int, $calculateBounds: boolean) : void
        /**
        * Sets the triangle list for the sub-mesh.
        * @param triangles The list of indices that define the triangles.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
        * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
        * @methodSwap SetTriangles_EBB7509C_F9464DD
        */
        public SetTriangles ($triangles: int[], $submesh: int, $calculateBounds: boolean, $baseVertex: int) : void
        /**
        * Sets the triangle list of the Mesh, using a part of the input array.
        * @param triangles The list of indices that define the triangles.
        * @param trianglesStart Index of the first element to take from the input array.
        * @param trianglesLength Number of elements to take from the input array.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
        * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
        * @methodSwap SetTriangles_EBB7509C_FFED6869
        */
        public SetTriangles ($triangles: int[], $trianglesStart: int, $trianglesLength: int, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * Sets the triangle list for the sub-mesh.
        * @param triangles The list of indices that define the triangles.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
        * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
        * @methodSwap SetTriangles_EBB7509C_H24D99A96
        */
        public SetTriangles ($triangles: ushort[], $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * Sets the triangle list of the Mesh, using a part of the input array.
        * @param triangles The list of indices that define the triangles.
        * @param trianglesStart Index of the first element to take from the input array.
        * @param trianglesLength Number of elements to take from the input array.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
        * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
        * @methodSwap SetTriangles_EBB7509C_H7B6C211A
        */
        public SetTriangles ($triangles: ushort[], $trianglesStart: int, $trianglesLength: int, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * @methodSwap SetTriangles_EBB7509C_D450F175
        */
        public SetTriangles ($triangles: System_Collections_Generic.List$1<int>, $submesh: int) : void
        /**
        * @methodSwap SetTriangles_EBB7509C_H7EC0A5F2
        */
        public SetTriangles ($triangles: System_Collections_Generic.List$1<int>, $submesh: int, $calculateBounds: boolean) : void
        /**
        * @methodSwap SetTriangles_EBB7509C_H4D13AE5D
        */
        public SetTriangles ($triangles: System_Collections_Generic.List$1<int>, $submesh: int, $calculateBounds: boolean, $baseVertex: int) : void
        /**
        * @methodSwap SetTriangles_EBB7509C_D419D9E9
        */
        public SetTriangles ($triangles: System_Collections_Generic.List$1<int>, $trianglesStart: int, $trianglesLength: int, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * @methodSwap SetTriangles_EBB7509C_A32B78C4
        */
        public SetTriangles ($triangles: System_Collections_Generic.List$1<ushort>, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * @methodSwap SetTriangles_EBB7509C_CFDA9960
        */
        public SetTriangles ($triangles: System_Collections_Generic.List$1<ushort>, $trianglesStart: int, $trianglesLength: int, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * Sets the index buffer for the sub-mesh.
        * @param indices The array of indices that define the mesh faces.
        * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
        * @param baseVertex Optional vertex offset that is added to all vertex indices.
        * @methodSwap SetIndices_EBB7509C_D70C445E
        */
        public SetIndices ($indices: int[], $topology: MeshTopology, $submesh: int) : void
        /**
        * Sets the index buffer for the sub-mesh.
        * @param indices The array of indices that define the mesh faces.
        * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
        * @param baseVertex Optional vertex offset that is added to all vertex indices.
        * @methodSwap SetIndices_EBB7509C_H688022FD
        */
        public SetIndices ($indices: int[], $topology: MeshTopology, $submesh: int, $calculateBounds: boolean) : void
        /**
        * Sets the index buffer for the sub-mesh.
        * @param indices The array of indices that define the mesh faces.
        * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
        * @param baseVertex Optional vertex offset that is added to all vertex indices.
        * @methodSwap SetIndices_EBB7509C_H35C92DFE
        */
        public SetIndices ($indices: int[], $topology: MeshTopology, $submesh: int, $calculateBounds: boolean, $baseVertex: int) : void
        /**
        * Sets the index buffer of a sub-mesh, using a part of the input array.
        * @param indices The array of indices that define the mesh faces.
        * @param indicesStart Index of the first element to take from the input array.
        * @param indicesLength Number of elements to take from the input array.
        * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
        * @param baseVertex Optional vertex offset that is added to all vertex indices.
        * @methodSwap SetIndices_EBB7509C_H273AD8DA
        */
        public SetIndices ($indices: int[], $indicesStart: int, $indicesLength: int, $topology: MeshTopology, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * Sets the index buffer for the sub-mesh.
        * @param indices The array of indices that define the mesh faces.
        * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
        * @param baseVertex Optional vertex offset that is added to all vertex indices.
        * @methodSwap SetIndices_EBB7509C_H43C58769
        */
        public SetIndices ($indices: ushort[], $topology: MeshTopology, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * Sets the index buffer of a sub-mesh, using a part of the input array.
        * @param indices The array of indices that define the mesh faces.
        * @param indicesStart Index of the first element to take from the input array.
        * @param indicesLength Number of elements to take from the input array.
        * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
        * @param submesh The sub-mesh to modify.
        * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
        * @param baseVertex Optional vertex offset that is added to all vertex indices.
        * @methodSwap SetIndices_EBB7509C_H8804385D
        */
        public SetIndices ($indices: ushort[], $indicesStart: int, $indicesLength: int, $topology: MeshTopology, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * @methodSwap SetIndices_EBB7509C_C9364B52
        */
        public SetIndices<T> ($indices: Unity_Collections.NativeArray$1<T>, $topology: MeshTopology, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * @methodSwap SetIndices_EBB7509C_A459EBAE
        */
        public SetIndices<T> ($indices: Unity_Collections.NativeArray$1<T>, $indicesStart: int, $indicesLength: int, $topology: MeshTopology, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * @methodSwap SetIndices_EBB7509C_CAB4E37E
        */
        public SetIndices ($indices: System_Collections_Generic.List$1<int>, $topology: MeshTopology, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * @methodSwap SetIndices_EBB7509C_H71EAF65A
        */
        public SetIndices ($indices: System_Collections_Generic.List$1<int>, $indicesStart: int, $indicesLength: int, $topology: MeshTopology, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * @methodSwap SetIndices_EBB7509C_H43AA7DEF
        */
        public SetIndices ($indices: System_Collections_Generic.List$1<ushort>, $topology: MeshTopology, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * @methodSwap SetIndices_EBB7509C_EFD2605B
        */
        public SetIndices ($indices: System_Collections_Generic.List$1<ushort>, $indicesStart: int, $indicesLength: int, $topology: MeshTopology, $submesh: int, $calculateBounds?: boolean, $baseVertex?: int) : void
        /**
        * Sets information defining all sub-meshes in this Mesh, replacing any existing sub-meshes.
        * @param desc An array or list of sub-mesh data descriptors.
        * @param start Index of the first element to take from the array or list in desc.
        * @param count Number of elements to take from the array or list in desc.
        * @param flags (Optional) Flags controlling the function behavior, see MeshUpdateFlags.
        * @methodSwap SetSubMeshes_EBB7509C_H25B53D46
        */
        public SetSubMeshes ($desc: UnityEngine_Rendering.SubMeshDescriptor[], $start: int, $count: int, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Sets information defining all sub-meshes in this Mesh, replacing any existing sub-meshes.
        * @param desc An array or list of sub-mesh data descriptors.
        * @param start Index of the first element to take from the array or list in desc.
        * @param count Number of elements to take from the array or list in desc.
        * @param flags (Optional) Flags controlling the function behavior, see MeshUpdateFlags.
        */
        public SetSubMeshes ($desc: UnityEngine_Rendering.SubMeshDescriptor[], $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * @methodSwap SetSubMeshes_EBB7509C_H1CF7F2A6
        */
        public SetSubMeshes ($desc: System_Collections_Generic.List$1<UnityEngine_Rendering.SubMeshDescriptor>, $start: int, $count: int, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        public SetSubMeshes ($desc: System_Collections_Generic.List$1<UnityEngine_Rendering.SubMeshDescriptor>, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * @methodSwap SetSubMeshes_EBB7509C_H463A3C8E
        */
        public SetSubMeshes<T> ($desc: Unity_Collections.NativeArray$1<T>, $start: int, $count: int, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        public SetSubMeshes<T> ($desc: Unity_Collections.NativeArray$1<T>, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
        public GetBindposes ($bindposes: System_Collections_Generic.List$1<Matrix4x4>) : void
        public GetBoneWeights ($boneWeights: System_Collections_Generic.List$1<BoneWeight>) : void
        /**
        * Clears all vertex data and all triangle indices.
        * @param keepVertexLayout True if the existing Mesh data layout should be preserved.
        */
        public Clear ($keepVertexLayout: boolean) : void
        public Clear () : void
        public RecalculateBounds () : void
        public RecalculateNormals () : void
        public RecalculateTangents () : void
        /**
        * Recalculate the bounding volume of the Mesh from the vertices.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        */
        public RecalculateBounds ($flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Recalculates the normals of the Mesh from the triangles and vertices.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        */
        public RecalculateNormals ($flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Recalculates the tangents of the Mesh from the normals and texture coordinates.
        * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
        */
        public RecalculateTangents ($flags: UnityEngine_Rendering.MeshUpdateFlags) : void
        /**
        * Recalculates the UV distribution metric of the Mesh from the vertices and uv coordinates.
        * @param uvSetIndex The UV set index to set the UV distibution metric for. Use 0 for first index.
        * @param uvAreaThreshold The minimum UV area to consider. The default value is 1e-9f.
        */
        public RecalculateUVDistributionMetric ($uvSetIndex: int, $uvAreaThreshold?: float) : void
        /**
        * Recalculates the UV distribution metrics of the Mesh from the vertices and uv coordinates.
        * @param uvAreaThreshold The minimum UV area to consider. The default value is 1e-9f.
        */
        public RecalculateUVDistributionMetrics ($uvAreaThreshold?: float) : void
        /**
        * Optimize mesh for frequent updates.
        */
        public MarkDynamic () : void
        /**
        * Upload previously done Mesh modifications to the graphics API.
        * @param markNoLongerReadable Frees up system memory copy of mesh data when set to true.
        */
        public UploadMeshData ($markNoLongerReadable: boolean) : void
        /**
        * Optimizes the Mesh data to improve rendering performance.
        */
        public Optimize () : void
        /**
        * Optimizes the geometry of the Mesh to improve rendering performance.
        */
        public OptimizeIndexBuffers () : void
        /**
        * Optimizes the vertices of the Mesh to improve rendering performance.
        */
        public OptimizeReorderVertexBuffer () : void
        /**
        * Gets the topology of a sub-mesh.
        */
        public GetTopology ($submesh: int) : MeshTopology
        /**
        * Combines several Meshes into this Mesh.
        * @param combine Descriptions of the Meshes to combine.
        * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
        * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
        * @param hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
        */
        public CombineMeshes ($combine: CombineInstance[], $mergeSubMeshes: boolean, $useMatrices: boolean, $hasLightmapData: boolean) : void
        /**
        * Combines several Meshes into this Mesh.
        * @param combine Descriptions of the Meshes to combine.
        * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
        * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
        * @param hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
        */
        public CombineMeshes ($combine: CombineInstance[], $mergeSubMeshes: boolean, $useMatrices: boolean) : void
        /**
        * Combines several Meshes into this Mesh.
        * @param combine Descriptions of the Meshes to combine.
        * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
        * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
        * @param hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
        */
        public CombineMeshes ($combine: CombineInstance[], $mergeSubMeshes: boolean) : void
        /**
        * Combines several Meshes into this Mesh.
        * @param combine Descriptions of the Meshes to combine.
        * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
        * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
        * @param hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
        */
        public CombineMeshes ($combine: CombineInstance[]) : void
    }

    /**
    * Describes a bone weight that affects a vertex in a mesh.
    */
    class BoneWeight1 extends System.ValueType implements System.IEquatable$1<BoneWeight1> {

        /**
        * Skinning weight for bone.
        */
        public get weight(): float;
        public set weight(value: float);
        /**
        * Index of bone.
        */
        public get boneIndex(): int;
        public set boneIndex(value: int);

        public Equals ($other: any) : boolean
        public Equals ($other: BoneWeight1) : boolean
        public GetHashCode () : int
        public static op_Equality ($lhs: BoneWeight1, $rhs: BoneWeight1) : boolean
        public static op_Inequality ($lhs: BoneWeight1, $rhs: BoneWeight1) : boolean
    }

    /**
    * Topology of Mesh faces.
    */
    enum MeshTopology {
        Triangles = 0,
        Quads = 2,
        Lines = 3,
        LineStrip = 4,
        Points = 5 
    }

    /**
    * Represents an axis aligned bounding box.
    */
    class Bounds extends System.ValueType implements System.IFormattable, System.IEquatable$1<Bounds> {

        /**
        * The center of the bounding box.
        */
        public get center(): Vector3;
        public set center(value: Vector3);
        /**
        * The total size of the box. This is always twice as large as the extents.
        */
        public get size(): Vector3;
        public set size(value: Vector3);
        /**
        * The extents of the Bounding Box. This is always half of the size of the Bounds.
        */
        public get extents(): Vector3;
        public set extents(value: Vector3);
        /**
        * The minimal point of the box. This is always equal to center-extents.
        */
        public get min(): Vector3;
        public set min(value: Vector3);
        /**
        * The maximal point of the box. This is always equal to center+extents.
        */
        public get max(): Vector3;
        public set max(value: Vector3);

        /**
        * Creates a new Bounds.
        * @param center The location of the origin of the Bounds.
        * @param size The dimensions of the Bounds.
        */
        public constructor ($center: Vector3, $size: Vector3)
        public GetHashCode () : int
        public Equals ($other: any) : boolean
        public Equals ($other: Bounds) : boolean
        /**
        * Sets the bounds to the min and max value of the box.
        */
        public SetMinMax ($min: Vector3, $max: Vector3) : void
        /**
        * Grows the Bounds to include the point.
        */
        public Encapsulate ($point: Vector3) : void
        /**
        * Grow the bounds to encapsulate the bounds.
        */
        public Encapsulate ($bounds: Bounds) : void
        /**
        * Expand the bounds by increasing its size by amount along each side.
        * @methodSwap Expand_EBB7509C_H82424F3E
        */
        public Expand ($amount: float) : void
        /**
        * Expand the bounds by increasing its size by amount along each side.
        */
        public Expand ($amount: Vector3) : void
        /**
        * Does another bounding box intersect with this bounding box?
        */
        public Intersects ($bounds: Bounds) : boolean
        /**
        * Does ray intersect this bounding box?
        */
        public IntersectRay ($ray: Ray) : boolean
        /**
        * Does ray intersect this bounding box?
        */
        public IntersectRay ($ray: Ray, $distance: $Ref<float>) : boolean
        /**
        * Returns a formatted string for the bounds.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for the bounds.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for the bounds.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        /**
        * Is point contained in the bounding box?
        */
        public Contains ($point: Vector3) : boolean
        /**
        * The smallest squared distance between the point and this bounding box.
        */
        public SqrDistance ($point: Vector3) : float
        /**
        * The closest point on the bounding box.
        * @param point Arbitrary point.
        * @returns The point on the bounding box or inside the bounding box.
        */
        public ClosestPoint ($point: Vector3) : Vector3
        public static op_Equality ($lhs: Bounds, $rhs: Bounds) : boolean
        public static op_Inequality ($lhs: Bounds, $rhs: Bounds) : boolean
    }

    /**
    * Representation of RGBA colors in 32 bit format.
    */
    class Color32 extends System.ValueType implements System.IFormattable {

        /**
        * Red component of the color.
        */
        public r : byte
        /**
        * Green component of the color.
        */
        public g : byte
        /**
        * Blue component of the color.
        */
        public b : byte
        /**
        * Alpha component of the color.
        */
        public a : byte

        /**
        * Constructs a new Color32 with given r, g, b, a components.
        */
        public constructor ($r: byte, $g: byte, $b: byte, $a: byte)
        /**
        * Linearly interpolates between colors a and b by t.
        */
        public static Lerp ($a: Color32, $b: Color32, $t: float) : Color32
        /**
        * Linearly interpolates between colors a and b by t.
        */
        public static LerpUnclamped ($a: Color32, $b: Color32, $t: float) : Color32
        /**
        * Returns a formatted string for this color.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this color.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this color.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        public get_Item ($index: int) : byte
        public set_Item ($index: int, $value: byte) : void
        public static op_Implicit ($c: Color) : Color32
        public static op_Implicit ($c: Color32) : Color
    }

    /**
    * Skin weights.
    */
    enum SkinWeights {
        None = 0,
        OneBone = 1,
        TwoBones = 2,
        FourBones = 4,
        Unlimited = 255 
    }

    /**
    * Describes the location of blend shape vertex data in a GraphicsBuffer.
    */
    class BlendShapeBufferRange extends System.ValueType {

        /**
        * The index of the first blend shape vertex for the requested blend shape.
        */
        public get startIndex(): uint;
        /**
        * The index of the last blend shape vertex for the requested blend shape.
        */
        public get endIndex(): uint;

    }

    /**
    * Describes 4 skinning bone weights that affect a vertex in a mesh.
    */
    class BoneWeight extends System.ValueType implements System.IEquatable$1<BoneWeight> {

        /**
        * Skinning weight for first bone.
        */
        public get weight0(): float;
        public set weight0(value: float);
        /**
        * Skinning weight for second bone.
        */
        public get weight1(): float;
        public set weight1(value: float);
        /**
        * Skinning weight for third bone.
        */
        public get weight2(): float;
        public set weight2(value: float);
        /**
        * Skinning weight for fourth bone.
        */
        public get weight3(): float;
        public set weight3(value: float);
        /**
        * Index of first bone.
        */
        public get boneIndex0(): int;
        public set boneIndex0(value: int);
        /**
        * Index of second bone.
        */
        public get boneIndex1(): int;
        public set boneIndex1(value: int);
        /**
        * Index of third bone.
        */
        public get boneIndex2(): int;
        public set boneIndex2(value: int);
        /**
        * Index of fourth bone.
        */
        public get boneIndex3(): int;
        public set boneIndex3(value: int);

        public GetHashCode () : int
        public Equals ($other: any) : boolean
        public Equals ($other: BoneWeight) : boolean
        public static op_Equality ($lhs: BoneWeight, $rhs: BoneWeight) : boolean
        public static op_Inequality ($lhs: BoneWeight, $rhs: BoneWeight) : boolean
    }

    /**
    * Struct used to describe meshes to be combined using Mesh.CombineMeshes.
    */
    class CombineInstance extends System.ValueType {

        /**
        * Mesh to combine.
        */
        public get mesh(): Mesh;
        public set mesh(value: Mesh);
        /**
        * Sub-Mesh index of the Mesh.
        */
        public get subMeshIndex(): int;
        public set subMeshIndex(value: int);
        /**
        * Matrix to transform the Mesh with before combining. Refer to Mesh.CombineMeshes for an example.
        */
        public get transform(): Matrix4x4;
        public set transform(value: Matrix4x4);
        /**
        * The baked lightmap UV scale and offset applied to the Mesh.
        */
        public get lightmapScaleOffset(): Vector4;
        public set lightmapScaleOffset(value: Vector4);
        /**
        * The real-time lightmap UV scale and offset applied to the Mesh.
        */
        public get realtimeLightmapScaleOffset(): Vector4;
        public set realtimeLightmapScaleOffset(value: Vector4);

    }

    /**
    * A block of material values to apply.
    */
    class MaterialPropertyBlock extends System.Object {

        /**
        * Is the material property block empty? (Read Only)
        */
        public get isEmpty(): boolean;

        public constructor ()
        /**
        * Clear material property values.
        */
        public Clear () : void
        /**
        * This method is deprecated. Use SetFloat or SetInteger instead.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The int value to set.
        * @methodSwap SetInt_EBB7509C_H72D17FE0
        */
        public SetInt ($name: string, $value: int) : void
        /**
        * This method is deprecated. Use SetFloat or SetInteger instead.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The int value to set.
        * @methodSwap SetInt_EBB7509C_H2CFB2EE5
        */
        public SetInt ($nameID: int, $value: int) : void
        /**
        * Set a float property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The float value to set.
        * @methodSwap SetFloat_EBB7509C_H45FF9778
        */
        public SetFloat ($name: string, $value: float) : void
        /**
        * Set a float property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The float value to set.
        * @methodSwap SetFloat_EBB7509C_A137D5B3
        */
        public SetFloat ($nameID: int, $value: float) : void
        /**
        * Adds a property to the block. If an integer property with the given name already exists, the old value is replaced.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The integer value to set.
        * @methodSwap SetInteger_EBB7509C_H72D17FE0
        */
        public SetInteger ($name: string, $value: int) : void
        /**
        * Adds a property to the block. If an integer property with the given name already exists, the old value is replaced.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The integer value to set.
        * @methodSwap SetInteger_EBB7509C_H2CFB2EE5
        */
        public SetInteger ($nameID: int, $value: int) : void
        /**
        * Set a vector property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The Vector4 value to set.
        */
        public SetVector ($name: string, $value: Vector4) : void
        /**
        * Set a vector property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The Vector4 value to set.
        * @methodSwap SetVector_EBB7509C_H9F0E6FE
        */
        public SetVector ($nameID: int, $value: Vector4) : void
        /**
        * Set a color property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The Color value to set.
        */
        public SetColor ($name: string, $value: Color) : void
        /**
        * Set a color property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The Color value to set.
        * @methodSwap SetColor_EBB7509C_H9F453824
        */
        public SetColor ($nameID: int, $value: Color) : void
        /**
        * Set a matrix property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The matrix value to set.
        */
        public SetMatrix ($name: string, $value: Matrix4x4) : void
        /**
        * Set a matrix property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The matrix value to set.
        * @methodSwap SetMatrix_EBB7509C_A704EAE0
        */
        public SetMatrix ($nameID: int, $value: Matrix4x4) : void
        /**
        * Set a buffer property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The ComputeBuffer or GraphicsBuffer to set.
        */
        public SetBuffer ($name: string, $value: ComputeBuffer) : void
        /**
        * Set a buffer property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The ComputeBuffer or GraphicsBuffer to set.
        * @methodSwap SetBuffer_EBB7509C_E83D65D0
        */
        public SetBuffer ($nameID: int, $value: ComputeBuffer) : void
        /**
        * Set a buffer property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The ComputeBuffer or GraphicsBuffer to set.
        */
        public SetBuffer ($name: string, $value: GraphicsBuffer) : void
        /**
        * Set a buffer property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The ComputeBuffer or GraphicsBuffer to set.
        * @methodSwap SetBuffer_EBB7509C_EA6F5EB6
        */
        public SetBuffer ($nameID: int, $value: GraphicsBuffer) : void
        /**
        * Set a texture property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The Texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        */
        public SetTexture ($name: string, $value: Texture) : void
        /**
        * Set a texture property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The Texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetTexture_EBB7509C_BEB5CD50
        */
        public SetTexture ($nameID: int, $value: Texture) : void
        /**
        * Set a texture property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The Texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        */
        public SetTexture ($name: string, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement) : void
        /**
        * Set a texture property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param value The Texture to set.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetTexture_EBB7509C_H63044826
        */
        public SetTexture ($nameID: int, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
        * @param name The name of the constant buffer to override.
        * @param value The buffer to override the constant buffer values with.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @param nameID The shader property ID of the constant buffer to override.
        * @methodSwap SetConstantBuffer_EBB7509C_H1515F92F
        */
        public SetConstantBuffer ($name: string, $value: ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
        * @param name The name of the constant buffer to override.
        * @param value The buffer to override the constant buffer values with.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @param nameID The shader property ID of the constant buffer to override.
        * @methodSwap SetConstantBuffer_EBB7509C_H2CE47D04
        */
        public SetConstantBuffer ($nameID: int, $value: ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
        * @param name The name of the constant buffer to override.
        * @param value The buffer to override the constant buffer values with.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @param nameID The shader property ID of the constant buffer to override.
        * @methodSwap SetConstantBuffer_EBB7509C_H369B14DB
        */
        public SetConstantBuffer ($name: string, $value: GraphicsBuffer, $offset: int, $size: int) : void
        /**
        * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
        * @param name The name of the constant buffer to override.
        * @param value The buffer to override the constant buffer values with.
        * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @param nameID The shader property ID of the constant buffer to override.
        * @methodSwap SetConstantBuffer_EBB7509C_H30D518B2
        */
        public SetConstantBuffer ($nameID: int, $value: GraphicsBuffer, $offset: int, $size: int) : void
        public SetFloatArray ($name: string, $values: System_Collections_Generic.List$1<float>) : void
        /**
        * @methodSwap SetFloatArray_EBB7509C_E8859065
        */
        public SetFloatArray ($nameID: int, $values: System_Collections_Generic.List$1<float>) : void
        /**
        * Set a float array property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param values The array to set.
        */
        public SetFloatArray ($name: string, $values: float[]) : void
        /**
        * Set a float array property.
        * @param name The name of the property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param values The array to set.
        * @methodSwap SetFloatArray_EBB7509C_H4A792FF
        */
        public SetFloatArray ($nameID: int, $values: float[]) : void
        public SetVectorArray ($name: string, $values: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * @methodSwap SetVectorArray_EBB7509C_H5C64F93A
        */
        public SetVectorArray ($nameID: int, $values: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * Set a vector array property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param values The array to set.
        * @param name The name of the property.
        */
        public SetVectorArray ($name: string, $values: Vector4[]) : void
        /**
        * Set a vector array property.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param values The array to set.
        * @param name The name of the property.
        * @methodSwap SetVectorArray_EBB7509C_H500372C6
        */
        public SetVectorArray ($nameID: int, $values: Vector4[]) : void
        public SetMatrixArray ($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * @methodSwap SetMatrixArray_EBB7509C_H73E77D48
        */
        public SetMatrixArray ($nameID: int, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * Set a matrix array property.
        * @param name The name of the property.
        * @param values The name ID of the property retrieved by Shader.PropertyToID.
        * @param nameID The array to set.
        */
        public SetMatrixArray ($name: string, $values: Matrix4x4[]) : void
        /**
        * Set a matrix array property.
        * @param name The name of the property.
        * @param values The name ID of the property retrieved by Shader.PropertyToID.
        * @param nameID The array to set.
        * @methodSwap SetMatrixArray_EBB7509C_H4B572A74
        */
        public SetMatrixArray ($nameID: int, $values: Matrix4x4[]) : void
        /**
        * Checks if MaterialPropertyBlock has the property with the given name or name ID. To set the property, use one of the Set methods for MaterialPropertyBlock.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        */
        public HasProperty ($name: string) : boolean
        /**
        * Checks if MaterialPropertyBlock has the property with the given name or name ID. To set the property, use one of the Set methods for MaterialPropertyBlock.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        * @methodSwap HasProperty_EBB7509C_F92D023A
        */
        public HasProperty ($nameID: int) : boolean
        /**
        * This method is deprecated. Use HasFloat or HasInteger instead.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        */
        public HasInt ($name: string) : boolean
        /**
        * This method is deprecated. Use HasFloat or HasInteger instead.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        * @methodSwap HasInt_EBB7509C_F92D023A
        */
        public HasInt ($nameID: int) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Float property with the given name or name ID. To set the property, use SetFloat.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        */
        public HasFloat ($name: string) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Float property with the given name or name ID. To set the property, use SetFloat.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        * @methodSwap HasFloat_EBB7509C_F92D023A
        */
        public HasFloat ($nameID: int) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Integer property with the given name or name ID. To set the property, use SetInteger.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        */
        public HasInteger ($name: string) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Integer property with the given name or name ID. To set the property, use SetInteger.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        * @methodSwap HasInteger_EBB7509C_F92D023A
        */
        public HasInteger ($nameID: int) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Texture property with the given name or name ID. To set the property, use SetTexture.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        */
        public HasTexture ($name: string) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Texture property with the given name or name ID. To set the property, use SetTexture.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        * @methodSwap HasTexture_EBB7509C_F92D023A
        */
        public HasTexture ($nameID: int) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Matrix property with the given name or name ID. This also works with the Matrix Array property. To set the property, use SetMatrix.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        */
        public HasMatrix ($name: string) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Matrix property with the given name or name ID. This also works with the Matrix Array property. To set the property, use SetMatrix.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        * @methodSwap HasMatrix_EBB7509C_F92D023A
        */
        public HasMatrix ($nameID: int) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Vector property with the given name or name ID. This also works with the Vector Array property. To set the property, use SetVector.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        */
        public HasVector ($name: string) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Vector property with the given name or name ID. This also works with the Vector Array property. To set the property, use SetVector.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        * @methodSwap HasVector_EBB7509C_F92D023A
        */
        public HasVector ($nameID: int) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Color property with the given name or name ID. To set the property, use SetColor.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        */
        public HasColor ($name: string) : boolean
        /**
        * Checks if MaterialPropertyBlock has the Color property with the given name or name ID. To set the property, use SetColor.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        * @methodSwap HasColor_EBB7509C_F92D023A
        */
        public HasColor ($nameID: int) : boolean
        /**
        * Checks if MaterialPropertyBlock has the ComputeBuffer property with the given name or name ID. To set the property, use SetBuffer.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if MaterialPropertyBlock has this property.
        */
        public HasBuffer ($name: string) : boolean
        /**
        * Checks if MaterialPropertyBlock has the ComputeBuffer property with the given name or name ID. To set the property, use SetBuffer.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @param name The name of the property.
        * @returns Returns true if MaterialPropertyBlock has this property.
        * @methodSwap HasBuffer_EBB7509C_F92D023A
        */
        public HasBuffer ($nameID: int) : boolean
        /**
        * Checks if MaterialPropertyBlock has the ConstantBuffer property with the given name or name ID. To set the property, use SetConstantBuffer.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        */
        public HasConstantBuffer ($name: string) : boolean
        /**
        * Checks if MaterialPropertyBlock has the ConstantBuffer property with the given name or name ID. To set the property, use SetConstantBuffer.
        * @param name The name of the property.
        * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
        * @returns Returns true if MaterialPropertyBlock has this property.
        * @methodSwap HasConstantBuffer_EBB7509C_F92D023A
        */
        public HasConstantBuffer ($nameID: int) : boolean
        /**
        * Get a float from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetFloat ($name: string) : float
        /**
        * Get a float from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetFloat_EBB7509C_F92D023A
        */
        public GetFloat ($nameID: int) : float
        /**
        * This method is deprecated. Use GetFloat or GetInteger instead.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetInt ($name: string) : int
        /**
        * This method is deprecated. Use GetFloat or GetInteger instead.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetInt_EBB7509C_F92D023A
        */
        public GetInt ($nameID: int) : int
        /**
        * Get an integer from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetInteger ($name: string) : int
        /**
        * Get an integer from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetInteger_EBB7509C_F92D023A
        */
        public GetInteger ($nameID: int) : int
        /**
        * Get a vector from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetVector ($name: string) : Vector4
        /**
        * Get a vector from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetVector_EBB7509C_F92D023A
        */
        public GetVector ($nameID: int) : Vector4
        /**
        * Get a color from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetColor ($name: string) : Color
        /**
        * Get a color from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetColor_EBB7509C_F92D023A
        */
        public GetColor ($nameID: int) : Color
        /**
        * Get a matrix from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetMatrix ($name: string) : Matrix4x4
        /**
        * Get a matrix from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetMatrix_EBB7509C_F92D023A
        */
        public GetMatrix ($nameID: int) : Matrix4x4
        /**
        * Get a texture from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetTexture ($name: string) : Texture
        /**
        * Get a texture from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetTexture_EBB7509C_F92D023A
        */
        public GetTexture ($nameID: int) : Texture
        /**
        * Get a float array from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetFloatArray ($name: string) : float[]
        /**
        * Get a float array from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetFloatArray_EBB7509C_F92D023A
        */
        public GetFloatArray ($nameID: int) : float[]
        /**
        * Get a vector array from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetVectorArray ($name: string) : Vector4[]
        /**
        * Get a vector array from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetVectorArray_EBB7509C_F92D023A
        */
        public GetVectorArray ($nameID: int) : Vector4[]
        /**
        * Get a matrix array from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        */
        public GetMatrixArray ($name: string) : Matrix4x4[]
        /**
        * Get a matrix array from the property block.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @methodSwap GetMatrixArray_EBB7509C_F92D023A
        */
        public GetMatrixArray ($nameID: int) : Matrix4x4[]
        public GetFloatArray ($name: string, $values: System_Collections_Generic.List$1<float>) : void
        /**
        * @methodSwap GetFloatArray_EBB7509C_E8859065
        */
        public GetFloatArray ($nameID: int, $values: System_Collections_Generic.List$1<float>) : void
        public GetVectorArray ($name: string, $values: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * @methodSwap GetVectorArray_EBB7509C_H5C64F93A
        */
        public GetVectorArray ($nameID: int, $values: System_Collections_Generic.List$1<Vector4>) : void
        public GetMatrixArray ($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * @methodSwap GetMatrixArray_EBB7509C_H73E77D48
        */
        public GetMatrixArray ($nameID: int, $values: System_Collections_Generic.List$1<Matrix4x4>) : void
        public CopySHCoefficientArraysFrom ($lightProbes: System_Collections_Generic.List$1<UnityEngine_Rendering.SphericalHarmonicsL2>) : void
        /**
        * This function converts and copies the entire source array into 7 Vector4 property arrays named unity_SHAr, unity_SHAg, unity_SHAb, unity_SHBr, unity_SHBg, unity_SHBb and unity_SHC for use with instanced rendering.
        * @param lightProbes The array of SH values to copy from.
        */
        public CopySHCoefficientArraysFrom ($lightProbes: UnityEngine_Rendering.SphericalHarmonicsL2[]) : void
        /**
        * @methodSwap CopySHCoefficientArraysFrom_EBB7509C_C23C91BE
        */
        public CopySHCoefficientArraysFrom ($lightProbes: System_Collections_Generic.List$1<UnityEngine_Rendering.SphericalHarmonicsL2>, $sourceStart: int, $destStart: int, $count: int) : void
        /**
        * This function converts and copies the source array into 7 Vector4 property arrays named unity_SHAr, unity_SHAg, unity_SHAb, unity_SHBr, unity_SHBg, unity_SHBb and unity_SHC with the specified source and destination range for use with instanced rendering.
        * @param lightProbes The array of SH values to copy from.
        * @param sourceStart The index of the first element in the source array to copy from.
        * @param destStart The index of the first element in the destination MaterialPropertyBlock array to copy to.
        * @param count The number of elements to copy.
        * @methodSwap CopySHCoefficientArraysFrom_EBB7509C_H92811350
        */
        public CopySHCoefficientArraysFrom ($lightProbes: UnityEngine_Rendering.SphericalHarmonicsL2[], $sourceStart: int, $destStart: int, $count: int) : void
        public CopyProbeOcclusionArrayFrom ($occlusionProbes: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * This function copies the entire source array into a Vector4 property array named unity_ProbesOcclusion for use with instanced rendering.
        * @param occlusionProbes The array of probe occlusion values to copy from.
        */
        public CopyProbeOcclusionArrayFrom ($occlusionProbes: Vector4[]) : void
        /**
        * @methodSwap CopyProbeOcclusionArrayFrom_EBB7509C_H66C55B26
        */
        public CopyProbeOcclusionArrayFrom ($occlusionProbes: System_Collections_Generic.List$1<Vector4>, $sourceStart: int, $destStart: int, $count: int) : void
        /**
        * This function copies the source array into a Vector4 property array named unity_ProbesOcclusion with the specified source and destination range for use with instanced rendering.
        * @param occlusionProbes The array of probe occlusion values to copy from.
        * @param sourceStart The index of the first element in the source array to copy from.
        * @param destStart The index of the first element in the destination MaterialPropertyBlock array to copy to.
        * @param count The number of elements to copy.
        * @methodSwap CopyProbeOcclusionArrayFrom_EBB7509C_H8764A9C8
        */
        public CopyProbeOcclusionArrayFrom ($occlusionProbes: Vector4[], $sourceStart: int, $destStart: int, $count: int) : void
    }

    /**
    * General functionality for all renderers.
    */
    class Renderer extends Component {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * The bounding box of the renderer in world space.
        */
        public get bounds(): Bounds;
        public set bounds(value: Bounds);
        /**
        * The bounding box of the renderer in local space.
        */
        public get localBounds(): Bounds;
        public set localBounds(value: Bounds);
        /**
        * Makes the rendered 3D object visible if enabled.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Is this renderer visible in any camera? (Read Only)
        */
        public get isVisible(): boolean;
        /**
        * Does this object cast shadows?
        */
        public get shadowCastingMode(): UnityEngine_Rendering.ShadowCastingMode;
        public set shadowCastingMode(value: UnityEngine_Rendering.ShadowCastingMode);
        /**
        * Does this object receive shadows?
        */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
        * Allows turning off rendering for a specific component.
        */
        public get forceRenderingOff(): boolean;
        public set forceRenderingOff(value: boolean);
        /**
        * Is this renderer a static shadow caster?
        */
        public get staticShadowCaster(): boolean;
        public set staticShadowCaster(value: boolean);
        /**
        * Specifies the mode for motion vector rendering.
        */
        public get motionVectorGenerationMode(): MotionVectorGenerationMode;
        public set motionVectorGenerationMode(value: MotionVectorGenerationMode);
        /**
        * The light probe interpolation type.
        */
        public get lightProbeUsage(): UnityEngine_Rendering.LightProbeUsage;
        public set lightProbeUsage(value: UnityEngine_Rendering.LightProbeUsage);
        /**
        * Should reflection probes be used for this Renderer?
        */
        public get reflectionProbeUsage(): UnityEngine_Rendering.ReflectionProbeUsage;
        public set reflectionProbeUsage(value: UnityEngine_Rendering.ReflectionProbeUsage);
        /**
        * Determines which rendering layer this renderer lives on, if you use a.
        */
        public get renderingLayerMask(): uint;
        public set renderingLayerMask(value: uint);
        /**
        * This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
        */
        public get rendererPriority(): int;
        public set rendererPriority(value: int);
        /**
        * Describes how this renderer is updated for ray tracing.
        */
        public get rayTracingMode(): UnityEngine_Experimental_Rendering.RayTracingMode;
        public set rayTracingMode(value: UnityEngine_Experimental_Rendering.RayTracingMode);
        /**
        * Name of the Renderer's sorting layer.
        */
        public get sortingLayerName(): string;
        public set sortingLayerName(value: string);
        /**
        * Unique ID of the Renderer's sorting layer.
        */
        public get sortingLayerID(): int;
        public set sortingLayerID(value: int);
        /**
        * Renderer's order within a sorting layer.
        */
        public get sortingOrder(): int;
        public set sortingOrder(value: int);
        /**
        * Controls if dynamic occlusion culling should be performed for this renderer.
        */
        public get allowOcclusionWhenDynamic(): boolean;
        public set allowOcclusionWhenDynamic(value: boolean);
        /**
        * Indicates whether the renderer is part of a with other renderers.
        */
        public get isPartOfStaticBatch(): boolean;
        /**
        * Matrix that transforms a point from world space into local space (Read Only).
        */
        public get worldToLocalMatrix(): Matrix4x4;
        /**
        * Matrix that transforms a point from local space into world space (Read Only).
        */
        public get localToWorldMatrix(): Matrix4x4;
        /**
        * If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
        */
        public get lightProbeProxyVolumeOverride(): GameObject;
        public set lightProbeProxyVolumeOverride(value: GameObject);
        /**
        * If set, Renderer will use this Transform's position to find the light or reflection probe.
        */
        public get probeAnchor(): Transform;
        public set probeAnchor(value: Transform);
        /**
        * The index of the baked lightmap applied to this renderer.
        */
        public get lightmapIndex(): int;
        public set lightmapIndex(value: int);
        /**
        * The index of the real-time lightmap applied to this renderer.
        */
        public get realtimeLightmapIndex(): int;
        public set realtimeLightmapIndex(value: int);
        /**
        * The UV scale & offset used for a lightmap.
        */
        public get lightmapScaleOffset(): Vector4;
        public set lightmapScaleOffset(value: Vector4);
        /**
        * The UV scale & offset used for a real-time lightmap.
        */
        public get realtimeLightmapScaleOffset(): Vector4;
        public set realtimeLightmapScaleOffset(value: Vector4);
        /**
        * Returns all the instantiated materials of this object.
        */
        public get materials(): Material[];
        public set materials(value: Material[]);
        /**
        * Returns the first instantiated Material assigned to the renderer.
        */
        public get material(): Material;
        public set material(value: Material);
        /**
        * The shared material of this object.
        */
        public get sharedMaterial(): Material;
        public set sharedMaterial(value: Material);
        /**
        * All the shared materials of this object.
        */
        public get sharedMaterials(): Material[];
        public set sharedMaterials(value: Material[]);

        private constructor ()
        /**
        * Reset custom world space bounds.
        */
        public ResetBounds () : void
        /**
        * Reset custom local space bounds.
        */
        public ResetLocalBounds () : void
        /**
        * Returns true if the Renderer has a material property block attached via SetPropertyBlock.
        */
        public HasPropertyBlock () : boolean
        /**
        * Lets you set or clear per-renderer or per-material parameter overrides.
        * @param properties Property block with values you want to override.
        * @param materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
        */
        public SetPropertyBlock ($properties: MaterialPropertyBlock) : void
        /**
        * Lets you set or clear per-renderer or per-material parameter overrides.
        * @param properties Property block with values you want to override.
        * @param materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
        * @methodSwap SetPropertyBlock_EBB7509C_AEE3EC3C
        */
        public SetPropertyBlock ($properties: MaterialPropertyBlock, $materialIndex: int) : void
        /**
        * Get per-Renderer or per-Material property block.
        * @param properties Material parameters to retrieve.
        * @param materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
        */
        public GetPropertyBlock ($properties: MaterialPropertyBlock) : void
        /**
        * Get per-Renderer or per-Material property block.
        * @param properties Material parameters to retrieve.
        * @param materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
        * @methodSwap GetPropertyBlock_EBB7509C_AEE3EC3C
        */
        public GetPropertyBlock ($properties: MaterialPropertyBlock, $materialIndex: int) : void
        public GetMaterials ($m: System_Collections_Generic.List$1<Material>) : void
        public SetSharedMaterials ($materials: System_Collections_Generic.List$1<Material>) : void
        public SetMaterials ($materials: System_Collections_Generic.List$1<Material>) : void
        public GetSharedMaterials ($m: System_Collections_Generic.List$1<Material>) : void
        public GetClosestReflectionProbes ($result: System_Collections_Generic.List$1<UnityEngine_Rendering.ReflectionProbeBlendInfo>) : void
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * The reflection probe is used to capture the surroundings into a texture which is passed to the shaders and used for reflections.
    */
    class ReflectionProbe extends Behaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;
        /**
        * The size of the probe's bounding box in which the probe can contribute to reflections. The size is in world space.
        */
        public get size(): Vector3;
        public set size(value: Vector3);
        /**
        * The center of the probe's bounding box in which the probe can contribute to reflections. The center is relative to the position of the probe.
        */
        public get center(): Vector3;
        public set center(value: Vector3);
        /**
        * The near clipping plane distance when rendering the probe.
        */
        public get nearClipPlane(): float;
        public set nearClipPlane(value: float);
        /**
        * The far clipping plane distance when rendering the probe.
        */
        public get farClipPlane(): float;
        public set farClipPlane(value: float);
        /**
        * The intensity modifier that is applied to the texture of reflection probe in the shader.
        */
        public get intensity(): float;
        public set intensity(value: float);
        /**
        * The probe's world space axis-aligned bounding box in which the probe can contribute to reflections (Read Only).
        */
        public get bounds(): Bounds;
        /**
        * Should this reflection probe use HDR rendering?
        */
        public get hdr(): boolean;
        public set hdr(value: boolean);
        /**
        * Specifies whether Unity should render non-static GameObjects into the Reflection Probe. If you set this to true, Unity renders non-static GameObjects into the Reflection Probe. If you set this to false, Unity does not render non-static GameObjects into the Reflection Probe. Unity only takes this property into account if the Reflection Probe's Type is Custom.
        */
        public get renderDynamicObjects(): boolean;
        public set renderDynamicObjects(value: boolean);
        /**
        * Shadow drawing distance when rendering the probe.
        */
        public get shadowDistance(): float;
        public set shadowDistance(value: float);
        /**
        * Resolution of the underlying reflection texture in pixels.
        */
        public get resolution(): int;
        public set resolution(value: int);
        /**
        * This is used to render parts of the reflecion probe's surrounding selectively.
        */
        public get cullingMask(): int;
        public set cullingMask(value: int);
        /**
        * How the reflection probe clears the background.
        */
        public get clearFlags(): UnityEngine_Rendering.ReflectionProbeClearFlags;
        public set clearFlags(value: UnityEngine_Rendering.ReflectionProbeClearFlags);
        /**
        * The color with which the texture of reflection probe will be cleared.
        */
        public get backgroundColor(): Color;
        public set backgroundColor(value: Color);
        /**
        * Distance around probe used for blending (used in deferred probes).
        */
        public get blendDistance(): float;
        public set blendDistance(value: float);
        /**
        * Should this reflection probe use box projection?
        */
        public get boxProjection(): boolean;
        public set boxProjection(value: boolean);
        /**
        * Should reflection probe texture be generated in the Editor (ReflectionProbeMode.Baked) or should probe use custom specified texure (ReflectionProbeMode.Custom)?
        */
        public get mode(): UnityEngine_Rendering.ReflectionProbeMode;
        public set mode(value: UnityEngine_Rendering.ReflectionProbeMode);
        /**
        * Reflection probe importance.
        */
        public get importance(): int;
        public set importance(value: int);
        /**
        * Sets the way the probe will refresh.
        * Additional resources: ReflectionProbeRefreshMode.
        */
        public get refreshMode(): UnityEngine_Rendering.ReflectionProbeRefreshMode;
        public set refreshMode(value: UnityEngine_Rendering.ReflectionProbeRefreshMode);
        /**
        * Sets this probe time-slicing mode
        * Additional resources: ReflectionProbeTimeSlicingMode.
        */
        public get timeSlicingMode(): UnityEngine_Rendering.ReflectionProbeTimeSlicingMode;
        public set timeSlicingMode(value: UnityEngine_Rendering.ReflectionProbeTimeSlicingMode);
        /**
        * Reference to the baked texture of the reflection probe's surrounding.
        */
        public get bakedTexture(): Texture;
        public set bakedTexture(value: Texture);
        /**
        * Reference to the baked texture of the reflection probe's surrounding. Use this to assign custom reflection texture.
        */
        public get customBakedTexture(): Texture;
        public set customBakedTexture(value: Texture);
        /**
        * Reference to the real-time texture of the reflection probe's surroundings. Use this to assign a RenderTexture to use for real-time reflection.
        */
        public get realtimeTexture(): RenderTexture;
        public set realtimeTexture(value: RenderTexture);
        /**
        * Texture which is passed to the shader of the objects in the vicinity of the reflection probe (Read Only).
        */
        public get texture(): Texture;
        /**
        * HDR decode values of the reflection probe texture.
        */
        public get textureHDRDecodeValues(): Vector4;
        public static get minBakedCubemapResolution(): int;
        public static get maxBakedCubemapResolution(): int;
        /**
        * HDR decode values of the default reflection probe texture.
        */
        public static get defaultTextureHDRDecodeValues(): Vector4;
        /**
        * The surface texture of the default reflection probe that captures the environment contribution. Read only.
        */
        public static get defaultTexture(): Texture;

        private constructor ()
        /**
        * Revert all ReflectionProbe parameters to default.
        */
        public Reset () : void
        public RenderProbe () : int
        /**
        * Refreshes the probe's cubemap.
        * @param targetTexture Target RenderTexture in which rendering should be done. Specifying null will update the probe's default texture.
        * @returns 
        An integer representing a RenderID which can subsequently be used to check if the probe has finished rendering while rendering in time-slice mode.

        Additional resources: IsFinishedRendering
        Additional resources: timeSlicingMode
        
        */
        public RenderProbe ($targetTexture: RenderTexture) : int
        /**
        * Checks if a probe has finished a time-sliced render.
        * @param renderId An integer representing the RenderID as returned by the RenderProbe method.
        * @returns 
        True if the render has finished, false otherwise.

        Additional resources: timeSlicingMode
        
        */
        public IsFinishedRendering ($renderId: int) : boolean
        /**
        * Utility method to blend 2 cubemaps into a target render texture.
        * @param src Cubemap to blend from.
        * @param dst Cubemap to blend to.
        * @param blend Blend weight.
        * @param target RenderTexture which will hold the result of the blend.
        * @returns Returns trues if cubemaps were blended, false otherwise.
        */
        public static BlendCubemap ($src: Texture, $dst: Texture, $blend: float, $target: RenderTexture) : boolean
        /**
        * Updates the culling system with the ReflectionProbe's current state. This ensures that Unity correctly culls the ReflectionProbe during rendering if you implement your own runtime reflection system.
        */
        public static UpdateCachedState () : void
        public static add_reflectionProbeChanged ($value: System.Action$2<ReflectionProbe, UnityEngine_ReflectionProbe.ReflectionProbeEvent>) : void
        public static add_defaultReflectionTexture ($value: System.Action$1<Texture>) : void
        public static remove_reflectionProbeChanged ($value: System.Action$2<ReflectionProbe, UnityEngine_ReflectionProbe.ReflectionProbeEvent>) : void
        public static remove_defaultReflectionTexture ($value: System.Action$1<Texture>) : void
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * The type of motion vectors that should be generated.
    */
    enum MotionVectorGenerationMode {
        Camera = 0,
        Object = 1,
        ForceNoMotion = 2 
    }

    /**
    * A 2D Rectangle defined by x, y, width, height with integers.
    */
    class RectInt extends System.ValueType implements System.IFormattable, System.IEquatable$1<RectInt> {

        /**
        * Left coordinate of the rectangle.
        */
        public get x(): int;
        public set x(value: int);
        /**
        * Top coordinate of the rectangle.
        */
        public get y(): int;
        public set y(value: int);
        /**
        * Center coordinate of the rectangle.
        */
        public get center(): Vector2;
        /**
        * The lower left corner of the rectangle; which is the minimal position of the rectangle along the x- and y-axes, when it is aligned to both axes.
        */
        public get min(): Vector2Int;
        public set min(value: Vector2Int);
        /**
        * The upper right corner of the rectangle; which is the maximal position of the rectangle along the x- and y-axes, when it is aligned to both axes.
        */
        public get max(): Vector2Int;
        public set max(value: Vector2Int);
        /**
        * Width of the rectangle.
        */
        public get width(): int;
        public set width(value: int);
        /**
        * Height of the rectangle.
        */
        public get height(): int;
        public set height(value: int);
        /**
        * Shows the minimum X value of the RectInt.
        */
        public get xMin(): int;
        public set xMin(value: int);
        /**
        * Show the minimum Y value of the RectInt.
        */
        public get yMin(): int;
        public set yMin(value: int);
        /**
        * Shows the maximum X value of the RectInt.
        */
        public get xMax(): int;
        public set xMax(value: int);
        /**
        * Shows the maximum Y value of the RectInt.
        */
        public get yMax(): int;
        public set yMax(value: int);
        /**
        * Returns the position (x, y) of the RectInt.
        */
        public get position(): Vector2Int;
        public set position(value: Vector2Int);
        /**
        * Returns the width and height of the RectInt.
        */
        public get size(): Vector2Int;
        public set size(value: Vector2Int);
        /**
        * A RectInt.PositionCollection that contains all positions within the RectInt.
        */
        public get allPositionsWithin(): UnityEngine_RectInt.PositionEnumerator;

        /**
        * Creates a new RectInt.
        * @param xMin The minimum X value of the RectInt.
        * @param yMin The minimum Y value of the RectInt.
        * @param width Width of the rectangle.
        * @param height Height of the rectangle.
        * @param position The position (x, y) of the rectangle.
        * @param size The width (x) and height (y) of the rectangle.
        */
        public constructor ($xMin: int, $yMin: int, $width: int, $height: int)
        /**
        * Creates a new RectInt.
        * @param xMin The minimum X value of the RectInt.
        * @param yMin The minimum Y value of the RectInt.
        * @param width Width of the rectangle.
        * @param height Height of the rectangle.
        * @param position The position (x, y) of the rectangle.
        * @param size The width (x) and height (y) of the rectangle.
        */
        public constructor ($position: Vector2Int, $size: Vector2Int)
        /**
        * Sets the bounds to the min and max value of the rect.
        */
        public SetMinMax ($minPosition: Vector2Int, $maxPosition: Vector2Int) : void
        /**
        * Clamps the position and size of the RectInt to the given bounds.
        * @param bounds Bounds to clamp the RectInt.
        */
        public ClampToBounds ($bounds: RectInt) : void
        /**
        * Returns true if the given position is within the RectInt.
        * @param position Position to check.
        * @returns Whether the position is within the RectInt.
        */
        public Contains ($position: Vector2Int) : boolean
        /**
        * RectInts overlap if each RectInt Contains a shared point.
        * @param other Other rectangle to test overlapping with.
        * @returns True if the other rectangle overlaps this one.
        */
        public Overlaps ($other: RectInt) : boolean
        /**
        * Returns the x, y, width and height of the RectInt.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns the x, y, width and height of the RectInt.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns the x, y, width and height of the RectInt.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        /**
        * Returns true if the given RectInt is equal to this RectInt.
        */
        public Equals ($other: RectInt) : boolean
    }

    /**
    * Representation of 2D vectors and points using integers.
    */
    class Vector2Int extends System.ValueType implements System.IFormattable, System.IEquatable$1<Vector2Int> {

        /**
        * X component of the vector.
        */
        public get x(): int;
        public set x(value: int);
        /**
        * Y component of the vector.
        */
        public get y(): int;
        public set y(value: int);
        /**
        * Returns the length of this vector (Read Only).
        */
        public get magnitude(): float;
        /**
        * Returns the squared length of this vector (Read Only).
        */
        public get sqrMagnitude(): int;
        /**
        * Shorthand for writing Vector2Int(0, 0).
        */
        public static get zero(): Vector2Int;
        /**
        * Shorthand for writing Vector2Int(1, 1).
        */
        public static get one(): Vector2Int;
        /**
        * Shorthand for writing Vector2Int(0, 1).
        */
        public static get up(): Vector2Int;
        /**
        * Shorthand for writing Vector2Int(0, -1).
        */
        public static get down(): Vector2Int;
        /**
        * Shorthand for writing Vector2Int(-1, 0).
        */
        public static get left(): Vector2Int;
        /**
        * Shorthand for writing Vector2Int(1, 0).
        */
        public static get right(): Vector2Int;

        public constructor ($x: int, $y: int)
        /**
        * Set x and y components of an existing Vector2Int.
        */
        public Set ($x: int, $y: int) : void
        /**
        * Returns the distance between a and b.
        */
        public static Distance ($a: Vector2Int, $b: Vector2Int) : float
        /**
        * Returns a vector that is made from the smallest components of two vectors.
        */
        public static Min ($lhs: Vector2Int, $rhs: Vector2Int) : Vector2Int
        /**
        * Returns a vector that is made from the largest components of two vectors.
        */
        public static Max ($lhs: Vector2Int, $rhs: Vector2Int) : Vector2Int
        /**
        * Multiplies two vectors component-wise.
        */
        public static Scale ($a: Vector2Int, $b: Vector2Int) : Vector2Int
        /**
        * Multiplies every component of this vector by the same component of scale.
        */
        public Scale ($scale: Vector2Int) : void
        /**
        * Clamps the Vector2Int to the bounds given by min and max.
        */
        public Clamp ($min: Vector2Int, $max: Vector2Int) : void
        /**
        * Converts a Vector2 to a Vector2Int by doing a Floor to each value.
        */
        public static FloorToInt ($v: Vector2) : Vector2Int
        /**
        * Converts a  Vector2 to a Vector2Int by doing a Ceiling to each value.
        */
        public static CeilToInt ($v: Vector2) : Vector2Int
        /**
        * Converts a  Vector2 to a Vector2Int by doing a Round to each value.
        */
        public static RoundToInt ($v: Vector2) : Vector2Int
        /**
        * Returns true if the objects are equal.
        */
        public Equals ($other: any) : boolean
        public Equals ($other: Vector2Int) : boolean
        /**
        * Gets the hash code for the Vector2Int.
        * @returns The hash code of the Vector2Int.
        */
        public GetHashCode () : int
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        public get_Item ($index: int) : int
        public set_Item ($index: int, $value: int) : void
        public static op_Implicit ($v: Vector2Int) : Vector2
        public static op_Explicit ($v: Vector2Int) : Vector3Int
        public static op_UnaryNegation ($v: Vector2Int) : Vector2Int
        public static op_Addition ($a: Vector2Int, $b: Vector2Int) : Vector2Int
        public static op_Subtraction ($a: Vector2Int, $b: Vector2Int) : Vector2Int
        /**
        * Multiplies a vector by a number.
        */
        public static op_Multiply ($a: Vector2Int, $b: Vector2Int) : Vector2Int
        /**
        * @methodSwap op_Multiply_EBB7509C_H185F171D
        */
        public static op_Multiply ($a: int, $b: Vector2Int) : Vector2Int
        /**
        * Multiplies a vector by a number.
        * @methodSwap op_Multiply_EBB7509C_H3024985
        */
        public static op_Multiply ($a: Vector2Int, $b: int) : Vector2Int
        public static op_Division ($a: Vector2Int, $b: int) : Vector2Int
        public static op_Equality ($lhs: Vector2Int, $rhs: Vector2Int) : boolean
        public static op_Inequality ($lhs: Vector2Int, $rhs: Vector2Int) : boolean
    }

    /**
    * Representation of 3D vectors and points using integers.
    */
    class Vector3Int extends System.ValueType implements System.IFormattable, System.IEquatable$1<Vector3Int> {

        /**
        * X component of the vector.
        */
        public get x(): int;
        public set x(value: int);
        /**
        * Y component of the vector.
        */
        public get y(): int;
        public set y(value: int);
        /**
        * Z component of the vector.
        */
        public get z(): int;
        public set z(value: int);
        /**
        * Returns the length of this vector (Read Only).
        */
        public get magnitude(): float;
        /**
        * Returns the squared length of this vector (Read Only).
        */
        public get sqrMagnitude(): int;
        /**
        * Shorthand for writing Vector3Int(0, 0, 0).
        */
        public static get zero(): Vector3Int;
        /**
        * Shorthand for writing Vector3Int(1, 1, 1).
        */
        public static get one(): Vector3Int;
        /**
        * Shorthand for writing Vector3Int(0, 1, 0).
        */
        public static get up(): Vector3Int;
        /**
        * Shorthand for writing Vector3Int(0, -1, 0).
        */
        public static get down(): Vector3Int;
        /**
        * Shorthand for writing Vector3Int(-1, 0, 0).
        */
        public static get left(): Vector3Int;
        /**
        * Shorthand for writing Vector3Int(1, 0, 0).
        */
        public static get right(): Vector3Int;
        /**
        * Shorthand for writing Vector3Int(0, 0, 1).
        */
        public static get forward(): Vector3Int;
        /**
        * Shorthand for writing Vector3Int(0, 0, -1).
        */
        public static get back(): Vector3Int;

        /**
        * Initializes and returns an instance of a new Vector3Int with x and y components and sets z to zero.
        * @param x The X component of the Vector3Int.
        * @param y The Y component of the Vector3Int.
        */
        public constructor ($x: int, $y: int)
        /**
        * Initializes and returns an instance of a new Vector3Int with x, y, z components.
        * @param x The X component of the Vector3Int.
        * @param y The Y component of the Vector3Int.
        * @param z The Z component of the Vector3Int.
        */
        public constructor ($x: int, $y: int, $z: int)
        /**
        * Set x, y and z components of an existing Vector3Int.
        */
        public Set ($x: int, $y: int, $z: int) : void
        /**
        * Returns the distance between a and b.
        */
        public static Distance ($a: Vector3Int, $b: Vector3Int) : float
        /**
        * Returns a vector that is made from the smallest components of two vectors.
        */
        public static Min ($lhs: Vector3Int, $rhs: Vector3Int) : Vector3Int
        /**
        * Returns a vector that is made from the largest components of two vectors.
        */
        public static Max ($lhs: Vector3Int, $rhs: Vector3Int) : Vector3Int
        /**
        * Multiplies two vectors component-wise.
        */
        public static Scale ($a: Vector3Int, $b: Vector3Int) : Vector3Int
        /**
        * Multiplies every component of this vector by the same component of scale.
        */
        public Scale ($scale: Vector3Int) : void
        /**
        * Clamps the Vector3Int to the bounds given by min and max.
        */
        public Clamp ($min: Vector3Int, $max: Vector3Int) : void
        /**
        * Converts a  Vector3 to a Vector3Int by doing a Floor to each value.
        */
        public static FloorToInt ($v: Vector3) : Vector3Int
        /**
        * Converts a  Vector3 to a Vector3Int by doing a Ceiling to each value.
        */
        public static CeilToInt ($v: Vector3) : Vector3Int
        /**
        * Converts a  Vector3 to a Vector3Int by doing a Round to each value.
        */
        public static RoundToInt ($v: Vector3) : Vector3Int
        /**
        * Returns true if the objects are equal.
        */
        public Equals ($other: any) : boolean
        public Equals ($other: Vector3Int) : boolean
        /**
        * Gets the hash code for the Vector3Int.
        * @returns The hash code of the Vector3Int.
        */
        public GetHashCode () : int
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this vector.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        public get_Item ($index: int) : int
        public set_Item ($index: int, $value: int) : void
        public static op_Implicit ($v: Vector3Int) : Vector3
        public static op_Explicit ($v: Vector3Int) : Vector2Int
        public static op_Addition ($a: Vector3Int, $b: Vector3Int) : Vector3Int
        public static op_Subtraction ($a: Vector3Int, $b: Vector3Int) : Vector3Int
        /**
        * Multiplies a vector by a number.
        */
        public static op_Multiply ($a: Vector3Int, $b: Vector3Int) : Vector3Int
        public static op_UnaryNegation ($a: Vector3Int) : Vector3Int
        /**
        * Multiplies a vector by a number.
        * @methodSwap op_Multiply_EBB7509C_H8DC59A70
        */
        public static op_Multiply ($a: Vector3Int, $b: int) : Vector3Int
        /**
        * @methodSwap op_Multiply_EBB7509C_F16D3FF8
        */
        public static op_Multiply ($a: int, $b: Vector3Int) : Vector3Int
        public static op_Division ($a: Vector3Int, $b: int) : Vector3Int
        public static op_Equality ($lhs: Vector3Int, $rhs: Vector3Int) : boolean
        public static op_Inequality ($lhs: Vector3Int, $rhs: Vector3Int) : boolean
    }

    /**
    * Rendering path of a Camera.
    */
    enum RenderingPath {
        UsePlayerSettings = -1,
        VertexLit = 0,
        Forward = 1,
        DeferredLighting = 2,
        DeferredShading = 3 
    }

    /**
    * Transparent object sorting mode of a Camera.
    */
    enum TransparencySortMode {
        Default = 0,
        Perspective = 1,
        Orthographic = 2,
        CustomAxis = 3 
    }

    /**
    * Describes different types of camera.
    */
    enum CameraType {
        Game = 1,
        SceneView = 2,
        Preview = 4,
        VR = 8,
        Reflection = 16 
    }

    /**
    * Values for Camera.clearFlags, determining what to clear when rendering a Camera.
    */
    enum CameraClearFlags {
        Skybox = 1,
        Color = 2,
        SolidColor = 2,
        Depth = 3,
        Nothing = 4 
    }

    /**
    * Depth texture generation mode for Camera.
    */
    enum DepthTextureMode {
        None = 0,
        Depth = 1,
        DepthNormals = 2,
        MotionVectors = 4 
    }

    /**
    * Enum values for the Camera's targetEye property.
    */
    enum StereoTargetEyeMask {
        None = 0,
        Left = 1,
        Right = 2,
        Both = 3 
    }

    /**
    * Describes a single bounding sphere for use by a CullingGroup.
    */
    class BoundingSphere extends System.ValueType {

        /**
        * The position of the center of the BoundingSphere.
        */
        public position : Vector3
        /**
        * The radius of the BoundingSphere.
        */
        public radius : float

        /**
        * Initializes a BoundingSphere.
        * @param pos The center of the sphere.
        * @param rad The radius of the sphere.
        * @param packedSphere A four-component vector containing the position (packed into the XYZ components) and radius (packed into the W component).
        */
        public constructor ($pos: Vector3, $rad: float)
        /**
        * Initializes a BoundingSphere.
        * @param pos The center of the sphere.
        * @param rad The radius of the sphere.
        * @param packedSphere A four-component vector containing the position (packed into the XYZ components) and radius (packed into the W component).
        */
        public constructor ($packedSphere: Vector4)
    }

    /**
    * Provides information about the current and previous states of one sphere in a CullingGroup.
    */
    class CullingGroupEvent extends System.ValueType {

        /**
        * The index of the sphere that has changed.
        */
        public get index(): int;
        /**
        * Was the sphere considered visible by the most recent culling pass?
        */
        public get isVisible(): boolean;
        /**
        * Was the sphere visible before the most recent culling pass?
        */
        public get wasVisible(): boolean;
        /**
        * Did this sphere change from being invisible to being visible in the most recent culling pass?
        */
        public get hasBecomeVisible(): boolean;
        /**
        * Did this sphere change from being visible to being invisible in the most recent culling pass?
        */
        public get hasBecomeInvisible(): boolean;
        /**
        * The current distance band index of the sphere, after the most recent culling pass.
        */
        public get currentDistance(): int;
        /**
        * The distance band index of the sphere before the most recent culling pass.
        */
        public get previousDistance(): int;

    }

    /**
    * Describes a set of bounding spheres that should have their visibility and distances maintained.
    */
    class CullingGroup extends System.Object implements System.IDisposable {

        /**
        * Sets the callback that will be called when a sphere's visibility and/or distance state has changed.
        */
        public get onStateChanged(): UnityEngine_CullingGroup.StateChanged;
        public set onStateChanged(value: UnityEngine_CullingGroup.StateChanged);
        /**
        * Pauses culling group execution.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Locks the CullingGroup to a specific camera.
        */
        public get targetCamera(): Camera;
        public set targetCamera(value: Camera);

        /**
        * Create a CullingGroup.
        */
        public constructor ()
        /**
        * Clean up all memory used by the CullingGroup immediately.
        */
        public Dispose () : void
        /**
        * Sets the array of bounding sphere definitions that the CullingGroup should compute culling for.
        * @param array The BoundingSpheres to cull.
        */
        public SetBoundingSpheres ($array: BoundingSphere[]) : void
        /**
        * Sets the number of bounding spheres in the bounding spheres array that are actually being used.
        * @param count The number of bounding spheres being used.
        */
        public SetBoundingSphereCount ($count: int) : void
        /**
        * Erase a given bounding sphere by moving the final sphere on top of it.
        * @param index The index of the entry to erase.
        */
        public EraseSwapBack ($index: int) : void
        public static EraseSwapBack<T> ($index: int, $myArray: T[], $size: $Ref<int>) : void
        /**
        * Retrieve the indices of spheres that have particular visibility and/or distance states.
        * @param visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
        * @param distanceIndex The distance band that retrieved spheres must be in.
        * @param result An array that will be filled with the retrieved sphere indices.
        * @param firstIndex The index of the sphere to begin searching at.
        * @returns The number of sphere indices found and written into the result array.
        * @methodSwap QueryIndices_EBB7509C_H86E68502
        */
        public QueryIndices ($visible: boolean, $result: int[], $firstIndex: int) : int
        /**
        * Retrieve the indices of spheres that have particular visibility and/or distance states.
        * @param visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
        * @param distanceIndex The distance band that retrieved spheres must be in.
        * @param result An array that will be filled with the retrieved sphere indices.
        * @param firstIndex The index of the sphere to begin searching at.
        * @returns The number of sphere indices found and written into the result array.
        * @methodSwap QueryIndices_EBB7509C_H207B7E06
        */
        public QueryIndices ($distanceIndex: int, $result: int[], $firstIndex: int) : int
        /**
        * Retrieve the indices of spheres that have particular visibility and/or distance states.
        * @param visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
        * @param distanceIndex The distance band that retrieved spheres must be in.
        * @param result An array that will be filled with the retrieved sphere indices.
        * @param firstIndex The index of the sphere to begin searching at.
        * @returns The number of sphere indices found and written into the result array.
        * @methodSwap QueryIndices_EBB7509C_FCD25795
        */
        public QueryIndices ($visible: boolean, $distanceIndex: int, $result: int[], $firstIndex: int) : int
        /**
        * Returns true if the bounding sphere at index is currently visible from any of the contributing cameras.
        * @param index The index of the bounding sphere.
        * @returns True if the sphere is visible; false if it is invisible.
        */
        public IsVisible ($index: int) : boolean
        /**
        * Get the current distance band index of a given sphere.
        * @param index The index of the sphere.
        * @returns The sphere's current distance band index.
        */
        public GetDistance ($index: int) : int
        /**
        * Set bounding distances for 'distance bands' the group should compute, as well as options for how spheres falling into each distance band should be treated.
        * @param distances An array of bounding distances. The distances should be sorted in increasing order.
        */
        public SetBoundingDistances ($distances: float[]) : void
        /**
        * Set the reference point from which distance bands are measured.
        * @param point A fixed point to measure the distance from.
        * @param transform A transform to measure the distance from. The transform's position will be automatically tracked.
        */
        public SetDistanceReferencePoint ($point: Vector3) : void
        /**
        * Set the reference point from which distance bands are measured.
        * @param point A fixed point to measure the distance from.
        * @param transform A transform to measure the distance from. The transform's position will be automatically tracked.
        */
        public SetDistanceReferencePoint ($transform: Transform) : void
    }

    /**
    * FlareLayer component.
    */
    class FlareLayer extends Behaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;

        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
        private constructor ()
    }

    /**
    * Holds data for a single application crash event and provides access to all gathered crash reports.
    */
    class CrashReport extends System.Object {

        /**
        * Time, when the crash occured.
        */
        public time : System.DateTime
        /**
        * Crash report data as formatted text.
        */
        public text : string
        /**
        * Returns all currently available reports in a new array.
        */
        public static get reports(): CrashReport[];
        /**
        * Returns last crash report, or null if no reports are available.
        */
        public static get lastReport(): CrashReport;

        /**
        * Remove all reports from available reports list.
        */
        public static RemoveAll () : void
        /**
        * Remove report from available reports list.
        */
        public Remove () : void
    }

    /**
    * Class containing methods to ease debugging while developing a game.
    */
    class Debug extends System.Object {

        /**
        * Get default debug logger.
        */
        public static get unityLogger(): ILogger;
        /**
        * Allows you to enable or disable the developer console.
        */
        public static get developerConsoleEnabled(): boolean;
        public static set developerConsoleEnabled(value: boolean);
        /**
        * Controls whether the development console is visible.
        */
        public static get developerConsoleVisible(): boolean;
        public static set developerConsoleVisible(value: boolean);
        /**
        * In the Build Settings dialog there is a check box called "Development Build".
        */
        public static get isDebugBuild(): boolean;

        public constructor ()
        /**
        * Draws a line between specified start and end points.
        * @param start Point in world space where the line should start.
        * @param end Point in world space where the line should end.
        * @param color Color of the line.
        * @param duration How long the line should be visible for.
        * @param depthTest Determines whether objects closer to the camera obscure the line.
        * @methodSwap DrawLine_EBB7509C_FF7C12A0
        */
        public static DrawLine ($start: Vector3, $end: Vector3, $color: Color, $duration: float) : void
        /**
        * Draws a line between specified start and end points.
        * @param start Point in world space where the line should start.
        * @param end Point in world space where the line should end.
        * @param color Color of the line.
        * @param duration How long the line should be visible for.
        * @param depthTest Determines whether objects closer to the camera obscure the line.
        */
        public static DrawLine ($start: Vector3, $end: Vector3, $color: Color) : void
        /**
        * Draws a line between specified start and end points.
        * @param start Point in world space where the line should start.
        * @param end Point in world space where the line should end.
        * @param color Color of the line.
        * @param duration How long the line should be visible for.
        * @param depthTest Determines whether objects closer to the camera obscure the line.
        */
        public static DrawLine ($start: Vector3, $end: Vector3) : void
        /**
        * Draws a line between specified start and end points.
        * @param start Point in world space where the line should start.
        * @param end Point in world space where the line should end.
        * @param color Color of the line.
        * @param duration How long the line should be visible for.
        * @param depthTest Determines whether objects closer to the camera obscure the line.
        * @methodSwap DrawLine_EBB7509C_H6EB6718B
        */
        public static DrawLine ($start: Vector3, $end: Vector3, $color: Color, $duration: float, $depthTest: boolean) : void
        /**
        * Draws a line from start to start + dir in world coordinates.
        * @param start Point in world space where the ray should start.
        * @param dir Direction and length of the ray.
        * @param color Color of the drawn line.
        * @param duration How long the line will be visible for (in seconds).
        * @param depthTest Determines whether objects closer to the camera obscure the line.
        * @methodSwap DrawRay_EBB7509C_FF7C12A0
        */
        public static DrawRay ($start: Vector3, $dir: Vector3, $color: Color, $duration: float) : void
        /**
        * Draws a line from start to start + dir in world coordinates.
        * @param start Point in world space where the ray should start.
        * @param dir Direction and length of the ray.
        * @param color Color of the drawn line.
        * @param duration How long the line will be visible for (in seconds).
        * @param depthTest Determines whether objects closer to the camera obscure the line.
        */
        public static DrawRay ($start: Vector3, $dir: Vector3, $color: Color) : void
        /**
        * Draws a line from start to start + dir in world coordinates.
        * @param start Point in world space where the ray should start.
        * @param dir Direction and length of the ray.
        * @param color Color of the drawn line.
        * @param duration How long the line will be visible for (in seconds).
        * @param depthTest Determines whether objects closer to the camera obscure the line.
        */
        public static DrawRay ($start: Vector3, $dir: Vector3) : void
        /**
        * Draws a line from start to start + dir in world coordinates.
        * @param start Point in world space where the ray should start.
        * @param dir Direction and length of the ray.
        * @param color Color of the drawn line.
        * @param duration How long the line will be visible for (in seconds).
        * @param depthTest Determines whether objects closer to the camera obscure the line.
        * @methodSwap DrawRay_EBB7509C_H6EB6718B
        */
        public static DrawRay ($start: Vector3, $dir: Vector3, $color: Color, $duration: float, $depthTest: boolean) : void
        /**
        * Pauses the editor.
        */
        public static Break () : void
        public static DebugBreak () : void
        /**
        * Logs a message to the Unity Console.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public static Log ($message: any) : void
        /**
        * Logs a message to the Unity Console.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public static Log ($message: any, $context: Object) : void
        /**
        * Logs a formatted message to the Unity Console.
        * @param format A composite format string.
        * @param args Format arguments.
        * @param context Object to which the message applies.
        * @param logType Type of message e.g. warn or error etc.
        * @param logOptions Option flags to treat the log message special.
        */
        public static LogFormat ($format: string, ...args: any[]) : void
        /**
        * Logs a formatted message to the Unity Console.
        * @param format A composite format string.
        * @param args Format arguments.
        * @param context Object to which the message applies.
        * @param logType Type of message e.g. warn or error etc.
        * @param logOptions Option flags to treat the log message special.
        */
        public static LogFormat ($context: Object, $format: string, ...args: any[]) : void
        /**
        * Logs a formatted message to the Unity Console.
        * @param format A composite format string.
        * @param args Format arguments.
        * @param context Object to which the message applies.
        * @param logType Type of message e.g. warn or error etc.
        * @param logOptions Option flags to treat the log message special.
        */
        public static LogFormat ($logType: LogType, $logOptions: LogOption, $context: Object, $format: string, ...args: any[]) : void
        /**
        * A variant of Debug.Log that logs an error message to the console.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public static LogError ($message: any) : void
        /**
        * A variant of Debug.Log that logs an error message to the console.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public static LogError ($message: any, $context: Object) : void
        /**
        * Logs a formatted error message to the Unity console.
        * @param format A composite format string.
        * @param args Format arguments.
        * @param context Object to which the message applies.
        */
        public static LogErrorFormat ($format: string, ...args: any[]) : void
        /**
        * Logs a formatted error message to the Unity console.
        * @param format A composite format string.
        * @param args Format arguments.
        * @param context Object to which the message applies.
        */
        public static LogErrorFormat ($context: Object, $format: string, ...args: any[]) : void
        /**
        * Clears errors from the developer console.
        */
        public static ClearDeveloperConsole () : void
        /**
        * A variant of Debug.Log that logs an error message to the console.
        * @param context Object to which the message applies.
        * @param exception Runtime Exception.
        */
        public static LogException ($exception: System.Exception) : void
        /**
        * A variant of Debug.Log that logs an error message to the console.
        * @param context Object to which the message applies.
        * @param exception Runtime Exception.
        */
        public static LogException ($exception: System.Exception, $context: Object) : void
        /**
        * A variant of Debug.Log that logs a warning message to the console.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public static LogWarning ($message: any) : void
        /**
        * A variant of Debug.Log that logs a warning message to the console.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public static LogWarning ($message: any, $context: Object) : void
        /**
        * Logs a formatted warning message to the Unity Console.
        * @param format A composite format string.
        * @param args Format arguments.
        * @param context Object to which the message applies.
        */
        public static LogWarningFormat ($format: string, ...args: any[]) : void
        /**
        * Logs a formatted warning message to the Unity Console.
        * @param format A composite format string.
        * @param args Format arguments.
        * @param context Object to which the message applies.
        */
        public static LogWarningFormat ($context: Object, $format: string, ...args: any[]) : void
        /**
        * Assert a condition and logs an error message to the Unity console on failure.
        * @param condition Condition you expect to be true.
        * @param context Object to which the message applies.
        * @param message String or object to be converted to string representation for display.
        */
        public static Assert ($condition: boolean) : void
        /**
        * Assert a condition and logs an error message to the Unity console on failure.
        * @param condition Condition you expect to be true.
        * @param context Object to which the message applies.
        * @param message String or object to be converted to string representation for display.
        */
        public static Assert ($condition: boolean, $context: Object) : void
        /**
        * Assert a condition and logs an error message to the Unity console on failure.
        * @param condition Condition you expect to be true.
        * @param context Object to which the message applies.
        * @param message String or object to be converted to string representation for display.
        */
        public static Assert ($condition: boolean, $message: any) : void
        public static Assert ($condition: boolean, $message: string) : void
        /**
        * Assert a condition and logs an error message to the Unity console on failure.
        * @param condition Condition you expect to be true.
        * @param context Object to which the message applies.
        * @param message String or object to be converted to string representation for display.
        */
        public static Assert ($condition: boolean, $message: any, $context: Object) : void
        public static Assert ($condition: boolean, $message: string, $context: Object) : void
        /**
        * Assert a condition and logs a formatted error message to the Unity console on failure.
        * @param condition Condition you expect to be true.
        * @param format A composite format string.
        * @param args Format arguments.
        * @param context Object to which the message applies.
        */
        public static AssertFormat ($condition: boolean, $format: string, ...args: any[]) : void
        /**
        * Assert a condition and logs a formatted error message to the Unity console on failure.
        * @param condition Condition you expect to be true.
        * @param format A composite format string.
        * @param args Format arguments.
        * @param context Object to which the message applies.
        */
        public static AssertFormat ($condition: boolean, $context: Object, $format: string, ...args: any[]) : void
        /**
        * A variant of Debug.Log that logs an assertion message to the console.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public static LogAssertion ($message: any) : void
        /**
        * A variant of Debug.Log that logs an assertion message to the console.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public static LogAssertion ($message: any, $context: Object) : void
        /**
        * Logs a formatted assertion message to the Unity console.
        * @param format A composite format string.
        * @param args Format arguments.
        * @param context Object to which the message applies.
        */
        public static LogAssertionFormat ($format: string, ...args: any[]) : void
        /**
        * Logs a formatted assertion message to the Unity console.
        * @param format A composite format string.
        * @param args Format arguments.
        * @param context Object to which the message applies.
        */
        public static LogAssertionFormat ($context: Object, $format: string, ...args: any[]) : void
    }

    /**
    * Interface for custom logger implementation.
    */
    interface ILogger extends ILogHandler {

        /**
        * Set Logger.ILogHandler.
        */
        logHandler? : ILogHandler
        /**
        * To runtime toggle debug logging [ON/OFF].
        */
        logEnabled? : boolean
        /**
        * To selective enable debug log message.
        */
        filterLogType? : LogType

        /**
        * Check logging is enabled based on the LogType.
        * @returns Retrun true in case logs of LogType will be logged otherwise returns false.
        */
        IsLogTypeAllowed? ($logType: LogType) : boolean
        /**
        * Logs message to the Unity Console using default logger.
        */
        Log? ($logType: LogType, $message: any) : void
        /**
        * Logs message to the Unity Console using default logger.
        */
        Log? ($logType: LogType, $message: any, $context: Object) : void
        /**
        * Logs message to the Unity Console using default logger.
        */
        Log? ($logType: LogType, $tag: string, $message: any) : void
        /**
        * Logs message to the Unity Console using default logger.
        */
        Log? ($logType: LogType, $tag: string, $message: any, $context: Object) : void
        /**
        * Logs message to the Unity Console using default logger.
        */
        Log? ($message: any) : void
        /**
        * Logs message to the Unity Console using default logger.
        */
        Log? ($tag: string, $message: any) : void
        /**
        * Logs message to the Unity Console using default logger.
        */
        Log? ($tag: string, $message: any, $context: Object) : void
        /**
        * A variant of Logger.Log that logs an warning message.
        */
        LogWarning? ($tag: string, $message: any) : void
        /**
        * A variant of Logger.Log that logs an warning message.
        */
        LogWarning? ($tag: string, $message: any, $context: Object) : void
        /**
        * A variant of ILogger.Log that logs an error message.
        */
        LogError? ($tag: string, $message: any) : void
        /**
        * A variant of ILogger.Log that logs an error message.
        */
        LogError? ($tag: string, $message: any, $context: Object) : void
        /**
        * Logs a formatted message.
        */
        LogFormat? ($logType: LogType, $format: string, ...args: any[]) : void
        /**
        * A variant of ILogger.Log that logs an exception message.
        */
        LogException? ($exception: System.Exception) : void
    }

    /**
    * Interface for custom log handler implementation.
    */
    interface ILogHandler {

        /**
        * Logs a formatted message.
        * @param logType The type of the log message.
        * @param context Object to which the message applies.
        * @param format A composite format string.
        * @param args Format arguments.
        */
        LogFormat? ($logType: LogType, $context: Object, $format: string, ...args: any[]) : void
        /**
        * A variant of ILogHandler.LogFormat that logs an exception message.
        * @param exception Runtime Exception.
        * @param context Object to which the message applies.
        */
        LogException? ($exception: System.Exception, $context: Object) : void
    }

    /**
    * Object that is used to resolve references to an ExposedReference field.
    */
    class ExposedPropertyResolver extends System.ValueType {

    }

    /**
    * Creates a type whos value is resolvable at runtime.
    */
    class ExposedReference$1<T> extends System.ValueType {

        public exposedName : PropertyName
        public defaultValue : Object

        public Resolve ($resolver: IExposedPropertyTable) : T
    }

    /**
    * Interface for objects used as resolvers on ExposedReferences.
    */
    interface IExposedPropertyTable {

        /**
        * Assigns a value for an ExposedReference.
        * @param id Identifier of the ExposedReference.
        * @param value The value to assigned to the ExposedReference.
        */
        SetReferenceValue? ($id: PropertyName, $value: Object) : void
        /**
        * Retrieves a value for the given identifier.
        * @param id Identifier of the ExposedReference.
        * @param idValid Is the identifier valid?
        * @returns The value stored in the table.
        */
        GetReferenceValue? ($id: PropertyName, $idValid: $Ref<boolean>) : Object
        /**
        * Remove a value for the given reference.
        * @param id Identifier of the ExposedReference.
        */
        ClearReferenceValue? ($id: PropertyName) : void
    }

    /**
    * Represents a string as an int for efficient lookup and comparison. Use this for common PropertyNames.
    * Internally stores just an int to represent the string. A PropertyName can be created from a string but can not be converted back to a string. The same string always results in the same int representing that string. Thus this is a very efficient string representation in both memory and speed when all you need is comparison.
    * PropertyName is serializable.
    * ToString() is only implemented for debugging purposes in the editor it returns "theName:3737" in the player it returns "Unknown:3737".
    */
    class PropertyName extends System.ValueType implements System.IEquatable$1<PropertyName> {

        /**
        * Initializes the PropertyName using a string.
        */
        public constructor ($name: string)
        public constructor ($other: PropertyName)
        public constructor ($id: int)
        /**
        * Indicates whether the specified PropertyName is an Empty string.
        */
        public static IsNullOrEmpty ($prop: PropertyName) : boolean
        /**
        * Returns the hash code for this PropertyName.
        */
        public GetHashCode () : int
        /**
        * Determines whether this instance and a specified object, which must also be a PropertyName object, have the same value.
        */
        public Equals ($other: any) : boolean
        public Equals ($other: PropertyName) : boolean
        /**
        * For debugging purposes only. Returns the string value representing the string in the Editor.
        * Returns "UnityEngine.PropertyName" in the player.
        */
        public ToString () : string
        public static op_Equality ($lhs: PropertyName, $rhs: PropertyName) : boolean
        public static op_Inequality ($lhs: PropertyName, $rhs: PropertyName) : boolean
        public static op_Implicit ($name: string) : PropertyName
        public static op_Implicit ($id: int) : PropertyName
    }

    /**
    * Evaluates simple math expressions; supports int  float and operators: + - *  % ^ ( ).
    */
    class ExpressionEvaluator extends System.Object {

        public constructor ()
        public static Evaluate<T> ($expression: string, $value: $Ref<T>) : boolean
    }

    /**
    * Compression Levels relate to how much time should be spent compressing Assets into an Asset Bundle.
    */
    enum CompressionLevel {
        None = 0,
        Fastest = 1,
        Fast = 2,
        Normal = 3,
        High = 4,
        Maximum = 5 
    }

    /**
    * Contains information about compression methods, compression levels and block sizes that are supported by Asset Bundle compression at build time and recompression at runtime.
    */
    class BuildCompression extends System.ValueType {

        /**
        * Uncompressed Asset Bundle.
        */
        public static Uncompressed : BuildCompression
        /**
        * LZ4HC "Chunk Based" Compression.
        */
        public static LZ4 : BuildCompression
        /**
        * LZMA Compression.
        */
        public static LZMA : BuildCompression
        /**
        * Uncompressed Asset Bundle.
        */
        public static UncompressedRuntime : BuildCompression
        /**
        * LZ4 Compression for runtime recompression.
        */
        public static LZ4Runtime : BuildCompression
        public get compression(): CompressionType;
        public get level(): CompressionLevel;
        public get blockSize(): uint;

    }

    /**
    * Allows to control the dynamic Global Illumination.
    */
    class DynamicGI extends System.Object {

        /**
        * Allows for scaling the contribution coming from real-time & baked lightmaps.
        * Note: this value can be set in the Lighting Window UI and it is serialized, that is not the case for other properties in this class.
        */
        public static get indirectScale(): float;
        public static set indirectScale(value: float);
        /**
        * Determines the percentage change in lighting intensity that triggers Unity to recalculate the real-time lightmap.
        */
        public static get updateThreshold(): float;
        public static set updateThreshold(value: float);
        /**
        * The number of milliseconds that can be spent on material updates.
        */
        public static get materialUpdateTimeSlice(): int;
        public static set materialUpdateTimeSlice(value: int);
        /**
        * When enabled, new dynamic Global Illumination output is shown in each frame.
        */
        public static get synchronousMode(): boolean;
        public static set synchronousMode(value: boolean);
        /**
        * Is precomputed Enlighten Realtime Global Illumination output converged?
        */
        public static get isConverged(): boolean;

        public constructor ()
        /**
        * Allows to set an emissive color for a given renderer quickly, without the need to render the emissive input for the entire system.
        * @param renderer The Renderer that should get a new color.
        * @param color The emissive Color.
        */
        public static SetEmissive ($renderer: Renderer, $color: Color) : void
        /**
        * Allows overriding the distant environment lighting for Enlighten Realtime Global Illumination, without changing the Skybox Material.
        * @param input Array of float values to be used for Enlighten Realtime Global Illumination environment lighting.
        */
        public static SetEnvironmentData ($input: float[]) : void
        /**
        * Schedules an update of the environment cubemap.
        */
        public static UpdateEnvironment () : void
    }

    /**
    * Represents an axis aligned bounding box with all values as integers.
    */
    class BoundsInt extends System.ValueType implements System.IFormattable, System.IEquatable$1<BoundsInt> {

        /**
        * X value of the minimal point of the box.
        */
        public get x(): int;
        public set x(value: int);
        /**
        * Y value of the minimal point of the box.
        */
        public get y(): int;
        public set y(value: int);
        /**
        * Z value of the minimal point of the box.
        */
        public get z(): int;
        public set z(value: int);
        /**
        * The center of the bounding box.
        */
        public get center(): Vector3;
        /**
        * The minimal point of the box.
        */
        public get min(): Vector3Int;
        public set min(value: Vector3Int);
        /**
        * The maximal point of the box.
        */
        public get max(): Vector3Int;
        public set max(value: Vector3Int);
        /**
        * The minimal x point of the box.
        */
        public get xMin(): int;
        public set xMin(value: int);
        /**
        * The minimal y point of the box.
        */
        public get yMin(): int;
        public set yMin(value: int);
        /**
        * The minimal z point of the box.
        */
        public get zMin(): int;
        public set zMin(value: int);
        /**
        * The maximal x point of the box.
        */
        public get xMax(): int;
        public set xMax(value: int);
        /**
        * The maximal y point of the box.
        */
        public get yMax(): int;
        public set yMax(value: int);
        /**
        * The maximal z point of the box.
        */
        public get zMax(): int;
        public set zMax(value: int);
        /**
        * The position of the bounding box.
        */
        public get position(): Vector3Int;
        public set position(value: Vector3Int);
        /**
        * The total size of the box.
        */
        public get size(): Vector3Int;
        public set size(value: Vector3Int);
        /**
        * A BoundsInt.PositionCollection that contains all positions within the BoundsInt.
        */
        public get allPositionsWithin(): UnityEngine_BoundsInt.PositionEnumerator;

        public constructor ($xMin: int, $yMin: int, $zMin: int, $sizeX: int, $sizeY: int, $sizeZ: int)
        public constructor ($position: Vector3Int, $size: Vector3Int)
        /**
        * Sets the bounds to the min and max value of the box.
        */
        public SetMinMax ($minPosition: Vector3Int, $maxPosition: Vector3Int) : void
        /**
        * Clamps the position and size of this bounding box to the given bounds.
        * @param bounds Bounds to clamp to.
        */
        public ClampToBounds ($bounds: BoundsInt) : void
        /**
        * Is point contained in the bounding box?
        * @param position Point to check.
        * @returns Is point contained in the bounding box?
        */
        public Contains ($position: Vector3Int) : boolean
        /**
        * Returns a formatted string for the bounds.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for the bounds.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for the bounds.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        public Equals ($other: any) : boolean
        public Equals ($other: BoundsInt) : boolean
        public GetHashCode () : int
        public static op_Equality ($lhs: BoundsInt, $rhs: BoundsInt) : boolean
        public static op_Inequality ($lhs: BoundsInt, $rhs: BoundsInt) : boolean
    }

    /**
    * Utility class for common geometric functions.
    */
    class GeometryUtility extends System.Object {

        public constructor ()
        /**
        * Calculates frustum planes.
        * @param camera The camera with the view frustum that you want to calculate planes from.
        * @returns The planes that form the camera's view frustum.
        */
        public static CalculateFrustumPlanes ($camera: Camera) : Plane[]
        /**
        * Calculates frustum planes.
        * @param worldToProjectionMatrix A matrix that transforms from world space to projection space, from which the planes will be calculated.
        * @returns The planes that enclose the projection space described by the matrix.
        */
        public static CalculateFrustumPlanes ($worldToProjectionMatrix: Matrix4x4) : Plane[]
        /**
        * Calculates frustum planes.
        * @param camera The camera with the view frustum that you want to calculate planes from.
        * @param planes An array of 6 Planes that will be overwritten with the calculated plane values.
        */
        public static CalculateFrustumPlanes ($camera: Camera, $planes: Plane[]) : void
        /**
        * Calculates frustum planes.
        * @param worldToProjectionMatrix A matrix that transforms from world space to projection space, from which the planes will be calculated.
        * @param planes An array of 6 Planes that will be overwritten with the calculated plane values.
        */
        public static CalculateFrustumPlanes ($worldToProjectionMatrix: Matrix4x4, $planes: Plane[]) : void
        /**
        * Calculates the bounding box from the given array of positions and the transformation matrix.
        * @param positions An array that stores the location of 3d positions.
        * @param transform A matrix that changes the position, rotation and size of the bounds calculation.
        * @returns Calculates the axis-aligned bounding box.
        */
        public static CalculateBounds ($positions: Vector3[], $transform: Matrix4x4) : Bounds
        /**
        * GeometryUtility.TryCreatePlaneFromPolygon creates a plane from the given list of vertices that define the polygon, as long as they do not characterize a straight line or zero area.
        * @param vertices An array of vertex positions that define the shape of a polygon.
        * @param plane A valid plane that goes through the vertices.
        * @returns Returns true on success, false if Unity did not create a plane from the vertices.
        */
        public static TryCreatePlaneFromPolygon ($vertices: Vector3[], $plane: $Ref<Plane>) : boolean
        /**
        * Returns true if bounds are inside the plane array.
        */
        public static TestPlanesAABB ($planes: Plane[], $bounds: Bounds) : boolean
    }

    /**
    * A ray in 2D space.
    */
    class Ray2D extends System.ValueType implements System.IFormattable {

        /**
        * The starting point of the ray in world space.
        */
        public get origin(): Vector2;
        public set origin(value: Vector2);
        /**
        * The direction of the ray in world space.
        */
        public get direction(): Vector2;
        public set direction(value: Vector2);

        /**
        * Creates a 2D ray starting at origin along direction.
        * @param Vector2 Direction.
        */
        public constructor ($origin: Vector2, $direction: Vector2)
        /**
        * Get a point that lies a given distance along a ray.
        * @param distance Distance of the desired point along the path of the ray.
        */
        public GetPoint ($distance: float) : Vector2
        /**
        * Returns a formatted string for this 2D ray.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this 2D ray.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this 2D ray.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
    }

    /**
    * Offsets for rectangles, borders, etc.
    */
    class RectOffset extends System.Object implements System.IFormattable {

        /**
        * Left edge size.
        */
        public get left(): int;
        public set left(value: int);
        /**
        * Right edge size.
        */
        public get right(): int;
        public set right(value: int);
        /**
        * Top edge size.
        */
        public get top(): int;
        public set top(value: int);
        /**
        * Bottom edge size.
        */
        public get bottom(): int;
        public set bottom(value: int);
        /**
        * Shortcut for left + right. (Read Only)
        */
        public get horizontal(): int;
        /**
        * Shortcut for top + bottom. (Read Only)
        */
        public get vertical(): int;

        /**
        * Creates a new rectangle with offsets.
        */
        public constructor ()
        /**
        * Creates a new rectangle with offsets.
        */
        public constructor ($left: int, $right: int, $top: int, $bottom: int)
        /**
        * Returns a formatted string for this RectOffset.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString () : string
        /**
        * Returns a formatted string for this RectOffset.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string) : string
        /**
        * Returns a formatted string for this RectOffset.
        * @param format A numeric format string.
        * @param formatProvider An object that specifies culture-specific formatting.
        */
        public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        /**
        * Add the border offsets to a rect.
        */
        public Add ($rect: Rect) : Rect
        /**
        * Remove the border offsets from a rect.
        */
        public Remove ($rect: Rect) : Rect
    }

    /**
    * Gizmos are used to give visual debugging or setup aids in the Scene view.
    */
    class Gizmos extends System.Object {

        /**
        * Sets the Color of the gizmos that are drawn next.
        */
        public static get color(): Color;
        public static set color(value: Color);
        /**
        * Sets the Matrix4x4 that the Unity Editor uses to draw Gizmos.
        */
        public static get matrix(): Matrix4x4;
        public static set matrix(value: Matrix4x4);
        /**
        * Set a texture that contains the exposure correction for LightProbe gizmos. The value is sampled from the red channel in the middle of the texture.
        */
        public static get exposure(): Texture;
        public static set exposure(value: Texture);
        /**
        * Set a scale for Light Probe gizmos. This scale will be used to render the spherical harmonic preview spheres.
        */
        public static get probeSize(): float;

        public constructor ()
        /**
        * Draws a line starting at from towards to.
        */
        public static DrawLine ($from: Vector3, $to: Vector3) : void
        /**
        * Draws a wireframe sphere with center and radius.
        */
        public static DrawWireSphere ($center: Vector3, $radius: float) : void
        /**
        * Draws a solid sphere with center and radius.
        */
        public static DrawSphere ($center: Vector3, $radius: float) : void
        /**
        * Draw a wireframe box with center and size.
        */
        public static DrawWireCube ($center: Vector3, $size: Vector3) : void
        /**
        * Draw a solid box at center with size.
        */
        public static DrawCube ($center: Vector3, $size: Vector3) : void
        /**
        * Draws a mesh.
        * @param mesh Mesh to draw as a gizmo.
        * @param position Position (default is zero).
        * @param rotation Rotation (default is no rotation).
        * @param scale Scale (default is no scale).
        * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
        * @methodSwap DrawMesh_EBB7509C_B05EB09B
        */
        public static DrawMesh ($mesh: Mesh, $submeshIndex: int, $position: Vector3, $rotation: Quaternion, $scale: Vector3) : void
        /**
        * Draws a wireframe mesh.
        * @param mesh Mesh to draw as a gizmo.
        * @param position Position (default is zero).
        * @param rotation Rotation (default is no rotation).
        * @param scale Scale (default is no scale).
        * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
        * @methodSwap DrawWireMesh_EBB7509C_B05EB09B
        */
        public static DrawWireMesh ($mesh: Mesh, $submeshIndex: int, $position: Vector3, $rotation: Quaternion, $scale: Vector3) : void
        /**
        * Draw an icon at a position in the Scene view.
        */
        public static DrawIcon ($center: Vector3, $name: string, $allowScaling: boolean) : void
        public static DrawIcon ($center: Vector3, $name: string, $allowScaling: boolean, $tint: Color) : void
        /**
        * Draw a texture in the Scene.
        * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
        * @param texture The texture to be displayed.
        * @param mat An optional material to apply the texture.
        * @param leftBorder Inset from the rectangle's left edge.
        * @param rightBorder Inset from the rectangle's right edge.
        * @param topBorder Inset from the rectangle's top edge.
        * @param bottomBorder Inset from the rectangle's bottom edge.
        * @methodSwap DrawGUITexture_EBB7509C_H9B75C2C4
        */
        public static DrawGUITexture ($screenRect: Rect, $texture: Texture, $leftBorder: int, $rightBorder: int, $topBorder: int, $bottomBorder: int, $mat: Material) : void
        /**
        * Draw a camera frustum using the currently set Gizmos.matrix for its location and rotation.
        * @param center The apex of the truncated pyramid.
        * @param fov Vertical field of view (ie, the angle at the apex in degrees).
        * @param maxRange Distance of the frustum's far plane.
        * @param minRange Distance of the frustum's near plane.
        * @param aspect Width/height ratio.
        */
        public static DrawFrustum ($center: Vector3, $fov: float, $maxRange: float, $minRange: float, $aspect: float) : void
        /**
        * Draws a ray starting at from to from + direction.
        */
        public static DrawRay ($r: Ray) : void
        /**
        * Draws a ray starting at from to from + direction.
        */
        public static DrawRay ($from: Vector3, $direction: Vector3) : void
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion) : void
        public static DrawMesh ($mesh: Mesh, $position: Vector3) : void
        public static DrawMesh ($mesh: Mesh) : void
        /**
        * Draws a mesh.
        * @param mesh Mesh to draw as a gizmo.
        * @param position Position (default is zero).
        * @param rotation Rotation (default is no rotation).
        * @param scale Scale (default is no scale).
        * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $scale: Vector3) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H8C6DE126
        */
        public static DrawMesh ($mesh: Mesh, $submeshIndex: int, $position: Vector3, $rotation: Quaternion) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H6F078265
        */
        public static DrawMesh ($mesh: Mesh, $submeshIndex: int, $position: Vector3) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H24E28B14
        */
        public static DrawMesh ($mesh: Mesh, $submeshIndex: int) : void
        public static DrawWireMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion) : void
        public static DrawWireMesh ($mesh: Mesh, $position: Vector3) : void
        public static DrawWireMesh ($mesh: Mesh) : void
        /**
        * Draws a wireframe mesh.
        * @param mesh Mesh to draw as a gizmo.
        * @param position Position (default is zero).
        * @param rotation Rotation (default is no rotation).
        * @param scale Scale (default is no scale).
        * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
        */
        public static DrawWireMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $scale: Vector3) : void
        /**
        * @methodSwap DrawWireMesh_EBB7509C_H8C6DE126
        */
        public static DrawWireMesh ($mesh: Mesh, $submeshIndex: int, $position: Vector3, $rotation: Quaternion) : void
        /**
        * @methodSwap DrawWireMesh_EBB7509C_H6F078265
        */
        public static DrawWireMesh ($mesh: Mesh, $submeshIndex: int, $position: Vector3) : void
        /**
        * @methodSwap DrawWireMesh_EBB7509C_H24E28B14
        */
        public static DrawWireMesh ($mesh: Mesh, $submeshIndex: int) : void
        /**
        * Draw an icon at a position in the Scene view.
        */
        public static DrawIcon ($center: Vector3, $name: string) : void
        /**
        * Draw a texture in the Scene.
        * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
        * @param texture The texture to be displayed.
        * @param mat An optional material to apply the texture.
        * @param leftBorder Inset from the rectangle's left edge.
        * @param rightBorder Inset from the rectangle's right edge.
        * @param topBorder Inset from the rectangle's top edge.
        * @param bottomBorder Inset from the rectangle's bottom edge.
        */
        public static DrawGUITexture ($screenRect: Rect, $texture: Texture) : void
        /**
        * Draw a texture in the Scene.
        * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
        * @param texture The texture to be displayed.
        * @param mat An optional material to apply the texture.
        * @param leftBorder Inset from the rectangle's left edge.
        * @param rightBorder Inset from the rectangle's right edge.
        * @param topBorder Inset from the rectangle's top edge.
        * @param bottomBorder Inset from the rectangle's bottom edge.
        */
        public static DrawGUITexture ($screenRect: Rect, $texture: Texture, $mat: Material) : void
        /**
        * Draw a texture in the Scene.
        * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
        * @param texture The texture to be displayed.
        * @param mat An optional material to apply the texture.
        * @param leftBorder Inset from the rectangle's left edge.
        * @param rightBorder Inset from the rectangle's right edge.
        * @param topBorder Inset from the rectangle's top edge.
        * @param bottomBorder Inset from the rectangle's bottom edge.
        * @methodSwap DrawGUITexture_EBB7509C_H484D9D22
        */
        public static DrawGUITexture ($screenRect: Rect, $texture: Texture, $leftBorder: int, $rightBorder: int, $topBorder: int, $bottomBorder: int) : void
    }

    /**
    * BillboardAsset describes how a billboard is rendered.
    */
    class BillboardAsset extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Width of the billboard.
        */
        public get width(): float;
        public set width(value: float);
        /**
        * Height of the billboard.
        */
        public get height(): float;
        public set height(value: float);
        /**
        * Height of the billboard that is below ground.
        */
        public get bottom(): float;
        public set bottom(value: float);
        /**
        * Number of pre-rendered images that can be switched when the billboard is viewed from different angles.
        */
        public get imageCount(): int;
        /**
        * Number of vertices in the billboard mesh.
        */
        public get vertexCount(): int;
        /**
        * Number of indices in the billboard mesh.
        */
        public get indexCount(): int;
        /**
        * The material used for rendering.
        */
        public get material(): Material;
        public set material(value: Material);

        /**
        * Constructs a new BillboardAsset.
        */
        public constructor ()
        public GetImageTexCoords ($imageTexCoords: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * Get the array of billboard image texture coordinate data.
        * @param imageTexCoords The list that receives the array.
        */
        public GetImageTexCoords () : Vector4[]
        public SetImageTexCoords ($imageTexCoords: System_Collections_Generic.List$1<Vector4>) : void
        /**
        * Set the array of billboard image texture coordinate data.
        * @param imageTexCoords The array of data to set.
        */
        public SetImageTexCoords ($imageTexCoords: Vector4[]) : void
        public GetVertices ($vertices: System_Collections_Generic.List$1<Vector2>) : void
        /**
        * Get the vertices of the billboard mesh.
        * @param vertices The list that receives the array.
        */
        public GetVertices () : Vector2[]
        public SetVertices ($vertices: System_Collections_Generic.List$1<Vector2>) : void
        /**
        * Set the vertices of the billboard mesh.
        * @param vertices The array of data to set.
        */
        public SetVertices ($vertices: Vector2[]) : void
        public GetIndices ($indices: System_Collections_Generic.List$1<ushort>) : void
        /**
        * Get the indices of the billboard mesh.
        * @param indices The list that receives the array.
        */
        public GetIndices () : ushort[]
        public SetIndices ($indices: System_Collections_Generic.List$1<ushort>) : void
        /**
        * Set the indices of the billboard mesh.
        * @param indices The array of data to set.
        */
        public SetIndices ($indices: ushort[]) : void
    }

    /**
    * Renders a billboard from a BillboardAsset.
    */
    class BillboardRenderer extends Renderer {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * The bounding box of the renderer in world space.
        */
        public get bounds(): Bounds;
        public set bounds(value: Bounds);
        /**
        * The bounding box of the renderer in local space.
        */
        public get localBounds(): Bounds;
        public set localBounds(value: Bounds);
        /**
        * Makes the rendered 3D object visible if enabled.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Is this renderer visible in any camera? (Read Only)
        */
        public get isVisible(): boolean;
        /**
        * Does this object cast shadows?
        */
        public get shadowCastingMode(): UnityEngine_Rendering.ShadowCastingMode;
        public set shadowCastingMode(value: UnityEngine_Rendering.ShadowCastingMode);
        /**
        * Does this object receive shadows?
        */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
        * Allows turning off rendering for a specific component.
        */
        public get forceRenderingOff(): boolean;
        public set forceRenderingOff(value: boolean);
        /**
        * Is this renderer a static shadow caster?
        */
        public get staticShadowCaster(): boolean;
        public set staticShadowCaster(value: boolean);
        /**
        * Specifies the mode for motion vector rendering.
        */
        public get motionVectorGenerationMode(): MotionVectorGenerationMode;
        public set motionVectorGenerationMode(value: MotionVectorGenerationMode);
        /**
        * The light probe interpolation type.
        */
        public get lightProbeUsage(): UnityEngine_Rendering.LightProbeUsage;
        public set lightProbeUsage(value: UnityEngine_Rendering.LightProbeUsage);
        /**
        * Should reflection probes be used for this Renderer?
        */
        public get reflectionProbeUsage(): UnityEngine_Rendering.ReflectionProbeUsage;
        public set reflectionProbeUsage(value: UnityEngine_Rendering.ReflectionProbeUsage);
        /**
        * Determines which rendering layer this renderer lives on, if you use a.
        */
        public get renderingLayerMask(): uint;
        public set renderingLayerMask(value: uint);
        /**
        * This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
        */
        public get rendererPriority(): int;
        public set rendererPriority(value: int);
        /**
        * Describes how this renderer is updated for ray tracing.
        */
        public get rayTracingMode(): UnityEngine_Experimental_Rendering.RayTracingMode;
        public set rayTracingMode(value: UnityEngine_Experimental_Rendering.RayTracingMode);
        /**
        * Name of the Renderer's sorting layer.
        */
        public get sortingLayerName(): string;
        public set sortingLayerName(value: string);
        /**
        * Unique ID of the Renderer's sorting layer.
        */
        public get sortingLayerID(): int;
        public set sortingLayerID(value: int);
        /**
        * Renderer's order within a sorting layer.
        */
        public get sortingOrder(): int;
        public set sortingOrder(value: int);
        /**
        * Controls if dynamic occlusion culling should be performed for this renderer.
        */
        public get allowOcclusionWhenDynamic(): boolean;
        public set allowOcclusionWhenDynamic(value: boolean);
        /**
        * Indicates whether the renderer is part of a with other renderers.
        */
        public get isPartOfStaticBatch(): boolean;
        /**
        * Matrix that transforms a point from world space into local space (Read Only).
        */
        public get worldToLocalMatrix(): Matrix4x4;
        /**
        * Matrix that transforms a point from local space into world space (Read Only).
        */
        public get localToWorldMatrix(): Matrix4x4;
        /**
        * If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
        */
        public get lightProbeProxyVolumeOverride(): GameObject;
        public set lightProbeProxyVolumeOverride(value: GameObject);
        /**
        * If set, Renderer will use this Transform's position to find the light or reflection probe.
        */
        public get probeAnchor(): Transform;
        public set probeAnchor(value: Transform);
        /**
        * The index of the baked lightmap applied to this renderer.
        */
        public get lightmapIndex(): int;
        public set lightmapIndex(value: int);
        /**
        * The index of the real-time lightmap applied to this renderer.
        */
        public get realtimeLightmapIndex(): int;
        public set realtimeLightmapIndex(value: int);
        /**
        * The UV scale & offset used for a lightmap.
        */
        public get lightmapScaleOffset(): Vector4;
        public set lightmapScaleOffset(value: Vector4);
        /**
        * The UV scale & offset used for a real-time lightmap.
        */
        public get realtimeLightmapScaleOffset(): Vector4;
        public set realtimeLightmapScaleOffset(value: Vector4);
        /**
        * Returns all the instantiated materials of this object.
        */
        public get materials(): Material[];
        public set materials(value: Material[]);
        /**
        * Returns the first instantiated Material assigned to the renderer.
        */
        public get material(): Material;
        public set material(value: Material);
        /**
        * The shared material of this object.
        */
        public get sharedMaterial(): Material;
        public set sharedMaterial(value: Material);
        /**
        * All the shared materials of this object.
        */
        public get sharedMaterials(): Material[];
        public set sharedMaterials(value: Material[]);
        /**
        * The BillboardAsset to render.
        */
        public get billboard(): BillboardAsset;
        public set billboard(value: BillboardAsset);

        /**
        * Constructor.
        */
        private constructor ()
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * Custom Render Texture Manager.
    */
    class CustomRenderTextureManager {

        public static GetAllCustomRenderTextures ($currentCustomRenderTextures: System_Collections_Generic.List$1<CustomRenderTexture>) : void
        public static add_textureLoaded ($value: System.Action$1<CustomRenderTexture>) : void
        public static add_textureUnloaded ($value: System.Action$1<CustomRenderTexture>) : void
        public static add_updateTriggered ($value: System.Action$2<CustomRenderTexture, int>) : void
        public static add_initializeTriggered ($value: System.Action$1<CustomRenderTexture>) : void
        public static remove_textureLoaded ($value: System.Action$1<CustomRenderTexture>) : void
        public static remove_textureUnloaded ($value: System.Action$1<CustomRenderTexture>) : void
        public static remove_updateTriggered ($value: System.Action$2<CustomRenderTexture, int>) : void
        public static remove_initializeTriggered ($value: System.Action$1<CustomRenderTexture>) : void
    }

    /**
    * Custom Render Textures are an extension to Render Textures that allow you to render directly to the Texture using a Shader.
    */
    class CustomRenderTexture extends RenderTexture {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
        */
        public static GenerateAllMips : int
        /**
        * How many mipmap levels are in this Texture (Read Only).
        */
        public get mipmapCount(): int;
        public static get anisotropicFiltering(): AnisotropicFiltering;
        public static set anisotropicFiltering(value: AnisotropicFiltering);
        /**
        * Returns the GraphicsFormat format or color format of a Texture object.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
        * Width of the Texture in pixels (Read Only).
        */
        public get width(): int;
        public set width(value: int);
        /**
        * Height of the Texture in pixels (Read Only).
        */
        public get height(): int;
        public set height(value: int);
        /**
        * Dimensionality (type) of the Texture (Read Only).
        */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
        * Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
        */
        public get isReadable(): boolean;
        /**
        * Texture coordinate wrapping mode.
        */
        public get wrapMode(): TextureWrapMode;
        public set wrapMode(value: TextureWrapMode);
        /**
        * Texture U coordinate wrapping mode.
        */
        public get wrapModeU(): TextureWrapMode;
        public set wrapModeU(value: TextureWrapMode);
        /**
        * Texture V coordinate wrapping mode.
        */
        public get wrapModeV(): TextureWrapMode;
        public set wrapModeV(value: TextureWrapMode);
        /**
        * Texture W coordinate wrapping mode for Texture3D.
        */
        public get wrapModeW(): TextureWrapMode;
        public set wrapModeW(value: TextureWrapMode);
        /**
        * Filtering mode of the Texture.
        */
        public get filterMode(): FilterMode;
        public set filterMode(value: FilterMode);
        /**
        * Defines the anisotropic filtering level of the Texture.
        */
        public get anisoLevel(): int;
        public set anisoLevel(value: int);
        /**
        * The mipmap bias of the Texture.
        */
        public get mipMapBias(): float;
        public set mipMapBias(value: float);
        public get texelSize(): Vector2;
        /**
        * This counter is incremented when the Texture is updated.
        */
        public get updateCount(): uint;
        /**
        * Returns true if the texture pixel data is in sRGB color space (Read Only).
        */
        public get isDataSRGB(): boolean;
        /**
        * The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0.
        * This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually.
        * To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`.
        * `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get totalTextureMemory(): bigint;
        /**
        * The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.
        * For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.
        * The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
        */
        public static get desiredTextureMemory(): bigint;
        /**
        * The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get targetTextureMemory(): bigint;
        /**
        * The amount of memory that all Textures in the scene use.
        */
        public static get currentTextureMemory(): bigint;
        /**
        * The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureMemory(): bigint;
        /**
        * How many times has a Texture been uploaded due to Texture mipmap streaming.
        */
        public static get streamingMipmapUploadCount(): bigint;
        /**
        * Number of renderers registered with the Texture streaming system.
        */
        public static get streamingRendererCount(): bigint;
        /**
        * Number of streaming Textures.
        */
        public static get streamingTextureCount(): bigint;
        /**
        * The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureCount(): bigint;
        /**
        * Number of streaming Textures with outstanding mipmaps to be loaded.
        */
        public static get streamingTexturePendingLoadCount(): bigint;
        /**
        * Number of streaming Textures with mipmaps currently loading.
        */
        public static get streamingTextureLoadingCount(): bigint;
        /**
        * Force streaming Textures to load all mipmap levels.
        */
        public static get streamingTextureForceLoadAll(): boolean;
        public static set streamingTextureForceLoadAll(value: boolean);
        /**
        * This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
        */
        public static get streamingTextureDiscardUnusedMips(): boolean;
        public static set streamingTextureDiscardUnusedMips(value: boolean);
        /**
        * Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
        */
        public static get allowThreadedTextureCreation(): boolean;
        public static set allowThreadedTextureCreation(value: boolean);
        /**
        * Render texture has mipmaps when this flag is set.
        */
        public get useMipMap(): boolean;
        public set useMipMap(value: boolean);
        /**
        * Does this render texture use sRGB read/write conversions? (Read Only).
        */
        public get sRGB(): boolean;
        /**
        * If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any.
        */
        public get vrUsage(): VRTextureUsage;
        public set vrUsage(value: VRTextureUsage);
        /**
        * The render texture memoryless mode property.
        */
        public get memorylessMode(): RenderTextureMemoryless;
        public set memorylessMode(value: RenderTextureMemoryless);
        public get format(): RenderTextureFormat;
        public set format(value: RenderTextureFormat);
        /**
        * The format of the stencil data that you can encapsulate within a RenderTexture.
        * Specifying this property creates a stencil element for the RenderTexture and sets its format.
        * This allows for stencil data to be bound as a Texture to all shader types for the platforms that support it.
        * This property does not specify the format of the stencil buffer, which is constrained by the depth buffer format specified in RenderTexture.depth.
        * Currently, most platforms only support R8_UInt (DirectX11, DirectX12), while PS4 also supports R8_UNorm.
        */
        public get stencilFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set stencilFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
        * The format of the depth/stencil buffer.
        */
        public get depthStencilFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set depthStencilFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
        * Mipmap levels are generated automatically when this flag is set.
        */
        public get autoGenerateMips(): boolean;
        public set autoGenerateMips(value: boolean);
        /**
        * Volume extent of a 3D render texture or number of slices of array texture.
        */
        public get volumeDepth(): int;
        public set volumeDepth(value: int);
        /**
        * The antialiasing level for the RenderTexture.
        */
        public get antiAliasing(): int;
        public set antiAliasing(value: int);
        /**
        * If true and antiAliasing is greater than 1, the render texture will not be resolved by default.  Use this if the render texture needs to be bound as a multisampled texture in a shader.
        */
        public get bindTextureMS(): boolean;
        public set bindTextureMS(value: boolean);
        /**
        * Enable random access write into this render texture on Shader Model 5.0 level shaders.
        */
        public get enableRandomWrite(): boolean;
        public set enableRandomWrite(value: boolean);
        /**
        * Is the render texture marked to be scaled by the.
        */
        public get useDynamicScale(): boolean;
        public set useDynamicScale(value: boolean);
        public get isPowerOfTwo(): boolean;
        public set isPowerOfTwo(value: boolean);
        /**
        * Currently active render texture.
        */
        public static get active(): RenderTexture;
        public static set active(value: RenderTexture);
        /**
        * Color buffer of the render texture (Read Only).
        */
        public get colorBuffer(): RenderBuffer;
        /**
        * Depth/stencil buffer of the render texture (Read Only).
        */
        public get depthBuffer(): RenderBuffer;
        /**
        * The precision of the render texture's depth buffer in bits (0, 16, 24 and 32 are supported).
        */
        public get depth(): int;
        public set depth(value: int);
        /**
        * This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties.
        */
        public get descriptor(): RenderTextureDescriptor;
        public set descriptor(value: RenderTextureDescriptor);
        /**
        * The Material that Unity uses to initialize the content of a Custom Render Texture.
        */
        public get material(): Material;
        public set material(value: Material);
        /**
        * The Material that Unity uses to initialize a Custom Render Texture. Initialization texture and color are ignored if you have set this parameter.
        */
        public get initializationMaterial(): Material;
        public set initializationMaterial(value: Material);
        /**
        * The Texture that Unity uses to initialize a Custom Render Texture, multiplied by the initialization color. Unity ignores this parameter if an initializationMaterial is set.
        */
        public get initializationTexture(): Texture;
        public set initializationTexture(value: Texture);
        /**
        * Determine if Unity initializes the Custom Render Texture with a Texture and a Color or a Material.
        */
        public get initializationSource(): CustomRenderTextureInitializationSource;
        public set initializationSource(value: CustomRenderTextureInitializationSource);
        /**
        * The color that Unity uses to initialize a Custom Render Texture. Unity ignores this parameter if an initializationMaterial is set.
        */
        public get initializationColor(): Color;
        public set initializationColor(value: Color);
        /**
        * Determine how Unity updates the Custom Render Texture.
        */
        public get updateMode(): CustomRenderTextureUpdateMode;
        public set updateMode(value: CustomRenderTextureUpdateMode);
        /**
        * Determine how Unity initializes a texture.
        */
        public get initializationMode(): CustomRenderTextureUpdateMode;
        public set initializationMode(value: CustomRenderTextureUpdateMode);
        /**
        * The space in which Unity expresses update zones. You can set this to Normalized or Pixel space.
        */
        public get updateZoneSpace(): CustomRenderTextureUpdateZoneSpace;
        public set updateZoneSpace(value: CustomRenderTextureUpdateZoneSpace);
        /**
        * The Shader Pass Unity uses to update the Custom Render Texture.
        */
        public get shaderPass(): int;
        public set shaderPass(value: int);
        /**
        * The bit field that you can use to enable or disable update on each of the cubemap faces. The bit order from least to most significant bit is as follows: +X, -X, +Y, -Y, +Z, -Z.
        */
        public get cubemapFaceMask(): uint;
        public set cubemapFaceMask(value: uint);
        /**
        * When this parameter is set to true, Unity double-buffers the Custom Render Texture so that you can access it during its own update.
        */
        public get doubleBuffered(): boolean;
        public set doubleBuffered(value: boolean);
        /**
        * When this parameter is set to true, Unity wraps Update zones around the border of the Custom Render Texture. Otherwise, Unity clamps Update zones at the border of the Custom Render Texture.
        */
        public get wrapUpdateZones(): boolean;
        public set wrapUpdateZones(value: boolean);
        /**
        * The period in seconds that Unity updates real-time Custom Render Textures. A value of 0.0 means Unity updates real-time Custom Render Textures every frame.
        */
        public get updatePeriod(): float;
        public set updatePeriod(value: float);

        /**
        * Create a new Custom Render Texture.
        */
        public constructor ($width: int, $height: int, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite)
        /**
        * Create a new Custom Render Texture.
        */
        public constructor ($width: int, $height: int, $format: RenderTextureFormat)
        public constructor ($width: int, $height: int)
        public constructor ($width: int, $height: int, $defaultFormat: UnityEngine_Experimental_Rendering.DefaultFormat)
        public constructor ($width: int, $height: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat)
        /**
        * Triggers an update of the Custom Render Texture.
        * @param count Number of upate pass to perform. The default value of this count parameter is 1.
        * @methodSwap Update_EBB7509C_F92D023A
        */
        public Update ($count: int) : void
        public Update () : void
        /**
        * Initializes the Custom Render Texture at the start of the next frame. Unity calls Initialise() before CustomRenderTexture.Update.
        */
        public Initialize () : void
        /**
        * Clear all Update Zones.
        */
        public ClearUpdateZones () : void
        public GetUpdateZones ($updateZones: System_Collections_Generic.List$1<CustomRenderTextureUpdateZone>) : void
        /**
        * Gets the Render Texture that this Custom Render Texture uses for double buffering.
        * @returns If CustomRenderTexture. doubleBuffered is true, this returns the Render Texture that this Custom Render Texture uses for double buffering. If CustomRenderTexture. doubleBuffered is false, this returns null.
        */
        public GetDoubleBufferRenderTexture () : RenderTexture
        /**
        * Updates the internal Render Texture that a Custom Render Texture uses for double buffering, so that it matches the size and format of the Custom Render Texture.
        */
        public EnsureDoubleBufferConsistency () : void
        /**
        * Setup the list of Update Zones for the Custom Render Texture.
        */
        public SetUpdateZones ($updateZones: CustomRenderTextureUpdateZone[]) : void
        /**
        * Creates a new RenderTexture object.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param depth Number of bits in depth buffer (0, 16, 24 or 32). Note that only 24 and 32 bit depth have stencil buffer support.
        * @param format Texture color format.
        * @param colorFormat The color format for the RenderTexture.
        * @param depthStencilFormat The depth stencil format for the RenderTexture.
        * @param mipCount Amount of mips to allocate for the RenderTexture.
        * @param readWrite How color space conversions are applied on texture read/write.
        * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
        * @param textureToCopy Copy the settings from another RenderTexture.
        */
        public constructor ($desc: RenderTextureDescriptor)
        /**
        * Creates a new RenderTexture object.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param depth Number of bits in depth buffer (0, 16, 24 or 32). Note that only 24 and 32 bit depth have stencil buffer support.
        * @param format Texture color format.
        * @param colorFormat The color format for the RenderTexture.
        * @param depthStencilFormat The depth stencil format for the RenderTexture.
        * @param mipCount Amount of mips to allocate for the RenderTexture.
        * @param readWrite How color space conversions are applied on texture read/write.
        * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
        * @param textureToCopy Copy the settings from another RenderTexture.
        */
        public constructor ($textureToCopy: RenderTexture)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: int)
        public constructor ($width: int, $height: int, $colorFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: int)
        public constructor ($width: int, $height: int, $colorFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine_Experimental_Rendering.GraphicsFormat)
        /**
        * Creates a new RenderTexture object.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param depth Number of bits in depth buffer (0, 16, 24 or 32). Note that only 24 and 32 bit depth have stencil buffer support.
        * @param format Texture color format.
        * @param colorFormat The color format for the RenderTexture.
        * @param depthStencilFormat The depth stencil format for the RenderTexture.
        * @param mipCount Amount of mips to allocate for the RenderTexture.
        * @param readWrite How color space conversions are applied on texture read/write.
        * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
        * @param textureToCopy Copy the settings from another RenderTexture.
        */
        public constructor ($width: int, $height: int, $depth: int, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite)
        /**
        * Creates a new RenderTexture object.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param depth Number of bits in depth buffer (0, 16, 24 or 32). Note that only 24 and 32 bit depth have stencil buffer support.
        * @param format Texture color format.
        * @param colorFormat The color format for the RenderTexture.
        * @param depthStencilFormat The depth stencil format for the RenderTexture.
        * @param mipCount Amount of mips to allocate for the RenderTexture.
        * @param readWrite How color space conversions are applied on texture read/write.
        * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
        * @param textureToCopy Copy the settings from another RenderTexture.
        */
        public constructor ($width: int, $height: int, $depth: int, $format: RenderTextureFormat)
        /**
        * Creates a new RenderTexture object.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param depth Number of bits in depth buffer (0, 16, 24 or 32). Note that only 24 and 32 bit depth have stencil buffer support.
        * @param format Texture color format.
        * @param colorFormat The color format for the RenderTexture.
        * @param depthStencilFormat The depth stencil format for the RenderTexture.
        * @param mipCount Amount of mips to allocate for the RenderTexture.
        * @param readWrite How color space conversions are applied on texture read/write.
        * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
        * @param textureToCopy Copy the settings from another RenderTexture.
        */
        public constructor ($width: int, $height: int, $depth: int)
        public constructor ($width: int, $height: int, $depth: int, $format: RenderTextureFormat, $mipCount: int)
        public constructor ()
    }

    /**
    * Structure describing an Update Zone.
    */
    class CustomRenderTextureUpdateZone extends System.ValueType {

        /**
        * Position of the center of the Update Zone within the Custom Render Texture.
        */
        public updateZoneCenter : Vector3
        /**
        * Size of the Update Zone.
        */
        public updateZoneSize : Vector3
        /**
        * Rotation of the Update Zone.
        */
        public rotation : float
        /**
        * Shader Pass used to update the Custom Render Texture for this Update Zone.
        */
        public passIndex : int
        /**
        * If true, and if the texture is double buffered, a request is made to swap the buffers before the next update. Otherwise, the buffers will not be swapped.
        */
        public needSwap : boolean

    }

    /**
    * Specify the source of a Custom Render Texture initialization.
    */
    enum CustomRenderTextureInitializationSource {
        TextureAndColor = 0,
        Material = 1 
    }

    /**
    * Frequency of update or initialization of a Custom Render Texture.
    */
    enum CustomRenderTextureUpdateMode {
        OnLoad = 0,
        Realtime = 1,
        OnDemand = 2 
    }

    /**
    * Space in which coordinates are provided for Update Zones.
    */
    enum CustomRenderTextureUpdateZoneSpace {
        Normalized = 0,
        Pixel = 1 
    }

    /**
    * Provides access to a display / screen for rendering operations.
    */
    class Display extends System.Object {

        /**
        * The list of connected displays.
        */
        public static displays : Display[]
        /**
        * Horizontal resolution that the display is rendering at in the viewport.
        */
        public get renderingWidth(): int;
        /**
        * Vertical resolution that the display is rendering at.
        */
        public get renderingHeight(): int;
        /**
        * Horizontal native display resolution.
        */
        public get systemWidth(): int;
        /**
        * Vertical native display resolution.
        */
        public get systemHeight(): int;
        /**
        * Color RenderBuffer.
        */
        public get colorBuffer(): RenderBuffer;
        /**
        * Depth RenderBuffer.
        */
        public get depthBuffer(): RenderBuffer;
        /**
        * Gets the state of the display and returns true if the display is active and false if otherwise.
        */
        public get active(): boolean;
        /**
        * True when the back buffer requires an intermediate texture to render.
        */
        public get requiresBlitToBackbuffer(): boolean;
        /**
        * True when doing a blit to the back buffer requires manual color space conversion.
        */
        public get requiresSrgbBlitToBackbuffer(): boolean;
        /**
        * Main Display.
        */
        public static get main(): Display;
        /**
        * Get the Editors active GameView display target.
        */
        public static get activeEditorGameViewTarget(): int;

        /**
        * Activates an external display. For example, a secondary monitor connected to the system.
        */
        public Activate () : void
        /**
        * Windows platforms only. Activates an external display with a specific width, height and refresh rate. For example, a secondary monitor connected to the system.
        * @param width Windows platforms only. Width of the window to open.
        * @param height Windows platforms only. Height of the window to open.
        * @param refreshRate Refresh Rate of the window to open.
        * @methodSwap Activate_EBB7509C_H14E372C7
        */
        public Activate ($width: int, $height: int, $refreshRate: RefreshRate) : void
        /**
        * Windows platforms only. Sets rendering size and position on screen.
        * @param width Windows platforms only. The width of the window.
        * @param height Windows platforms only. The height of the window.
        * @param x Windows platforms only. The x position of the window.
        * @param y Windows platforms only. The y position of the window.
        */
        public SetParams ($width: int, $height: int, $x: int, $y: int) : void
        /**
        * Sets rendering resolution for the display.
        * @param w The rendering width in pixels.
        * @param h The rendering height in pixels.
        */
        public SetRenderingResolution ($w: int, $h: int) : void
        /**
        * Query relative mouse coordinates.
        * @param inputMouseCoordinates Mouse Input Position as Coordinates.
        */
        public static RelativeMouseAt ($inputMouseCoordinates: Vector3) : Vector3
        public static add_onDisplaysUpdated ($value: UnityEngine_Display.DisplaysUpdatedDelegate) : void
        public static remove_onDisplaysUpdated ($value: UnityEngine_Display.DisplaysUpdatedDelegate) : void
    }

    /**
    * Represents the display refresh rate. This is how many frames the display can show per second.
    */
    class RefreshRate extends System.ValueType implements System.IComparable$1<RefreshRate>, System.IEquatable$1<RefreshRate> {

        /**
        * Numerator of the refresh rate fraction.
        */
        public numerator : uint
        /**
        * Denominator of the refresh rate fraction.
        */
        public denominator : uint
        /**
        * The numerical value of the refresh rate in hertz.
        */
        public get value(): double;

        public Equals ($other: RefreshRate) : boolean
        public CompareTo ($other: RefreshRate) : int
        public ToString () : string
    }

    /**
    * Thread-safe struct for batch sampling Light Probes in a Scene.
    */
    class LightProbesQuery extends System.ValueType implements System.IDisposable {

        /**
        * This property indicates whether target query data is valid.
        */
        public get IsCreated(): boolean;

        /**
        * "Constructor for creating Light Probe sample queries."
        * @param allocator Memory allocation context.
        */
        public constructor ($allocator: Unity_Collections.Allocator)
        public Dispose () : void
        /**
        * Use this method to clean up the memory this query references.
        */
        public Dispose ($inputDeps: Unity_Jobs.JobHandle) : Unity_Jobs.JobHandle
        /**
        * Calculate light probe and occlusion probe at the given world space position.
        * @param position The world space position used to evaluate the probe.
        * @param tetrahedronIndex Tetrahedron index that guides interpolation. Start with a value of 0 and reuse results between frames for faster lookup.
        * @param lightProbe The light probe where the resulting lighting is written to.
        * @param occlusionProbe The occlusion probe where the resulting occlusion is written to.
        */
        public CalculateInterpolatedLightAndOcclusionProbe ($position: Vector3, $tetrahedronIndex: $Ref<int>, $lightProbe: $Ref<UnityEngine_Rendering.SphericalHarmonicsL2>, $occlusionProbe: $Ref<Vector4>) : void
        public CalculateInterpolatedLightAndOcclusionProbes ($positions: Unity_Collections.NativeArray$1<Vector3>, $tetrahedronIndices: Unity_Collections.NativeArray$1<int>, $lightProbes: Unity_Collections.NativeArray$1<UnityEngine_Rendering.SphericalHarmonicsL2>, $occlusionProbes: Unity_Collections.NativeArray$1<Vector4>) : void
    }

    /**
    * Sets the full-screen mode. See the description of each mode for information on platform compatibility.
    */
    enum FullScreenMode {
        ExclusiveFullScreen = 0,
        FullScreenWindow = 1,
        MaximizedWindow = 2,
        Windowed = 3 
    }

    /**
    * Represents a connected display.
    */
    class DisplayInfo extends System.ValueType implements System.IEquatable$1<DisplayInfo> {

        /**
        * The display width in pixels.
        */
        public width : int
        /**
        * The display height in pixels.
        */
        public height : int
        /**
        * The current refresh rate of the display.
        */
        public refreshRate : RefreshRate
        /**
        * Specifies the work area rectangle of the display relative to the top left corner. For example, it excludes the area covered by the macOS Dock or the Windows Taskbar.
        */
        public workArea : RectInt
        /**
        * Human-friendly display name.
        */
        public name : string

        public Equals ($other: DisplayInfo) : boolean
    }

    /**
    * Constants for special values of Screen.sleepTimeout.
    */
    class SleepTimeout extends System.Object {

        /**
        * Prevent screen dimming.
        */
        public static NeverSleep : int
        /**
        * Set the sleep timeout to whatever the user has specified in the system settings.
        */
        public static SystemSetting : int

        public constructor ()
    }

    /**
    * Provides access to display information.
    */
    class Screen extends System.Object {

        /**
        * The current width of the screen window in pixels (Read Only).
        */
        public static get width(): int;
        /**
        * The current height of the screen window in pixels (Read Only).
        */
        public static get height(): int;
        /**
        * The current DPI of the screen / device (Read Only).
        */
        public static get dpi(): float;
        /**
        * The current screen resolution (Read Only).
        */
        public static get currentResolution(): Resolution;
        /**
        * Returns all full-screen resolutions that the monitor supports (Read Only).
        */
        public static get resolutions(): Resolution[];
        /**
        * Enables full-screen mode for the application.
        */
        public static get fullScreen(): boolean;
        public static set fullScreen(value: boolean);
        /**
        * Set this property to one of the values in FullScreenMode to change the display mode of your application.
        */
        public static get fullScreenMode(): FullScreenMode;
        public static set fullScreenMode(value: FullScreenMode);
        /**
        * Returns the safe area of the screen in pixels (Read Only).
        */
        public static get safeArea(): Rect;
        /**
        * Returns a list of screen areas that are not functional for displaying content (Read Only).
        */
        public static get cutouts(): Rect[];
        /**
        * Enables auto-rotation to portrait.
        */
        public static get autorotateToPortrait(): boolean;
        public static set autorotateToPortrait(value: boolean);
        /**
        * Enables auto-rotation to portrait, upside down.
        */
        public static get autorotateToPortraitUpsideDown(): boolean;
        public static set autorotateToPortraitUpsideDown(value: boolean);
        /**
        * Enables auto-rotation to landscape left.
        */
        public static get autorotateToLandscapeLeft(): boolean;
        public static set autorotateToLandscapeLeft(value: boolean);
        /**
        * Enables auto-rotation to landscape right.
        */
        public static get autorotateToLandscapeRight(): boolean;
        public static set autorotateToLandscapeRight(value: boolean);
        /**
        * Specifies logical orientation of the screen.
        */
        public static get orientation(): ScreenOrientation;
        public static set orientation(value: ScreenOrientation);
        /**
        * A power saving setting, allowing the screen to dim some time after the last active user interaction.
        */
        public static get sleepTimeout(): int;
        public static set sleepTimeout(value: int);
        /**
        * Indicates the current brightness of the screen.
        */
        public static get brightness(): float;
        public static set brightness(value: float);
        /**
        * The position of the top left corner of the main window relative to the top left corner of the display.
        */
        public static get mainWindowPosition(): Vector2Int;
        /**
        * The display information associated with the display that the main application window is on.
        */
        public static get mainWindowDisplayInfo(): DisplayInfo;

        public constructor ()
        /**
        * Switches the screen resolution.
        * @methodSwap SetResolution_EBB7509C_H19C6E178
        */
        public static SetResolution ($width: int, $height: int, $fullscreenMode: FullScreenMode, $preferredRefreshRate: RefreshRate) : void
        /**
        * Switches the screen resolution.
        * @methodSwap SetResolution_EBB7509C_FE5F9494
        */
        public static SetResolution ($width: int, $height: int, $fullscreenMode: FullScreenMode) : void
        /**
        * Switches the screen resolution.
        * @methodSwap SetResolution_EBB7509C_H9B170F22
        */
        public static SetResolution ($width: int, $height: int, $fullscreen: boolean) : void
        public static GetDisplayLayout ($displayLayout: System_Collections_Generic.List$1<DisplayInfo>) : void
        /**
        * Moves the main window to the specified position relative to the top left corner of the specified display. Position value is represented in pixels. Moving the window is an asynchronous operation, which can take multiple frames.
        * @param display The target display where the window should move to.
        * @param position The position the window moves to. Relative to the top left corner of the specified display in pixels.
        * @returns Returns AsyncOperation that represents moving the window.
        */
        public static MoveMainWindowTo ($display: $Ref<DisplayInfo>, $position: Vector2Int) : AsyncOperation
    }

    /**
    * Represents a display resolution.
    */
    class Resolution extends System.ValueType {

        /**
        * Resolution width in pixels.
        */
        public get width(): int;
        public set width(value: int);
        /**
        * Resolution height in pixels.
        */
        public get height(): int;
        public set height(value: int);
        /**
        * Resolution's vertical refresh rate in Hz.
        */
        public get refreshRateRatio(): RefreshRate;
        public set refreshRateRatio(value: RefreshRate);

        /**
        * Returns a nicely formatted string of the resolution.
        * @returns A string with the format "width x height @ refreshRateHz".
        */
        public ToString () : string
    }

    /**
    * Describes screen orientation.
    */
    enum ScreenOrientation {
        Portrait = 1,
        PortraitUpsideDown = 2,
        LandscapeLeft = 3,
        LandscapeRight = 4,
        AutoRotation = 5,
        Unknown = 0,
        Landscape = 3 
    }

    /**
    * Raw interface to Unity's drawing functions.
    */
    class Graphics extends System.Object {

        /**
        * Returns the currently active color gamut.
        */
        public static get activeColorGamut(): ColorGamut;
        /**
        * The GraphicsTier for the current device.
        */
        public static get activeTier(): UnityEngine_Rendering.GraphicsTier;
        public static set activeTier(value: UnityEngine_Rendering.GraphicsTier);
        /**
        * True when rendering over native UI is enabled in Player Settings (readonly).
        */
        public static get preserveFramebufferAlpha(): boolean;
        /**
        * The minimum OpenGL ES version. The value is specified in PlayerSettings.
        */
        public static get minOpenGLESVersion(): UnityEngine_Rendering.OpenGLESVersion;
        /**
        * Currently active color buffer (Read Only).
        */
        public static get activeColorBuffer(): RenderBuffer;
        /**
        * Currently active depth/stencil buffer (Read Only).
        */
        public static get activeDepthBuffer(): RenderBuffer;

        public constructor ()
        /**
        * Clear random write targets for level pixel shaders.
        */
        public static ClearRandomWriteTargets () : void
        /**
        * Execute a command buffer.
        * @param buffer The buffer to execute.
        */
        public static ExecuteCommandBuffer ($buffer: UnityEngine_Rendering.CommandBuffer) : void
        /**
        * Executes a command buffer on an async compute queue with the queue selected based on the ComputeQueueType parameter passed.
        * @param buffer The CommandBuffer to be executed.
        * @param queueType Describes the desired async compute queue the supplied CommandBuffer should be executed on.
        */
        public static ExecuteCommandBufferAsync ($buffer: UnityEngine_Rendering.CommandBuffer, $queueType: UnityEngine_Rendering.ComputeQueueType) : void
        /**
        * Sets current render target.
        * @param rt RenderTexture to set as active render target.
        * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
        * @param face Cubemap face to render into (use Unknown if not a cubemap).
        * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
        * @param colorBuffer Color buffer to render into.
        * @param depthBuffer Depth buffer to render into.
        * @param colorBuffers Color buffers to render into (for multiple render target effects).
        * @param setup Full render target setup information.
        * @methodSwap SetRenderTarget_EBB7509C_H385EA10C
        */
        public static SetRenderTarget ($rt: RenderTexture, $mipLevel: int, $face: CubemapFace, $depthSlice: int) : void
        /**
        * Sets current render target.
        * @param rt RenderTexture to set as active render target.
        * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
        * @param face Cubemap face to render into (use Unknown if not a cubemap).
        * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
        * @param colorBuffer Color buffer to render into.
        * @param depthBuffer Depth buffer to render into.
        * @param colorBuffers Color buffers to render into (for multiple render target effects).
        * @param setup Full render target setup information.
        * @methodSwap SetRenderTarget_EBB7509C_H5C8A9D50
        */
        public static SetRenderTarget ($colorBuffer: RenderBuffer, $depthBuffer: RenderBuffer, $mipLevel: int, $face: CubemapFace, $depthSlice: int) : void
        /**
        * Sets current render target.
        * @param rt RenderTexture to set as active render target.
        * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
        * @param face Cubemap face to render into (use Unknown if not a cubemap).
        * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
        * @param colorBuffer Color buffer to render into.
        * @param depthBuffer Depth buffer to render into.
        * @param colorBuffers Color buffers to render into (for multiple render target effects).
        * @param setup Full render target setup information.
        */
        public static SetRenderTarget ($colorBuffers: RenderBuffer[], $depthBuffer: RenderBuffer) : void
        /**
        * Sets current render target.
        * @param rt RenderTexture to set as active render target.
        * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
        * @param face Cubemap face to render into (use Unknown if not a cubemap).
        * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
        * @param colorBuffer Color buffer to render into.
        * @param depthBuffer Depth buffer to render into.
        * @param colorBuffers Color buffers to render into (for multiple render target effects).
        * @param setup Full render target setup information.
        */
        public static SetRenderTarget ($setup: RenderTargetSetup) : void
        /**
        * Set random write target for level pixel shaders.
        * @param index Index of the random write target in the shader.
        * @param uav Buffer or texture to set as the write target.
        * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
        * @methodSwap SetRandomWriteTarget_EBB7509C_H4E488C68
        */
        public static SetRandomWriteTarget ($index: int, $uav: RenderTexture) : void
        /**
        * Set random write target for level pixel shaders.
        * @param index Index of the random write target in the shader.
        * @param uav Buffer or texture to set as the write target.
        * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
        * @methodSwap SetRandomWriteTarget_EBB7509C_EF0A05BB
        */
        public static SetRandomWriteTarget ($index: int, $uav: ComputeBuffer, $preserveCounterValue: boolean) : void
        /**
        * Set random write target for level pixel shaders.
        * @param index Index of the random write target in the shader.
        * @param uav Buffer or texture to set as the write target.
        * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
        * @methodSwap SetRandomWriteTarget_EBB7509C_F29C30D5
        */
        public static SetRandomWriteTarget ($index: int, $uav: GraphicsBuffer, $preserveCounterValue: boolean) : void
        /**
        * Copies pixel data from one texture to another.
        * @param src The source texture.
        * @param dst The destination texture.
        * @param srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
        * @param srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
        * @param dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
        * @param srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
        * @param srcWidth The width of src to copy.
        * @param srcHeight The height of src to copy.
        * @param dstX The x coordinate of dst to copy to.
        * @param dstY The y coordinate to dst to copy to.
        */
        public static CopyTexture ($src: Texture, $dst: Texture) : void
        /**
        * @methodSwap CopyTexture_EBB7509C_H33088BF
        */
        public static CopyTexture ($src: Texture, $srcElement: int, $dst: Texture, $dstElement: int) : void
        /**
        * Copies pixel data from one texture to another.
        * @param src The source texture.
        * @param dst The destination texture.
        * @param srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
        * @param srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
        * @param dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
        * @param srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
        * @param srcWidth The width of src to copy.
        * @param srcHeight The height of src to copy.
        * @param dstX The x coordinate of dst to copy to.
        * @param dstY The y coordinate to dst to copy to.
        * @methodSwap CopyTexture_EBB7509C_E97AAA71
        */
        public static CopyTexture ($src: Texture, $srcElement: int, $srcMip: int, $dst: Texture, $dstElement: int, $dstMip: int) : void
        /**
        * Copies pixel data from one texture to another.
        * @param src The source texture.
        * @param dst The destination texture.
        * @param srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
        * @param srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
        * @param dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
        * @param srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
        * @param srcWidth The width of src to copy.
        * @param srcHeight The height of src to copy.
        * @param dstX The x coordinate of dst to copy to.
        * @param dstY The y coordinate to dst to copy to.
        * @methodSwap CopyTexture_EBB7509C_DD24F6D
        */
        public static CopyTexture ($src: Texture, $srcElement: int, $srcMip: int, $srcX: int, $srcY: int, $srcWidth: int, $srcHeight: int, $dst: Texture, $dstElement: int, $dstMip: int, $dstX: int, $dstY: int) : void
        /**
        * Copies the pixel data from one texture, converts the data into a different format, and copies it into another texture.
        * @param src The source texture. The texture must be a Texture2D or Cubemap.
        * @param dst The destination texture. The texture must be a Texture2D, Texture2DArray, Cubemap, or CubemapArray. The texture must also be uncompressed and correspond to a supported RenderTextureFormat.
        * @param srcElement The element in the source texture to copy from. Use CubemapFace if src is a Cubemap. Set the value to 0 if src is a 2D texture.
        * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
        * @returns true if the method succeeded.
        */
        public static ConvertTexture ($src: Texture, $dst: Texture) : boolean
        /**
        * Copies the pixel data from one texture, converts the data into a different format, and copies it into another texture.
        * @param src The source texture. The texture must be a Texture2D or Cubemap.
        * @param dst The destination texture. The texture must be a Texture2D, Texture2DArray, Cubemap, or CubemapArray. The texture must also be uncompressed and correspond to a supported RenderTextureFormat.
        * @param srcElement The element in the source texture to copy from. Use CubemapFace if src is a Cubemap. Set the value to 0 if src is a 2D texture.
        * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
        * @returns true if the method succeeded.
        * @methodSwap ConvertTexture_EBB7509C_H33088BF
        */
        public static ConvertTexture ($src: Texture, $srcElement: int, $dst: Texture, $dstElement: int) : boolean
        /**
        * Shortcut for calling Graphics.CreateGraphicsFence with Rendering.GraphicsFenceType.AsyncQueueSynchronisation as the first parameter.
        * @param stage Which SynchronisationStage to insert the fence after.
        * @returns Returns a new GraphicsFence.
        */
        public static CreateAsyncGraphicsFence ($stage: UnityEngine_Rendering.SynchronisationStage) : UnityEngine_Rendering.GraphicsFence
        /**
        * Shortcut for calling Graphics.CreateGraphicsFence with Rendering.GraphicsFenceType.AsyncQueueSynchronisation as the first parameter.
        * @param stage Which SynchronisationStage to insert the fence after.
        * @returns Returns a new GraphicsFence.
        */
        public static CreateAsyncGraphicsFence () : UnityEngine_Rendering.GraphicsFence
        /**
        * Creates a GraphicsFence.
        * @param fenceType The Rendering.GraphicsFenceType to create. Currently the only supported value is Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
        * @param stage Which SynchronisationStage to insert the fence after.
        * @returns Returns a new GraphicsFence.
        */
        public static CreateGraphicsFence ($fenceType: UnityEngine_Rendering.GraphicsFenceType, $stage: UnityEngine_Rendering.SynchronisationStageFlags) : UnityEngine_Rendering.GraphicsFence
        /**
        * Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence.
        * @param fence The GraphicsFence the GPU waits for. The fenceType of the graphics fence must be Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
        * @param stage Which SynchronisationStage to wait for.
        */
        public static WaitOnAsyncGraphicsFence ($fence: UnityEngine_Rendering.GraphicsFence) : void
        /**
        * Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence.
        * @param fence The GraphicsFence the GPU waits for. The fenceType of the graphics fence must be Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
        * @param stage Which SynchronisationStage to wait for.
        */
        public static WaitOnAsyncGraphicsFence ($fence: UnityEngine_Rendering.GraphicsFence, $stage: UnityEngine_Rendering.SynchronisationStage) : void
        /**
        * Copies the contents of one GraphicsBuffer into another.
        * @param source The source buffer.
        * @param dest The destination buffer.
        */
        public static CopyBuffer ($source: GraphicsBuffer, $dest: GraphicsBuffer) : void
        /**
        * Draw a texture in screen coordinates.
        * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
        * @param texture Texture to draw.
        * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
        * @param leftBorder Number of pixels from the left that are not affected by scale.
        * @param rightBorder Number of pixels from the right that are not affected by scale.
        * @param topBorder Number of pixels from the top that are not affected by scale.
        * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
        * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
        * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
        * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
        * @methodSwap DrawTexture_EBB7509C_A576DB96
        */
        public static DrawTexture ($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: int, $rightBorder: int, $topBorder: int, $bottomBorder: int, $color: Color, $mat: Material, $pass: int) : void
        /**
        * Draw a texture in screen coordinates.
        * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
        * @param texture Texture to draw.
        * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
        * @param leftBorder Number of pixels from the left that are not affected by scale.
        * @param rightBorder Number of pixels from the right that are not affected by scale.
        * @param topBorder Number of pixels from the top that are not affected by scale.
        * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
        * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
        * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
        * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
        * @methodSwap DrawTexture_EBB7509C_H52577F4A
        */
        public static DrawTexture ($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: int, $rightBorder: int, $topBorder: int, $bottomBorder: int, $mat: Material, $pass: int) : void
        /**
        * Draw a texture in screen coordinates.
        * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
        * @param texture Texture to draw.
        * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
        * @param leftBorder Number of pixels from the left that are not affected by scale.
        * @param rightBorder Number of pixels from the right that are not affected by scale.
        * @param topBorder Number of pixels from the top that are not affected by scale.
        * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
        * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
        * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
        * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
        * @methodSwap DrawTexture_EBB7509C_H5E1F11DF
        */
        public static DrawTexture ($screenRect: Rect, $texture: Texture, $leftBorder: int, $rightBorder: int, $topBorder: int, $bottomBorder: int, $mat: Material, $pass: int) : void
        /**
        * Draw a texture in screen coordinates.
        * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
        * @param texture Texture to draw.
        * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
        * @param leftBorder Number of pixels from the left that are not affected by scale.
        * @param rightBorder Number of pixels from the right that are not affected by scale.
        * @param topBorder Number of pixels from the top that are not affected by scale.
        * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
        * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
        * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
        * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
        * @methodSwap DrawTexture_EBB7509C_DF359F07
        */
        public static DrawTexture ($screenRect: Rect, $texture: Texture, $mat: Material, $pass: int) : void
        public static RenderMesh ($rparams: $Ref<RenderParams>, $mesh: Mesh, $submeshIndex: int, $objectToWorld: Matrix4x4, $prevObjectToWorld?: System.Nullable$1<Matrix4x4>) : void
        /**
        * @methodSwap RenderMeshInstanced_EBB7509C_H139AD536
        */
        public static RenderMeshInstanced<T> ($rparams: $Ref<RenderParams>, $mesh: Mesh, $submeshIndex: int, $instanceData: T[], $instanceCount?: int, $startInstance?: int) : void
        /**
        * @methodSwap RenderMeshInstanced_EBB7509C_BC0D772
        */
        public static RenderMeshInstanced<T> ($rparams: $Ref<RenderParams>, $mesh: Mesh, $submeshIndex: int, $instanceData: System_Collections_Generic.List$1<T>, $instanceCount?: int, $startInstance?: int) : void
        /**
        * @methodSwap RenderMeshInstanced_EBB7509C_H31245BE
        */
        public static RenderMeshInstanced<T> ($rparams: RenderParams, $mesh: Mesh, $submeshIndex: int, $instanceData: Unity_Collections.NativeArray$1<T>, $instanceCount?: int, $startInstance?: int) : void
        /**
        * Renders multiple instances of a mesh using GPU instancing and rendering command arguments from commandBuffer.
        * @param rparams The parameters Unity uses to render the mesh.
        * @param mesh The Mesh to render.
        * @param commandBuffer A command buffer that provides rendering command arguments (see GraphicsBuffer.IndirectDrawIndexedArgs).
        * @param commandCount The number of rendering commands to execute in the commandBuffer.
        * @param startCommand The first command to execute in the commandBuffer.
        */
        public static RenderMeshIndirect ($rparams: $Ref<RenderParams>, $mesh: Mesh, $commandBuffer: GraphicsBuffer, $commandCount?: int, $startCommand?: int) : void
        /**
        * Renders multiple instances of a Mesh using GPU instancing and a custom shader.
        * @param rparams The parameters Unity uses to render the Mesh primitives.
        * @param mesh The Mesh to render.
        * @param submeshIndex The index of a submesh Unity renders when the Mesh contains multiple Materials (submeshes). For a Mesh with a single Material, use value 0.
        * @param instanceCount The number of instances to render.
        */
        public static RenderMeshPrimitives ($rparams: $Ref<RenderParams>, $mesh: Mesh, $submeshIndex: int, $instanceCount?: int) : void
        /**
        * Renders non-indexed primitives with GPU instancing and a custom shader.
        * @param rparams The parameters Unity uses to render the primitives.
        * @param topology Primitive topology (for example, triangles or lines).
        * @param vertexCount The number of vertices per instance.
        * @param instanceCount The number of instances to render.
        */
        public static RenderPrimitives ($rparams: $Ref<RenderParams>, $topology: MeshTopology, $vertexCount: int, $instanceCount?: int) : void
        /**
        * Renders indexed primitives with GPU instancing and a custom shader.
        * @param rparams The parameters Unity uses to render the primitives.
        * @param topology Primitive topology (for example, triangles or lines).
        * @param indexBuffer The index buffer for the rendered primitives.
        * @param indexCount The number of indices per instance.
        * @param startIndex The first index in the indexBuffer.
        * @param instanceCount The number of instances to render.
        */
        public static RenderPrimitivesIndexed ($rparams: $Ref<RenderParams>, $topology: MeshTopology, $indexBuffer: GraphicsBuffer, $indexCount: int, $startIndex?: int, $instanceCount?: int) : void
        /**
        * Renders primitives with GPU instancing and a custom shader using rendering command arguments from commandBuffer.
        * @param rparams The parameters Unity uses to render the primitives.
        * @param topology Primitive topology (for example, triangles or lines).
        * @param commandBuffer A command buffer that provides rendering command arguments (see GraphicsBuffer.IndirectDrawArgs).
        * @param commandCount The number of rendering commands to execute in the commandBuffer.
        * @param startCommand The first command to execute in the commandBuffer.
        */
        public static RenderPrimitivesIndirect ($rparams: $Ref<RenderParams>, $topology: MeshTopology, $commandBuffer: GraphicsBuffer, $commandCount?: int, $startCommand?: int) : void
        /**
        * Renders indexed primitives with GPU instancing and a custom shader with rendering command arguments from commandBuffer.
        * @param rparams The parameters Unity uses to render the primitives.
        * @param topology Primitive topology (for example, triangles or lines).
        * @param indexBuffer Index buffer for the rendered primitives.
        * @param commandBuffer A command buffer that provides rendering command arguments (see GraphicsBuffer.IndirectDrawIndexedArgs).
        * @param commandCount The number of rendering commands to execute in the commandBuffer.
        * @param startCommand The first command to execute in the commandBuffer.
        */
        public static RenderPrimitivesIndexedIndirect ($rparams: $Ref<RenderParams>, $topology: MeshTopology, $indexBuffer: GraphicsBuffer, $commandBuffer: GraphicsBuffer, $commandCount?: int, $startCommand?: int) : void
        /**
        * Draw a mesh immediately.
        * @param mesh The Mesh to draw.
        * @param position Position of the mesh.
        * @param rotation Rotation of the mesh.
        * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
        * @param materialIndex Subset of the mesh to draw.
        * @methodSwap DrawMeshNow_EBB7509C_H62424000
        */
        public static DrawMeshNow ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $materialIndex: int) : void
        /**
        * Draw a mesh immediately.
        * @param mesh The Mesh to draw.
        * @param position Position of the mesh.
        * @param rotation Rotation of the mesh.
        * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
        * @param materialIndex Subset of the mesh to draw.
        * @methodSwap DrawMeshNow_EBB7509C_H3020414C
        */
        public static DrawMeshNow ($mesh: Mesh, $matrix: Matrix4x4, $materialIndex: int) : void
        /**
        * Draw a mesh immediately.
        * @param mesh The Mesh to draw.
        * @param position Position of the mesh.
        * @param rotation Rotation of the mesh.
        * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
        * @param materialIndex Subset of the mesh to draw.
        */
        public static DrawMeshNow ($mesh: Mesh, $position: Vector3, $rotation: Quaternion) : void
        /**
        * Draw a mesh immediately.
        * @param mesh The Mesh to draw.
        * @param position Position of the mesh.
        * @param rotation Rotation of the mesh.
        * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
        * @param materialIndex Subset of the mesh to draw.
        */
        public static DrawMeshNow ($mesh: Mesh, $matrix: Matrix4x4) : void
        /**
        * Draw a mesh.
        * @param mesh The Mesh to draw.
        * @param position Position of the mesh.
        * @param rotation Rotation of the mesh.
        * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
        * @param material Material to use.
        * @param layer  the mesh is drawn on.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param useLightProbes Should the mesh use light probes?
        * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
        * @param lightProbeUsage LightProbeUsage for the mesh.
        * @methodSwap DrawMesh_EBB7509C_H24E1EF28
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean) : void
        /**
        * Draw a mesh.
        * @param mesh The Mesh to draw.
        * @param position Position of the mesh.
        * @param rotation Rotation of the mesh.
        * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
        * @param material Material to use.
        * @param layer  the mesh is drawn on.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param useLightProbes Should the mesh use light probes?
        * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
        * @param lightProbeUsage LightProbeUsage for the mesh.
        * @methodSwap DrawMesh_EBB7509C_H4B13BD47
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform, $useLightProbes: boolean) : void
        /**
        * Draw a mesh.
        * @param mesh The Mesh to draw.
        * @param position Position of the mesh.
        * @param rotation Rotation of the mesh.
        * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
        * @param material Material to use.
        * @param layer  the mesh is drawn on.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param useLightProbes Should the mesh use light probes?
        * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
        * @param lightProbeUsage LightProbeUsage for the mesh.
        * @methodSwap DrawMesh_EBB7509C_BA54E8CC
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean) : void
        /**
        * Draw a mesh.
        * @param mesh The Mesh to draw.
        * @param position Position of the mesh.
        * @param rotation Rotation of the mesh.
        * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
        * @param material Material to use.
        * @param layer  the mesh is drawn on.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param useLightProbes Should the mesh use light probes?
        * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
        * @param lightProbeUsage LightProbeUsage for the mesh.
        * @methodSwap DrawMesh_EBB7509C_H469C363B
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume: LightProbeProxyVolume) : void
        /**
        * Draws the same mesh multiple times using GPU instancing.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
        * @param material Material to use.
        * @param matrices The array of object transformation matrices.
        * @param count The number of instances to be drawn.
        * @param properties Additional material properties to apply. See MaterialPropertyBlock.
        * @param castShadows Determines whether the Meshes should cast shadows.
        * @param receiveShadows Determines whether the Meshes should receive shadows.
        * @param layer  to use.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
        * @param lightProbeUsage LightProbeUsage for the instances.
        * @methodSwap DrawMeshInstanced_EBB7509C_H5A72F6FD
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: Matrix4x4[], $count: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: int, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume: LightProbeProxyVolume) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_H1B4475CE
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: int, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume: LightProbeProxyVolume) : void
        /**
        * This function is now obsolete. Use Graphics.RenderMeshPrimitives instead. Draws the same mesh multiple times using GPU instancing.
        * This is similar to Graphics.DrawMeshInstancedIndirect, except that when the instance count is known from script, it can be supplied directly using this method, rather than via a ComputeBuffer.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
        * @param material Material to use.
        * @param bounds The bounding volume surrounding the instances you intend to draw.
        * @param count The number of instances to be drawn.
        * @param properties Additional material properties to apply. See MaterialPropertyBlock.
        * @param castShadows Determines whether the Meshes should cast shadows.
        * @param receiveShadows Determines whether the Meshes should receive shadows.
        * @param layer  to use.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
        * @param lightProbeUsage LightProbeUsage for the instances.
        */
        public static DrawMeshInstancedProcedural ($mesh: Mesh, $submeshIndex: int, $material: Material, $bounds: Bounds, $count: int, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: int, $camera?: Camera, $lightProbeUsage?: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume?: LightProbeProxyVolume) : void
        /**
        * This function is now obsolete. Use Graphics.RenderMeshIndirect instead. Draws the same mesh multiple times using GPU instancing.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
        * @param material Material to use.
        * @param bounds The bounding volume surrounding the instances you intend to draw.
        * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
        * @param argsOffset The byte offset into the buffer, where the draw arguments start.
        * @param properties Additional material properties to apply. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param layer  to use.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
        * @param lightProbeUsage LightProbeUsage for the instances.
        * @methodSwap DrawMeshInstancedIndirect_EBB7509C_H372D6B33
        */
        public static DrawMeshInstancedIndirect ($mesh: Mesh, $submeshIndex: int, $material: Material, $bounds: Bounds, $bufferWithArgs: ComputeBuffer, $argsOffset: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: int, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume: LightProbeProxyVolume) : void
        /**
        * This function is now obsolete. Use Graphics.RenderMeshIndirect instead. Draws the same mesh multiple times using GPU instancing.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
        * @param material Material to use.
        * @param bounds The bounding volume surrounding the instances you intend to draw.
        * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
        * @param argsOffset The byte offset into the buffer, where the draw arguments start.
        * @param properties Additional material properties to apply. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param layer  to use.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
        * @param lightProbeUsage LightProbeUsage for the instances.
        * @methodSwap DrawMeshInstancedIndirect_EBB7509C_H7334272D
        */
        public static DrawMeshInstancedIndirect ($mesh: Mesh, $submeshIndex: int, $material: Material, $bounds: Bounds, $bufferWithArgs: GraphicsBuffer, $argsOffset: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: int, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume: LightProbeProxyVolume) : void
        /**
        * Draws procedural geometry on the GPU.
        * @param topology Topology of the procedural geometry.
        * @param vertexCount Vertex count to render.
        * @param instanceCount Instance count to render.
        * @methodSwap DrawProceduralNow_EBB7509C_H444CAC0E
        */
        public static DrawProceduralNow ($topology: MeshTopology, $vertexCount: int, $instanceCount?: int) : void
        /**
        * Draws procedural geometry on the GPU.
        * @param topology Topology of the procedural geometry.
        * @param indexCount Index count to render.
        * @param instanceCount Instance count to render.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @methodSwap DrawProceduralNow_EBB7509C_F34572DA
        */
        public static DrawProceduralNow ($topology: MeshTopology, $indexBuffer: GraphicsBuffer, $indexCount: int, $instanceCount?: int) : void
        /**
        * Draws procedural geometry on the GPU.
        * @param topology Topology of the procedural geometry.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @methodSwap DrawProceduralIndirectNow_EBB7509C_H1313FF1B
        */
        public static DrawProceduralIndirectNow ($topology: MeshTopology, $bufferWithArgs: ComputeBuffer, $argsOffset?: int) : void
        /**
        * Draws procedural geometry on the GPU.
        * @param topology Topology of the procedural geometry.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @methodSwap DrawProceduralIndirectNow_EBB7509C_H2258FFCF
        */
        public static DrawProceduralIndirectNow ($topology: MeshTopology, $indexBuffer: GraphicsBuffer, $bufferWithArgs: ComputeBuffer, $argsOffset?: int) : void
        /**
        * Draws procedural geometry on the GPU.
        * @param topology Topology of the procedural geometry.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @methodSwap DrawProceduralIndirectNow_EBB7509C_H384A3711
        */
        public static DrawProceduralIndirectNow ($topology: MeshTopology, $bufferWithArgs: GraphicsBuffer, $argsOffset?: int) : void
        /**
        * Draws procedural geometry on the GPU.
        * @param topology Topology of the procedural geometry.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @methodSwap DrawProceduralIndirectNow_EBB7509C_A271093D
        */
        public static DrawProceduralIndirectNow ($topology: MeshTopology, $indexBuffer: GraphicsBuffer, $bufferWithArgs: GraphicsBuffer, $argsOffset?: int) : void
        /**
        * This function is now obsolete. For non-indexed rendering, use Graphics.RenderPrimitives instead.
        * For indexed rendering, use Graphics.RenderPrimitivesIndexed. Draws procedural geometry on the GPU.
        * @param material Material to use.
        * @param bounds The bounding volume surrounding the instances you intend to draw.
        * @param topology Topology of the procedural geometry.
        * @param vertexCount Vertex count to render.
        * @param instanceCount Instance count to render.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param layer  to use.
        * @methodSwap DrawProcedural_EBB7509C_H1145883B
        */
        public static DrawProcedural ($material: Material, $bounds: Bounds, $topology: MeshTopology, $vertexCount: int, $instanceCount?: int, $camera?: Camera, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: int) : void
        /**
        * Draws procedural geometry on the GPU, with an index buffer.
        * @param material Material to use.
        * @param bounds The bounding volume surrounding the instances you intend to draw.
        * @param topology Topology of the procedural geometry.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @param instanceCount Instance count to render.
        * @param indexCount Index count to render.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param layer  to use.
        * @methodSwap DrawProcedural_EBB7509C_B4CE6A67
        */
        public static DrawProcedural ($material: Material, $bounds: Bounds, $topology: MeshTopology, $indexBuffer: GraphicsBuffer, $indexCount: int, $instanceCount?: int, $camera?: Camera, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: int) : void
        /**
        * Draws procedural geometry on the GPU.
        * @param material Material to use.
        * @param bounds The bounding volume surrounding the instances you intend to draw.
        * @param topology Topology of the procedural geometry.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param layer  to use.
        * @methodSwap DrawProceduralIndirect_EBB7509C_DF927482
        */
        public static DrawProceduralIndirect ($material: Material, $bounds: Bounds, $topology: MeshTopology, $bufferWithArgs: ComputeBuffer, $argsOffset?: int, $camera?: Camera, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: int) : void
        /**
        * Draws procedural geometry on the GPU.
        * @param material Material to use.
        * @param bounds The bounding volume surrounding the instances you intend to draw.
        * @param topology Topology of the procedural geometry.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param layer  to use.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H23060D40
        */
        public static DrawProceduralIndirect ($material: Material, $bounds: Bounds, $topology: MeshTopology, $bufferWithArgs: GraphicsBuffer, $argsOffset?: int, $camera?: Camera, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: int) : void
        /**
        * Draws procedural geometry on the GPU.
        * @param material Material to use.
        * @param bounds The bounding volume surrounding the instances you intend to draw.
        * @param topology Topology of the procedural geometry.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param layer  to use.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H53665526
        */
        public static DrawProceduralIndirect ($material: Material, $bounds: Bounds, $topology: MeshTopology, $indexBuffer: GraphicsBuffer, $bufferWithArgs: ComputeBuffer, $argsOffset?: int, $camera?: Camera, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: int) : void
        /**
        * Draws procedural geometry on the GPU.
        * @param material Material to use.
        * @param bounds The bounding volume surrounding the instances you intend to draw.
        * @param topology Topology of the procedural geometry.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param layer  to use.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H6F269BEC
        */
        public static DrawProceduralIndirect ($material: Material, $bounds: Bounds, $topology: MeshTopology, $indexBuffer: GraphicsBuffer, $bufferWithArgs: GraphicsBuffer, $argsOffset?: int, $camera?: Camera, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: int) : void
        /**
        * Uses a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture.
        * @param dest The destination RenderTexture.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        */
        public static Blit ($source: Texture, $dest: RenderTexture) : void
        /**
        * Uses a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture.
        * @param dest The destination RenderTexture.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        * @methodSwap Blit_EBB7509C_EE238E1
        */
        public static Blit ($source: Texture, $dest: RenderTexture, $sourceDepthSlice: int, $destDepthSlice: int) : void
        /**
        * Uses a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture.
        * @param dest The destination RenderTexture.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        */
        public static Blit ($source: Texture, $dest: RenderTexture, $scale: Vector2, $offset: Vector2) : void
        /**
        * Uses a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture.
        * @param dest The destination RenderTexture.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        * @methodSwap Blit_EBB7509C_H354A1761
        */
        public static Blit ($source: Texture, $dest: RenderTexture, $scale: Vector2, $offset: Vector2, $sourceDepthSlice: int, $destDepthSlice: int) : void
        /**
        * Uses a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture.
        * @param dest The destination RenderTexture.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        * @methodSwap Blit_EBB7509C_H6BCC271C
        */
        public static Blit ($source: Texture, $dest: RenderTexture, $mat: Material, $pass: int) : void
        /**
        * @methodSwap Blit_EBB7509C_D29EFE17
        */
        public static Blit ($source: Texture, $dest: RenderTexture, $mat: Material, $pass: int, $destDepthSlice: int) : void
        public static Blit ($source: Texture, $dest: RenderTexture, $mat: Material) : void
        /**
        * Uses a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture.
        * @param dest The destination RenderTexture.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        * @methodSwap Blit_EBB7509C_H26B21C8C
        */
        public static Blit ($source: Texture, $mat: Material, $pass: int) : void
        /**
        * Uses a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture.
        * @param dest The destination RenderTexture.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        * @methodSwap Blit_EBB7509C_FA7D7FE7
        */
        public static Blit ($source: Texture, $mat: Material, $pass: int, $destDepthSlice: int) : void
        public static Blit ($source: Texture, $mat: Material) : void
        /**
        * Copies source texture into destination, for multi-tap shader.
        * @param source Source texture.
        * @param dest Destination RenderTexture, or null to blit directly to screen.
        * @param mat Material to use for copying. Material's shader should do some post-processing effect.
        * @param offsets Variable number of filtering offsets. Offsets are given in pixels.
        * @param destDepthSlice The texture array destination slice to blit to.
        */
        public static BlitMultiTap ($source: Texture, $dest: RenderTexture, $mat: Material, ...offsets: Vector2[]) : void
        /**
        * Copies source texture into destination, for multi-tap shader.
        * @param source Source texture.
        * @param dest Destination RenderTexture, or null to blit directly to screen.
        * @param mat Material to use for copying. Material's shader should do some post-processing effect.
        * @param offsets Variable number of filtering offsets. Offsets are given in pixels.
        * @param destDepthSlice The texture array destination slice to blit to.
        * @methodSwap BlitMultiTap_EBB7509C_H10F937D4
        */
        public static BlitMultiTap ($source: Texture, $dest: RenderTexture, $mat: Material, $destDepthSlice: int, ...offsets: Vector2[]) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H835512DE
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: int) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H69AC41DE
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: int, $camera: Camera) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_DFA64111
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_B51C93B
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H4B7540FC
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: boolean) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_A4403757
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H41B04C28
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_A8F65333
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_AF09806C
        */
        public static DrawMesh ($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_DD285E6A
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H7350ACBA
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_CA91D565
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H5BF15FEF
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H2D5371A0
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: boolean) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H35A3908B
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_H76F60D7C
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_C94D23D7
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
        /**
        * @methodSwap DrawMesh_EBB7509C_B25DA630
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform) : void
        /**
        * Draw a mesh.
        * @param mesh The Mesh to draw.
        * @param position Position of the mesh.
        * @param rotation Rotation of the mesh.
        * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
        * @param material Material to use.
        * @param layer  the mesh is drawn on.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param useLightProbes Should the mesh use light probes?
        * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
        * @param lightProbeUsage LightProbeUsage for the mesh.
        * @methodSwap DrawMesh_EBB7509C_A17AAA1B
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform, $useLightProbes: boolean) : void
        /**
        * Draw a mesh.
        * @param mesh The Mesh to draw.
        * @param position Position of the mesh.
        * @param rotation Rotation of the mesh.
        * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
        * @param material Material to use.
        * @param layer  the mesh is drawn on.
        * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
        * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
        * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
        * @param castShadows Determines whether the mesh can cast shadows.
        * @param receiveShadows Determines whether the mesh can receive shadows.
        * @param useLightProbes Should the mesh use light probes?
        * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
        * @param lightProbeUsage LightProbeUsage for the mesh.
        * @methodSwap DrawMesh_EBB7509C_H5740CC52
        */
        public static DrawMesh ($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: int, $camera: Camera, $submeshIndex: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_DDBA4148
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: Matrix4x4[]) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_H272A6C1B
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: Matrix4x4[], $count: int) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_H440D9D25
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: Matrix4x4[], $count: int, $properties: MaterialPropertyBlock) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_D9D5A0AA
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: Matrix4x4[], $count: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_AC90E589
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: Matrix4x4[], $count: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_H82D5A7D2
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: Matrix4x4[], $count: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: int) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_H453CCB12
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: Matrix4x4[], $count: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: int, $camera: Camera) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_H370F332C
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: Matrix4x4[], $count: int, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: int, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_EB70F0E4
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_B0FCBBD4
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_H128E5ED1
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_H70C269BE
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_H51AF7AF1
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: int) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_H3A5D4579
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: int, $camera: Camera) : void
        /**
        * @methodSwap DrawMeshInstanced_EBB7509C_H937BFA15
        */
        public static DrawMeshInstanced ($mesh: Mesh, $submeshIndex: int, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: int, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage) : void
        /**
        * @methodSwap DrawMeshInstancedIndirect_EBB7509C_A5312A9A
        */
        public static DrawMeshInstancedIndirect ($mesh: Mesh, $submeshIndex: int, $material: Material, $bounds: Bounds, $bufferWithArgs: ComputeBuffer, $argsOffset?: int, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: int, $camera?: Camera, $lightProbeUsage?: UnityEngine_Rendering.LightProbeUsage) : void
        /**
        * @methodSwap DrawMeshInstancedIndirect_EBB7509C_H26621A7C
        */
        public static DrawMeshInstancedIndirect ($mesh: Mesh, $submeshIndex: int, $material: Material, $bounds: Bounds, $bufferWithArgs: GraphicsBuffer, $argsOffset?: int, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: int, $camera?: Camera, $lightProbeUsage?: UnityEngine_Rendering.LightProbeUsage) : void
        /**
        * Draw a texture in screen coordinates.
        * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
        * @param texture Texture to draw.
        * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
        * @param leftBorder Number of pixels from the left that are not affected by scale.
        * @param rightBorder Number of pixels from the right that are not affected by scale.
        * @param topBorder Number of pixels from the top that are not affected by scale.
        * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
        * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
        * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
        * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
        * @methodSwap DrawTexture_EBB7509C_H1DC194B5
        */
        public static DrawTexture ($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: int, $rightBorder: int, $topBorder: int, $bottomBorder: int, $color: Color, $mat: Material) : void
        /**
        * @methodSwap DrawTexture_EBB7509C_C1A0CCF
        */
        public static DrawTexture ($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: int, $rightBorder: int, $topBorder: int, $bottomBorder: int, $color: Color) : void
        /**
        * Draw a texture in screen coordinates.
        * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
        * @param texture Texture to draw.
        * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
        * @param leftBorder Number of pixels from the left that are not affected by scale.
        * @param rightBorder Number of pixels from the right that are not affected by scale.
        * @param topBorder Number of pixels from the top that are not affected by scale.
        * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
        * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
        * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
        * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
        * @methodSwap DrawTexture_EBB7509C_H7638D761
        */
        public static DrawTexture ($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: int, $rightBorder: int, $topBorder: int, $bottomBorder: int, $mat: Material) : void
        /**
        * @methodSwap DrawTexture_EBB7509C_H81CFC6B
        */
        public static DrawTexture ($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: int, $rightBorder: int, $topBorder: int, $bottomBorder: int) : void
        /**
        * Draw a texture in screen coordinates.
        * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
        * @param texture Texture to draw.
        * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
        * @param leftBorder Number of pixels from the left that are not affected by scale.
        * @param rightBorder Number of pixels from the right that are not affected by scale.
        * @param topBorder Number of pixels from the top that are not affected by scale.
        * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
        * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
        * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
        * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
        * @methodSwap DrawTexture_EBB7509C_H9B75C2C4
        */
        public static DrawTexture ($screenRect: Rect, $texture: Texture, $leftBorder: int, $rightBorder: int, $topBorder: int, $bottomBorder: int, $mat: Material) : void
        /**
        * @methodSwap DrawTexture_EBB7509C_H484D9D22
        */
        public static DrawTexture ($screenRect: Rect, $texture: Texture, $leftBorder: int, $rightBorder: int, $topBorder: int, $bottomBorder: int) : void
        /**
        * Draw a texture in screen coordinates.
        * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
        * @param texture Texture to draw.
        * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
        * @param leftBorder Number of pixels from the left that are not affected by scale.
        * @param rightBorder Number of pixels from the right that are not affected by scale.
        * @param topBorder Number of pixels from the top that are not affected by scale.
        * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
        * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
        * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
        * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
        */
        public static DrawTexture ($screenRect: Rect, $texture: Texture, $mat: Material) : void
        public static DrawTexture ($screenRect: Rect, $texture: Texture) : void
        public static SetRenderTarget ($rt: RenderTexture) : void
        /**
        * @methodSwap SetRenderTarget_EBB7509C_H795E908A
        */
        public static SetRenderTarget ($rt: RenderTexture, $mipLevel: int) : void
        /**
        * @methodSwap SetRenderTarget_EBB7509C_H2562BE8B
        */
        public static SetRenderTarget ($rt: RenderTexture, $mipLevel: int, $face: CubemapFace) : void
        public static SetRenderTarget ($colorBuffer: RenderBuffer, $depthBuffer: RenderBuffer) : void
        /**
        * @methodSwap SetRenderTarget_EBB7509C_H796C7046
        */
        public static SetRenderTarget ($colorBuffer: RenderBuffer, $depthBuffer: RenderBuffer, $mipLevel: int) : void
        /**
        * @methodSwap SetRenderTarget_EBB7509C_F9E89277
        */
        public static SetRenderTarget ($colorBuffer: RenderBuffer, $depthBuffer: RenderBuffer, $mipLevel: int, $face: CubemapFace) : void
        /**
        * @methodSwap SetRandomWriteTarget_EBB7509C_E83D65D0
        */
        public static SetRandomWriteTarget ($index: int, $uav: ComputeBuffer) : void
        /**
        * @methodSwap SetRandomWriteTarget_EBB7509C_EA6F5EB6
        */
        public static SetRandomWriteTarget ($index: int, $uav: GraphicsBuffer) : void
    }

    /**
    * Rendering parameters used by various rendering functions.
    */
    class RenderParams extends System.ValueType {

        /**
        * Layer used for rendering. to use.
        */
        public get layer(): int;
        public set layer(value: int);
        /**
        * Renderer layer mask used for rendering.
        */
        public get renderingLayerMask(): uint;
        public set renderingLayerMask(value: uint);
        /**
        * Renderer priority.
        */
        public get rendererPriority(): int;
        public set rendererPriority(value: int);
        /**
        * Defines world space bounds for the geometry. Used to cull and sort the rendered geometry.
        */
        public get worldBounds(): Bounds;
        public set worldBounds(value: Bounds);
        /**
        * The camera used for rendering. If set to null (default) renders for all cameras.
        */
        public get camera(): Camera;
        public set camera(value: Camera);
        /**
        * Motion vector mode used for rendering.
        */
        public get motionVectorMode(): MotionVectorGenerationMode;
        public set motionVectorMode(value: MotionVectorGenerationMode);
        /**
        * The type of reflection probe used for rendering.
        */
        public get reflectionProbeUsage(): UnityEngine_Rendering.ReflectionProbeUsage;
        public set reflectionProbeUsage(value: UnityEngine_Rendering.ReflectionProbeUsage);
        /**
        * Material used for rendering.
        */
        public get material(): Material;
        public set material(value: Material);
        /**
        * Material properties used for rendering.
        */
        public get matProps(): MaterialPropertyBlock;
        public set matProps(value: MaterialPropertyBlock);
        /**
        * Describes if geometry should cast shadows.
        */
        public get shadowCastingMode(): UnityEngine_Rendering.ShadowCastingMode;
        public set shadowCastingMode(value: UnityEngine_Rendering.ShadowCastingMode);
        /**
        * Descripes if the rendered geometry should receive shadows.
        */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
        * The type of light probe usage.
        */
        public get lightProbeUsage(): UnityEngine_Rendering.LightProbeUsage;
        public set lightProbeUsage(value: UnityEngine_Rendering.LightProbeUsage);
        /**
        * Light Probe Proxy Volume (LPPV) used for rendering.
        */
        public get lightProbeProxyVolume(): LightProbeProxyVolume;
        public set lightProbeProxyVolume(value: LightProbeProxyVolume);

        /**
        * Constructor.
        */
        public constructor ($mat: Material)
    }

    /**
    * The Light Probe Proxy Volume component offers the possibility to use higher resolution lighting for large non-static GameObjects.
    */
    class LightProbeProxyVolume extends Behaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;
        /**
        * Checks if Light Probe Proxy Volumes are supported.
        */
        public static get isFeatureSupported(): boolean;
        /**
        * The world-space bounding box in which the 3D grid of interpolated Light Probes is generated.
        */
        public get boundsGlobal(): Bounds;
        /**
        * The size of the bounding box in which the 3D grid of interpolated Light Probes is generated.
        */
        public get sizeCustom(): Vector3;
        public set sizeCustom(value: Vector3);
        /**
        * The local-space origin of the bounding box in which the 3D grid of interpolated Light Probes is generated.
        */
        public get originCustom(): Vector3;
        public set originCustom(value: Vector3);
        /**
        * Interpolated Light Probe density.
        */
        public get probeDensity(): float;
        public set probeDensity(value: float);
        /**
        * The 3D grid resolution on the x-axis.
        */
        public get gridResolutionX(): int;
        public set gridResolutionX(value: int);
        /**
        * The 3D grid resolution on the y-axis.
        */
        public get gridResolutionY(): int;
        public set gridResolutionY(value: int);
        /**
        * The 3D grid resolution on the z-axis.
        */
        public get gridResolutionZ(): int;
        public set gridResolutionZ(value: int);
        /**
        * The bounding box mode for generating the 3D grid of interpolated Light Probes.
        */
        public get boundingBoxMode(): UnityEngine_LightProbeProxyVolume.BoundingBoxMode;
        public set boundingBoxMode(value: UnityEngine_LightProbeProxyVolume.BoundingBoxMode);
        /**
        * The resolution mode for generating the grid of interpolated Light Probes.
        */
        public get resolutionMode(): UnityEngine_LightProbeProxyVolume.ResolutionMode;
        public set resolutionMode(value: UnityEngine_LightProbeProxyVolume.ResolutionMode);
        /**
        * The mode in which the interpolated Light Probe positions are generated.
        */
        public get probePositionMode(): UnityEngine_LightProbeProxyVolume.ProbePositionMode;
        public set probePositionMode(value: UnityEngine_LightProbeProxyVolume.ProbePositionMode);
        /**
        * Sets the way the Light Probe Proxy Volume refreshes.
        */
        public get refreshMode(): UnityEngine_LightProbeProxyVolume.RefreshMode;
        public set refreshMode(value: UnityEngine_LightProbeProxyVolume.RefreshMode);
        /**
        * Determines how many Spherical Harmonics bands will be evaluated to compute the ambient color.
        */
        public get qualityMode(): UnityEngine_LightProbeProxyVolume.QualityMode;
        public set qualityMode(value: UnityEngine_LightProbeProxyVolume.QualityMode);
        /**
        * The texture data format used by the Light Probe Proxy Volume 3D texture.
        */
        public get dataFormat(): UnityEngine_LightProbeProxyVolume.DataFormat;
        public set dataFormat(value: UnityEngine_LightProbeProxyVolume.DataFormat);

        private constructor ()
        /**
        * Triggers an update of the Light Probe Proxy Volume.
        */
        public Update () : void
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * Represents a color gamut.
    */
    enum ColorGamut {
        sRGB = 0,
        Rec709 = 1,
        Rec2020 = 2,
        DisplayP3 = 3,
        HDR10 = 4,
        DolbyHDR = 5,
        P3D65G22 = 6 
    }

    /**
    * Low-level graphics library.
    */
    class GL extends System.Object {

        /**
        * Mode for Begin: draw triangles.
        */
        public static TRIANGLES : int
        /**
        * Mode for Begin: draw triangle strip.
        */
        public static TRIANGLE_STRIP : int
        /**
        * Mode for Begin: draw quads.
        */
        public static QUADS : int
        /**
        * Mode for Begin: draw lines.
        */
        public static LINES : int
        /**
        * Mode for Begin: draw line strip.
        */
        public static LINE_STRIP : int
        /**
        * Should rendering be done in wireframe?
        */
        public static get wireframe(): boolean;
        public static set wireframe(value: boolean);
        /**
        * Controls whether Linear-to-sRGB color conversion is performed while rendering.
        */
        public static get sRGBWrite(): boolean;
        public static set sRGBWrite(value: boolean);
        /**
        * Select whether to invert the backface culling (true) or not (false).
        */
        public static get invertCulling(): boolean;
        public static set invertCulling(value: boolean);
        /**
        * Gets or sets the modelview matrix.
        */
        public static get modelview(): Matrix4x4;
        public static set modelview(value: Matrix4x4);

        public constructor ()
        /**
        * Submit a vertex.
        */
        public static Vertex3 ($x: float, $y: float, $z: float) : void
        /**
        * Submit a vertex.
        */
        public static Vertex ($v: Vector3) : void
        /**
        * Sets current texture coordinate (x,y,z) for all texture units.
        */
        public static TexCoord3 ($x: float, $y: float, $z: float) : void
        /**
        * Sets current texture coordinate (v.x,v.y,v.z) for all texture units.
        */
        public static TexCoord ($v: Vector3) : void
        /**
        * Sets current texture coordinate (x,y) for all texture units.
        */
        public static TexCoord2 ($x: float, $y: float) : void
        /**
        * Sets current texture coordinate (x,y,z) to the actual texture unit.
        */
        public static MultiTexCoord3 ($unit: int, $x: float, $y: float, $z: float) : void
        /**
        * Sets current texture coordinate (v.x,v.y,v.z) to the actual texture unit.
        */
        public static MultiTexCoord ($unit: int, $v: Vector3) : void
        /**
        * Sets current texture coordinate (x,y) for the actual texture unit.
        */
        public static MultiTexCoord2 ($unit: int, $x: float, $y: float) : void
        /**
        * Sets current vertex color.
        */
        public static Color ($c: Color) : void
        /**
        * Sends queued-up commands in the driver's command buffer to the GPU.
        */
        public static Flush () : void
        /**
        * Resolves the render target for subsequent operations sampling from it.
        */
        public static RenderTargetBarrier () : void
        /**
        * Sets the current model matrix to the one specified.
        */
        public static MultMatrix ($m: Matrix4x4) : void
        /**
        * Saves the model, view and projection matrices to the top of the matrix stack.
        */
        public static PushMatrix () : void
        /**
        * Restores the model, view and projection matrices off the top of the matrix stack.
        */
        public static PopMatrix () : void
        /**
        * Load an identity into the current model and view matrices.
        */
        public static LoadIdentity () : void
        /**
        * Helper function to set up an orthograhic projection.
        */
        public static LoadOrtho () : void
        /**
        * Setup a matrix for pixel-correct rendering.
        */
        public static LoadPixelMatrix () : void
        /**
        * Load an arbitrary matrix to the current projection matrix.
        */
        public static LoadProjectionMatrix ($mat: Matrix4x4) : void
        /**
        * Invalidate the internally cached render state.
        */
        public static InvalidateState () : void
        /**
        * Compute GPU projection matrix from camera's projection matrix.
        * @param proj Source projection matrix.
        * @param renderIntoTexture Will this projection be used for rendering into a RenderTexture?
        * @returns Adjusted projection matrix for the current graphics API.
        */
        public static GetGPUProjectionMatrix ($proj: Matrix4x4, $renderIntoTexture: boolean) : Matrix4x4
        /**
        * Setup a matrix for pixel-correct rendering.
        * @methodSwap LoadPixelMatrix_EBB7509C_H3F97763D
        */
        public static LoadPixelMatrix ($left: float, $right: float, $bottom: float, $top: float) : void
        /**
        * Send a user-defined event to a native code plugin.
        * @param eventID User defined id to send to the callback.
        * @param callback Native code callback to queue for Unity's renderer to invoke.
        */
        public static IssuePluginEvent ($callback: System.IntPtr, $eventID: int) : void
        /**
        * Begin drawing 3D primitives.
        * @param mode Primitives to draw: can be TRIANGLES, TRIANGLE_STRIP, QUADS or LINES.
        */
        public static Begin ($mode: int) : void
        /**
        * End drawing 3D primitives.
        */
        public static End () : void
        /**
        * Clear the current render buffer.
        * @param clearDepth Should the depth buffer be cleared?
        * @param clearColor Should the color buffer be cleared?
        * @param backgroundColor The color to clear with, used only if clearColor is true.
        * @param depth The depth to clear the z-buffer with, used only if clearDepth is true. The valid
        range is from 0 (near plane) to 1 (far plane). The value is graphics API agnostic: the abstraction layer will convert
        the value to match the convention of the current graphics API.
        * @methodSwap Clear_EBB7509C_C93D2606
        */
        public static Clear ($clearDepth: boolean, $clearColor: boolean, $backgroundColor: Color, $depth: float) : void
        public static Clear ($clearDepth: boolean, $clearColor: boolean, $backgroundColor: Color) : void
        /**
        * Set the rendering viewport.
        */
        public static Viewport ($pixelRect: Rect) : void
        /**
        * Clear the current render buffer with camera's skybox.
        * @param clearDepth Should the depth buffer be cleared?
        * @param camera Camera to get projection parameters and skybox from.
        */
        public static ClearWithSkybox ($clearDepth: boolean, $camera: Camera) : void
    }

    /**
    * Scales render textures to support dynamic resolution if the target platform/graphics API supports it.
    */
    class ScalableBufferManager {

        /**
        * Width scale factor to control dynamic resolution.
        */
        public static get widthScaleFactor(): float;
        /**
        * Height scale factor to control dynamic resolution.
        */
        public static get heightScaleFactor(): float;

        /**
        * Function to resize all buffers marked as DynamicallyScalable.
        * @param widthScale New scale factor for the width the ScalableBufferManager will use to resize all render textures the user marked as DynamicallyScalable, has to be some value greater than 0.0 and less than or equal to 1.0.
        * @param heightScale New scale factor for the height the ScalableBufferManager will use to resize all render textures the user marked as DynamicallyScalable, has to be some value greater than 0.0 and less than or equal to 1.0.
        */
        public static ResizeBuffers ($widthScale: float, $heightScale: float) : void
    }

    /**
    * Struct containing basic FrameTimings and accompanying relevant data.
    */
    class FrameTiming extends System.ValueType {

        /**
        * This is the total CPU frame time calculated as the time between ends of two frames, which includes all waiting time and overheads, in ms.
        */
        public cpuFrameTime : double
        /**
        * Total time between start of the frame and when the main thread finished the job, in ms.
        */
        public cpuMainThreadFrameTime : double
        /**
        * The CPU time the last frame spent in waiting for Present on the main thread, in ms.
        */
        public cpuMainThreadPresentWaitTime : double
        /**
        * The frame time between start of the work on the render thread and when Present was called, in ms.
        */
        public cpuRenderThreadFrameTime : double
        /**
        * The GPU time for a given frame, in ms.
        */
        public gpuFrameTime : double
        /**
        * This is the CPU clock time of the time when the frame was started.
        */
        public frameStartTimestamp : bigint
        /**
        * This is the CPU clock time of the time when the first job was submitted to GPU.
        */
        public firstSubmitTimestamp : bigint
        /**
        * This is the CPU clock time at the point Present was called for the current frame.
        */
        public cpuTimePresentCalled : bigint
        /**
        * This is the CPU clock time at the point GPU finished rendering the frame and interrupted the CPU.
        */
        public cpuTimeFrameComplete : bigint
        /**
        * This was the height scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings.
        */
        public heightScale : float
        /**
        * This was the width scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings.
        */
        public widthScale : float
        /**
        * This was the vsync mode for the given frame and the linked frame timings.
        */
        public syncInterval : uint

    }

    /**
    * The FrameTimingManager allows the user to capture and access FrameTiming data for multiple frames.
    */
    class FrameTimingManager {

        /**
        * Check if frame timing statistics are enabled.
        * @returns Whether frame timing statistics are enabled.
        */
        public static IsFeatureEnabled () : boolean
        /**
        * This function triggers the FrameTimingManager to capture a snapshot of FrameTiming's data, that can then be accessed by the user.
        */
        public static CaptureFrameTimings () : void
        /**
        * Allows the user to access the currently captured FrameTimings.
        * @param numFrames User supplies a desired number of frames they would like FrameTimings for. This should be equal to or less than the maximum FrameTimings the platform can capture.
        * @param timings An array of FrameTiming structs that is passed in by the user and will be filled with data as requested. It is the users job to make sure the array that is passed is large enough to hold the requested number of FrameTimings.
        * @returns Returns the number of FrameTimings it actually was able to get. This will always be equal to or less than the requested numFrames depending on availability of captured FrameTimings.
        */
        public static GetLatestTimings ($numFrames: uint, $timings: FrameTiming[]) : uint
        /**
        * This returns the number of vsyncs per second on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.
        * @returns Number of vsyncs per second of the current platform.
        */
        public static GetVSyncsPerSecond () : float
        /**
        * This returns the frequency of GPU timer on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.
        * @returns GPU timer frequency for current platform.
        */
        public static GetGpuTimerFrequency () : bigint
        /**
        * This returns the frequency of CPU timer on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.
        * @returns CPU timer frequency for current platform.
        */
        public static GetCpuTimerFrequency () : bigint
    }

    /**
    * Data of a lightmap.
    */
    class LightmapData extends System.Object {

        /**
        * Lightmap storing color of incoming light.
        */
        public get lightmapColor(): Texture2D;
        public set lightmapColor(value: Texture2D);
        /**
        * Lightmap storing dominant direction of incoming light.
        */
        public get lightmapDir(): Texture2D;
        public set lightmapDir(value: Texture2D);
        /**
        * Texture storing occlusion mask per light (ShadowMask, up to four lights).
        */
        public get shadowMask(): Texture2D;
        public set shadowMask(value: Texture2D);

        public constructor ()
    }

    /**
    * Class that represents textures in C# code.
    */
    class Texture2D extends Texture {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
        */
        public static GenerateAllMips : int
        /**
        * How many mipmap levels are in this Texture (Read Only).
        */
        public get mipmapCount(): int;
        public static get anisotropicFiltering(): AnisotropicFiltering;
        public static set anisotropicFiltering(value: AnisotropicFiltering);
        /**
        * Returns the GraphicsFormat format or color format of a Texture object.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
        * Width of the Texture in pixels (Read Only).
        */
        public get width(): int;
        public set width(value: int);
        /**
        * Height of the Texture in pixels (Read Only).
        */
        public get height(): int;
        public set height(value: int);
        /**
        * Dimensionality (type) of the Texture (Read Only).
        */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
        * Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
        */
        public get isReadable(): boolean;
        /**
        * Texture coordinate wrapping mode.
        */
        public get wrapMode(): TextureWrapMode;
        public set wrapMode(value: TextureWrapMode);
        /**
        * Texture U coordinate wrapping mode.
        */
        public get wrapModeU(): TextureWrapMode;
        public set wrapModeU(value: TextureWrapMode);
        /**
        * Texture V coordinate wrapping mode.
        */
        public get wrapModeV(): TextureWrapMode;
        public set wrapModeV(value: TextureWrapMode);
        /**
        * Texture W coordinate wrapping mode for Texture3D.
        */
        public get wrapModeW(): TextureWrapMode;
        public set wrapModeW(value: TextureWrapMode);
        /**
        * Filtering mode of the Texture.
        */
        public get filterMode(): FilterMode;
        public set filterMode(value: FilterMode);
        /**
        * Defines the anisotropic filtering level of the Texture.
        */
        public get anisoLevel(): int;
        public set anisoLevel(value: int);
        /**
        * The mipmap bias of the Texture.
        */
        public get mipMapBias(): float;
        public set mipMapBias(value: float);
        public get texelSize(): Vector2;
        /**
        * This counter is incremented when the Texture is updated.
        */
        public get updateCount(): uint;
        /**
        * Returns true if the texture pixel data is in sRGB color space (Read Only).
        */
        public get isDataSRGB(): boolean;
        /**
        * The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0.
        * This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually.
        * To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`.
        * `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get totalTextureMemory(): bigint;
        /**
        * The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.
        * For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.
        * The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
        */
        public static get desiredTextureMemory(): bigint;
        /**
        * The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get targetTextureMemory(): bigint;
        /**
        * The amount of memory that all Textures in the scene use.
        */
        public static get currentTextureMemory(): bigint;
        /**
        * The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureMemory(): bigint;
        /**
        * How many times has a Texture been uploaded due to Texture mipmap streaming.
        */
        public static get streamingMipmapUploadCount(): bigint;
        /**
        * Number of renderers registered with the Texture streaming system.
        */
        public static get streamingRendererCount(): bigint;
        /**
        * Number of streaming Textures.
        */
        public static get streamingTextureCount(): bigint;
        /**
        * The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureCount(): bigint;
        /**
        * Number of streaming Textures with outstanding mipmaps to be loaded.
        */
        public static get streamingTexturePendingLoadCount(): bigint;
        /**
        * Number of streaming Textures with mipmaps currently loading.
        */
        public static get streamingTextureLoadingCount(): bigint;
        /**
        * Force streaming Textures to load all mipmap levels.
        */
        public static get streamingTextureForceLoadAll(): boolean;
        public static set streamingTextureForceLoadAll(value: boolean);
        /**
        * This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
        */
        public static get streamingTextureDiscardUnusedMips(): boolean;
        public static set streamingTextureDiscardUnusedMips(value: boolean);
        /**
        * Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
        */
        public static get allowThreadedTextureCreation(): boolean;
        public static set allowThreadedTextureCreation(value: boolean);
        /**
        * The format of the pixel data in the texture (Read Only).
        */
        public get format(): TextureFormat;
        /**
        * This property causes a texture to ignore all texture mipmap limit settings.
        */
        public get ignoreMipmapLimit(): boolean;
        public set ignoreMipmapLimit(value: boolean);
        /**
        * The name of the texture mipmap limit group that this texture is associated with. (Read Only)
        */
        public get mipmapLimitGroup(): string;
        /**
        * The number of high resolution mipmap levels from the texture that Unity doesn't upload to the GPU. (Read Only)
        */
        public get activeMipmapLimit(): int;
        /**
        * Gets a small Texture with all white pixels.
        */
        public static get whiteTexture(): Texture2D;
        /**
        * Gets a small Texture with all black pixels.
        */
        public static get blackTexture(): Texture2D;
        /**
        * Gets a small Texture with all red pixels.
        */
        public static get redTexture(): Texture2D;
        /**
        * Gets a small Texture with all gray pixels.
        */
        public static get grayTexture(): Texture2D;
        /**
        * Gets a small Texture with all gray pixels.
        */
        public static get linearGrayTexture(): Texture2D;
        /**
        * Gets a small Texture with pixels that represent surface normal vectors at a neutral position.
        */
        public static get normalTexture(): Texture2D;
        /**
        * Returns true if the VTOnly checkbox was checked when the texture was imported; otherwise returns false. For additional information, see TextureImporter.vtOnly.
        */
        public get vtOnly(): boolean;
        /**
        * Determines whether mipmap streaming is enabled for this Texture.
        */
        public get streamingMipmaps(): boolean;
        /**
        * Sets the relative priority for this Texture when reducing memory size to fit within the memory budget.
        */
        public get streamingMipmapsPriority(): int;
        /**
        * The mipmap level to load.
        */
        public get requestedMipmapLevel(): int;
        public set requestedMipmapLevel(value: int);
        /**
        * Restricts the mipmap streaming system to a minimum mip level for this Texture.
        */
        public get minimumMipmapLevel(): int;
        public set minimumMipmapLevel(value: int);
        /**
        * The mipmap level calculated by the streaming system, which takes into account the streaming Cameras and the location of the objects containing this Texture. This is unaffected by requestedMipmapLevel or minimumMipmapLevel.
        */
        public get calculatedMipmapLevel(): int;
        /**
        * The mipmap level that the streaming system would load before memory budgets are applied.
        */
        public get desiredMipmapLevel(): int;
        /**
        * The mipmap level that the mipmap streaming system is in the process of loading.
        */
        public get loadingMipmapLevel(): int;
        /**
        * The mipmap level that is currently loaded by the streaming system.
        */
        public get loadedMipmapLevel(): int;

        public constructor ($width: int, $height: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $height: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $mipCount: int, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $height: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $mipCount: int, $mipmapLimitGroupName: string, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $height: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $height: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: int, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $height: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: int, $mipmapLimitGroupName: string, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        /**
        * Create a new empty texture.
        */
        public constructor ($width: int, $height: int, $textureFormat: TextureFormat, $mipCount: int, $linear: boolean)
        /**
        * Create a new empty texture.
        */
        public constructor ($width: int, $height: int, $textureFormat: TextureFormat, $mipCount: int, $linear: boolean, $createUninitialized: boolean)
        public constructor ($width: int, $height: int, $textureFormat: TextureFormat, $mipCount: int, $linear: boolean, $createUninitialized: boolean, $ignoreMipmapLimit: boolean, $mipmapLimitGroupName: string)
        /**
        * Create a new empty texture.
        */
        public constructor ($width: int, $height: int, $textureFormat: TextureFormat, $mipChain: boolean, $linear: boolean)
        /**
        * Create a new empty texture.
        */
        public constructor ($width: int, $height: int, $textureFormat: TextureFormat, $mipChain: boolean, $linear: boolean, $createUninitialized: boolean)
        /**
        * Create a new empty texture.
        */
        public constructor ($width: int, $height: int, $textureFormat: TextureFormat, $mipChain: boolean)
        /**
        * Create a new empty texture.
        */
        public constructor ($width: int, $height: int)
        /**
        * Compress texture at runtime to DXT/BCn or ETC formats.
        */
        public Compress ($highQuality: boolean) : void
        /**
        * Resets the requestedMipmapLevel field.
        */
        public ClearRequestedMipmapLevel () : void
        /**
        * Checks to see whether the mipmap level set by requestedMipmapLevel has finished loading.
        * @returns True if the mipmap level requested by requestedMipmapLevel has finished loading.
        */
        public IsRequestedMipmapLevelLoaded () : boolean
        /**
        * Resets the minimumMipmapLevel field.
        */
        public ClearMinimumMipmapLevel () : void
        /**
        * Updates Unity texture to use different native texture object.
        * @param nativeTex Native 2D texture object.
        */
        public UpdateExternalTexture ($nativeTex: System.IntPtr) : void
        /**
        * Gets the raw data from a texture, as a copy.
        * @returns A byte array that contains raw texture data.
        */
        public GetRawTextureData () : byte[]
        /**
        * Gets the pixel color data for part of a mipmap level as Color structs.
        * @param x The starting x position of the section to fetch.
        * @param y The starting y position of the section to fetch.
        * @param blockWidth The width of the section to fetch.
        * @param blockHeight The height of the section to fetch.
        * @param miplevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels_EBB7509C_EE96822
        */
        public GetPixels ($x: int, $y: int, $blockWidth: int, $blockHeight: int, $miplevel: int) : Color[]
        /**
        * Gets the pixel color data for part of a mipmap level as Color structs.
        * @param x The starting x position of the section to fetch.
        * @param y The starting y position of the section to fetch.
        * @param blockWidth The width of the section to fetch.
        * @param blockHeight The height of the section to fetch.
        * @param miplevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels_EBB7509C_H7CC42739
        */
        public GetPixels ($x: int, $y: int, $blockWidth: int, $blockHeight: int) : Color[]
        /**
        * Gets the pixel color data for a mipmap level as Color32 structs.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels32_EBB7509C_F92D023A
        */
        public GetPixels32 ($miplevel: int) : Color32[]
        public GetPixels32 () : Color32[]
        /**
        * Packs multiple Textures into a texture atlas.
        * @param textures Array of textures to pack into the atlas.
        * @param padding Padding in pixels between the packed textures.
        * @param maximumAtlasSize Maximum size of the resulting texture.
        * @param makeNoLongerReadable Should the texture be marked as no longer readable?
        * @returns An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails.
        * @methodSwap PackTextures_EBB7509C_H10A0654
        */
        public PackTextures ($textures: Texture2D[], $padding: int, $maximumAtlasSize: int, $makeNoLongerReadable: boolean) : Rect[]
        /**
        * @methodSwap PackTextures_EBB7509C_H1D08AF73
        */
        public PackTextures ($textures: Texture2D[], $padding: int, $maximumAtlasSize: int) : Rect[]
        /**
        * @methodSwap PackTextures_EBB7509C_H36977700
        */
        public PackTextures ($textures: Texture2D[], $padding: int) : Rect[]
        /**
        * Creates a Unity Texture out of an externally created native texture object.
        * @param nativeTex Native 2D texture object.
        * @param width Width of texture in pixels.
        * @param height Height of texture in pixels.
        * @param format Format of underlying texture object.
        * @param mipmap Does the texture have mipmaps?
        * @param linear Is texture using linear color space?
        */
        public static CreateExternalTexture ($width: int, $height: int, $format: TextureFormat, $mipChain: boolean, $linear: boolean, $nativeTex: System.IntPtr) : Texture2D
        /**
        * Sets the pixel color at coordinates (x,y).
        * @param x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
        * @param y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
        * @param color The color to set.
        * @param mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixel_EBB7509C_CE85301
        */
        public SetPixel ($x: int, $y: int, $color: Color) : void
        /**
        * Sets the pixel color at coordinates (x,y).
        * @param x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
        * @param y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
        * @param color The color to set.
        * @param mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixel_EBB7509C_H6836546A
        */
        public SetPixel ($x: int, $y: int, $color: Color, $mipLevel: int) : void
        /**
        * Sets the pixel colors of part of a mipmap level.
        * @param x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
        * @param y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
        * @param blockWidth The width of the block of pixels to set.
        * @param blockHeight The height of the block of pixels to set.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels_EBB7509C_H9F0CB3A6
        */
        public SetPixels ($x: int, $y: int, $blockWidth: int, $blockHeight: int, $colors: Color[], $miplevel: int) : void
        /**
        * @methodSwap SetPixels_EBB7509C_A02751E5
        */
        public SetPixels ($x: int, $y: int, $blockWidth: int, $blockHeight: int, $colors: Color[]) : void
        /**
        * Sets the pixel colors of an entire mipmap level.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels_EBB7509C_H813F99E
        */
        public SetPixels ($colors: Color[], $miplevel: int) : void
        public SetPixels ($colors: Color[]) : void
        /**
        * Gets the pixel color at coordinates (x, y).
        * @param x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
        * @param y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
        * @param mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns The pixel color.
        * @methodSwap GetPixel_EBB7509C_H2CFB2EE5
        */
        public GetPixel ($x: int, $y: int) : Color
        /**
        * Gets the pixel color at coordinates (x, y).
        * @param x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
        * @param y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
        * @param mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns The pixel color.
        * @methodSwap GetPixel_EBB7509C_H71E348A6
        */
        public GetPixel ($x: int, $y: int, $mipLevel: int) : Color
        /**
        * Gets the filtered pixel color at the normalized coordinates (u, v).
        * @param u The u coordinate of the pixel to get.
        * @param v The v coordinate of the pixel to get.
        * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns The pixel color.
        * @methodSwap GetPixelBilinear_EBB7509C_H1075CF37
        */
        public GetPixelBilinear ($u: float, $v: float) : Color
        /**
        * Gets the filtered pixel color at the normalized coordinates (u, v).
        * @param u The u coordinate of the pixel to get.
        * @param v The v coordinate of the pixel to get.
        * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns The pixel color.
        * @methodSwap GetPixelBilinear_EBB7509C_F41D0090
        */
        public GetPixelBilinear ($u: float, $v: float, $mipLevel: int) : Color
        /**
        * Sets the raw data of an entire texture in CPU memory.
        * @param data The array of data to use.
        * @param size The size of the data in bytes.
        * @methodSwap LoadRawTextureData_EBB7509C_H75650664
        */
        public LoadRawTextureData ($data: System.IntPtr, $size: int) : void
        /**
        * Sets the raw data of an entire texture in CPU memory.
        * @param data The array of data to use.
        * @param size The size of the data in bytes.
        */
        public LoadRawTextureData ($data: byte[]) : void
        public LoadRawTextureData<T> ($data: Unity_Collections.NativeArray$1<T>) : void
        /**
        * @methodSwap SetPixelData_EBB7509C_D5108AF9
        */
        public SetPixelData<T> ($data: T[], $mipLevel: int, $sourceDataStartIndex?: int) : void
        /**
        * @methodSwap SetPixelData_EBB7509C_H51A2967A
        */
        public SetPixelData<T> ($data: Unity_Collections.NativeArray$1<T>, $mipLevel: int, $sourceDataStartIndex?: int) : void
        /**
        * Gets the raw data from a texture.
        * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns A native array that points directly to the texture's data buffer in CPU memory.
        */
        public GetPixelData<T> ($mipLevel: int) : Unity_Collections.NativeArray$1<T>
        /**
        * Gets the raw data from a texture, as a copy.
        * @returns A byte array that contains raw texture data.
        */
        public GetRawTextureData<T> () : Unity_Collections.NativeArray$1<T>
        /**
        * Copies changes you've made in a CPU texture to the GPU.
        * @param updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
        * @param makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
        */
        public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
        public Apply ($updateMipmaps: boolean) : void
        public Apply () : void
        /**
        * Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
        * @param width New width of the Texture.
        * @param height New height of the Texture.
        * @param format New format of the Texture.
        * @param hasMipMap Indicates if the Texture should reserve memory for a full mip map chain.
        * @returns Returns true if the reinitialization was a success.
        * @methodSwap Reinitialize_EBB7509C_H2CFB2EE5
        */
        public Reinitialize ($width: int, $height: int) : boolean
        /**
        * Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
        * @param width New width of the Texture.
        * @param height New height of the Texture.
        * @param format New format of the Texture.
        * @param hasMipMap Indicates if the Texture should reserve memory for a full mip map chain.
        * @returns Returns true if the reinitialization was a success.
        * @methodSwap Reinitialize_EBB7509C_AC779B9D
        */
        public Reinitialize ($width: int, $height: int, $format: TextureFormat, $hasMipMap: boolean) : boolean
        /**
        * Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
        * @param width New width of the Texture.
        * @param height New height of the Texture.
        * @param format New format of the Texture.
        * @param hasMipMap Indicates if the Texture should reserve memory for a full mip map chain.
        * @returns Returns true if the reinitialization was a success.
        * @methodSwap Reinitialize_EBB7509C_H7065FDC9
        */
        public Reinitialize ($width: int, $height: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $hasMipMap: boolean) : boolean
        /**
        * Reads pixels from the current render target and writes them to a texture.
        * @param source The region of the render target to read from.
        * @param destX The x position in the texture to write the pixels to.
        * @param destY The y position in the texture to write the pixels to.
        * @param recalculateMipMaps When the value is true, Unity automatically recalculates the mipmap for the texture after it writes the pixel data. Otherwise, Unity doesn't do this automatically.
        * @methodSwap ReadPixels_EBB7509C_H7E4D9907
        */
        public ReadPixels ($source: Rect, $destX: int, $destY: int, $recalculateMipMaps: boolean) : void
        /**
        * @methodSwap ReadPixels_EBB7509C_E8D347AC
        */
        public ReadPixels ($source: Rect, $destX: int, $destY: int) : void
        public static GenerateAtlas ($sizes: Vector2[], $padding: int, $atlasSize: int, $results: System_Collections_Generic.List$1<Rect>) : boolean
        /**
        * Sets the pixel colors of an entire mipmap level.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels32_EBB7509C_H74E0DA77
        */
        public SetPixels32 ($colors: Color32[], $miplevel: int) : void
        /**
        * Sets the pixel colors of an entire mipmap level.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        */
        public SetPixels32 ($colors: Color32[]) : void
        /**
        * Sets the pixel colors of part of a mipmap level.
        * @param x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
        * @param y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
        * @param blockWidth The width of the block of pixels to set.
        * @param blockHeight The height of the block of pixels to set.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels32_EBB7509C_H6543ACBF
        */
        public SetPixels32 ($x: int, $y: int, $blockWidth: int, $blockHeight: int, $colors: Color32[], $miplevel: int) : void
        /**
        * Sets the pixel colors of part of a mipmap level.
        * @param x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
        * @param y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
        * @param blockWidth The width of the block of pixels to set.
        * @param blockHeight The height of the block of pixels to set.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels32_EBB7509C_H37DACA24
        */
        public SetPixels32 ($x: int, $y: int, $blockWidth: int, $blockHeight: int, $colors: Color32[]) : void
        /**
        * Gets the pixel color data for a mipmap level as Color structs.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels_EBB7509C_F92D023A
        */
        public GetPixels ($miplevel: int) : Color[]
        public GetPixels () : Color[]
        public constructor ()
    }

    /**
    * Stores lightmaps of the Scene.
    */
    class LightmapSettings extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Lightmap array.
        */
        public static get lightmaps(): LightmapData[];
        public static set lightmaps(value: LightmapData[]);
        /**
        * NonDirectional or CombinedDirectional Specular lightmaps rendering mode.
        */
        public static get lightmapsMode(): LightmapsMode;
        public static set lightmapsMode(value: LightmapsMode);
        /**
        * Baked Light Probe data.
        */
        public static get lightProbes(): LightProbes;
        public static set lightProbes(value: LightProbes);

    }

    /**
    * Lightmap (and lighting) configuration mode, controls how lightmaps interact with lighting and what kind of information they store.
    */
    enum LightmapsMode {
        NonDirectional = 0,
        CombinedDirectional = 1,
        SeparateDirectional = 2,
        Single = 0,
        Dual = 1,
        Directional = 2 
    }

    /**
    * Stores light probe data for all currently loaded Scenes.
    */
    class LightProbes extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Positions of the baked light probes (Read Only).
        */
        public get positions(): Vector3[];
        /**
        * Coefficients of baked light probes.
        */
        public get bakedProbes(): UnityEngine_Rendering.SphericalHarmonicsL2[];
        public set bakedProbes(value: UnityEngine_Rendering.SphericalHarmonicsL2[]);
        /**
        * The number of light probes (Read Only).
        */
        public get count(): int;
        /**
        * The number of cells space is divided into (Read Only).
        */
        public get cellCount(): int;

        /**
        * Synchronously tetrahedralize the currently loaded LightProbe positions.
        */
        public static Tetrahedralize () : void
        /**
        * Asynchronously tetrahedralize all currently loaded LightProbe positions.
        */
        public static TetrahedralizeAsync () : void
        /**
        * Returns an interpolated probe for the given position for both real-time and baked light probes combined.
        */
        public static GetInterpolatedProbe ($position: Vector3, $renderer: Renderer, $probe: $Ref<UnityEngine_Rendering.SphericalHarmonicsL2>) : void
        /**
        * Calculate light probes and occlusion probes at the given world space positions.
        * @param positions The array of world space positions used to evaluate the probes.
        * @param lightProbes The array where the resulting light probes are written to.
        * @param occlusionProbes The array where the resulting occlusion probes are written to.
        */
        public static CalculateInterpolatedLightAndOcclusionProbes ($positions: Vector3[], $lightProbes: UnityEngine_Rendering.SphericalHarmonicsL2[], $occlusionProbes: Vector4[]) : void
        public static CalculateInterpolatedLightAndOcclusionProbes ($positions: System_Collections_Generic.List$1<Vector3>, $lightProbes: System_Collections_Generic.List$1<UnityEngine_Rendering.SphericalHarmonicsL2>, $occlusionProbes: System_Collections_Generic.List$1<Vector4>) : void
        public static add_lightProbesUpdated ($value: System.Action) : void
        public static add_tetrahedralizationCompleted ($value: System.Action) : void
        public static add_needsRetetrahedralization ($value: System.Action) : void
        public static remove_lightProbesUpdated ($value: System.Action) : void
        public static remove_tetrahedralizationCompleted ($value: System.Action) : void
        public static remove_needsRetetrahedralization ($value: System.Action) : void
    }

    /**
    * Provides access to HDR display settings and information.
    */
    class HDROutputSettings extends System.Object {

        /**
        * The list of currently connected displays with possible HDR availability.
        */
        public static displays : HDROutputSettings[]
        /**
        * The HDROutputSettings for the main display.
        */
        public static get main(): HDROutputSettings;
        /**
        * Describes whether HDR output is currently active on the display. It is true if this is the case, and @@false@ otherwise.
        */
        public get active(): boolean;
        /**
        * Describes whether HDR is currently available on your primary display and that you have HDR enabled in your Unity Project. It is true if this is the case, and false otherwise.
        */
        public get available(): boolean;
        /**
        * Describes whether Unity performs HDR tonemapping automatically.
        */
        public get automaticHDRTonemapping(): boolean;
        public set automaticHDRTonemapping(value: boolean);
        /**
        * The ColorGamut used to output to the active HDR display.
        */
        public get displayColorGamut(): ColorGamut;
        /**
        * The RenderTextureFormat of the display buffer for the active HDR display.
        */
        public get format(): RenderTextureFormat;
        /**
        * The Experimental.Rendering.GraphicsFormat of the display buffer for the active HDR display.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
        * The base luminance of a white paper surface in nits or candela per square meter (cd/m2).
        */
        public get paperWhiteNits(): float;
        public set paperWhiteNits(value: float);
        /**
        * Maximum input luminance at which gradation is preserved even when the entire screen is bright.
        */
        public get maxFullFrameToneMapLuminance(): int;
        /**
        * Maximum input luminance at which gradation is preserved when 10% of the screen is bright.
        */
        public get maxToneMapLuminance(): int;
        /**
        * Minimum input luminance at which gradation is identifiable.
        */
        public get minToneMapLuminance(): int;
        /**
        * Describes whether the user has requested to change the HDR Output Mode. It is true if this is the case, and false otherwise.
        */
        public get HDRModeChangeRequested(): boolean;

        /**
        * Use this function to request a change in the HDR Output Mode and in the value of HDROutputSettings.active.
        * @param enabled Indicates whether HDR should be enabled.
        */
        public RequestHDRModeChange ($enabled: boolean) : void
    }

    /**
    * Utility class to query properties of a ColorGamut.
    */
    class ColorGamutUtility extends System.Object {

        public constructor ()
        /**
        * Returns the color primaries mapped to the color space used by the given gamut.
        * @param gamut The color gamut to look up.
        * @returns Color primaries for the given gamut.
        */
        public static GetColorPrimaries ($gamut: ColorGamut) : ColorPrimaries
        /**
        * Returns the white point that the given gamut uses.
        * @param gamut The color gamut to look up.
        * @returns The white point that the given gamut uses.
        */
        public static GetWhitePoint ($gamut: ColorGamut) : WhitePoint
        /**
        * Returns the transfer function that the given gamut uses on the current platform.
        * @param gamut The color gamut to look up.
        * @returns The transfer function that the given gamut uses.
        */
        public static GetTransferFunction ($gamut: ColorGamut) : TransferFunction
    }

    /**
    * Represents a color space based on its set of red, green, and blue color primaries.
    */
    enum ColorPrimaries {
        Unknown = -1,
        Rec709 = 0,
        Rec2020 = 1,
        P3 = 2 
    }

    /**
    * The reference white point of a color space.
    */
    enum WhitePoint {
        Unknown = -1,
        D65 = 0 
    }

    /**
    * Contains electro-optical transfer function options.
    */
    enum TransferFunction {
        Unknown = -1,
        sRGB = 0,
        BT1886 = 1,
        PQ = 2,
        Linear = 3,
        Gamma22 = 4 
    }

    /**
    * Extension methods to the Renderer class, used only for the UpdateGIMaterials method used by the Global Illumination System.
    */
    class RendererExtensions {

        /**
        * Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
        */
        public static UpdateGIMaterials ($renderer: Renderer) : void
    }

    /**
    * A script interface for a.
    */
    class Projector extends Behaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;
        /**
        * The near clipping plane distance.
        */
        public get nearClipPlane(): float;
        public set nearClipPlane(value: float);
        /**
        * The far clipping plane distance.
        */
        public get farClipPlane(): float;
        public set farClipPlane(value: float);
        /**
        * The field of view of the projection in degrees.
        */
        public get fieldOfView(): float;
        public set fieldOfView(value: float);
        /**
        * The aspect ratio of the projection.
        */
        public get aspectRatio(): float;
        public set aspectRatio(value: float);
        /**
        * Is the projection orthographic (true) or perspective (false)?
        */
        public get orthographic(): boolean;
        public set orthographic(value: boolean);
        /**
        * Projection's half-size when in orthographic mode.
        */
        public get orthographicSize(): float;
        public set orthographicSize(value: float);
        /**
        * Which object layers are ignored by the projector.
        */
        public get ignoreLayers(): int;
        public set ignoreLayers(value: int);
        /**
        * The material that will be projected onto every object.
        */
        public get material(): Material;
        public set material(value: Material);

        private constructor ()
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * Single, dual, or directional lightmaps rendering mode, used only in GIWorkflowMode.Legacy
    */
    enum LightmapsModeLegacy {
        Single = 0,
        Dual = 1,
        Directional = 2 
    }

    /**
    * The trail renderer is used to make trails behind objects in the Scene as they move about.
    */
    class TrailRenderer extends Renderer {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * The bounding box of the renderer in world space.
        */
        public get bounds(): Bounds;
        public set bounds(value: Bounds);
        /**
        * The bounding box of the renderer in local space.
        */
        public get localBounds(): Bounds;
        public set localBounds(value: Bounds);
        /**
        * Makes the rendered 3D object visible if enabled.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Is this renderer visible in any camera? (Read Only)
        */
        public get isVisible(): boolean;
        /**
        * Does this object cast shadows?
        */
        public get shadowCastingMode(): UnityEngine_Rendering.ShadowCastingMode;
        public set shadowCastingMode(value: UnityEngine_Rendering.ShadowCastingMode);
        /**
        * Does this object receive shadows?
        */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
        * Allows turning off rendering for a specific component.
        */
        public get forceRenderingOff(): boolean;
        public set forceRenderingOff(value: boolean);
        /**
        * Is this renderer a static shadow caster?
        */
        public get staticShadowCaster(): boolean;
        public set staticShadowCaster(value: boolean);
        /**
        * Specifies the mode for motion vector rendering.
        */
        public get motionVectorGenerationMode(): MotionVectorGenerationMode;
        public set motionVectorGenerationMode(value: MotionVectorGenerationMode);
        /**
        * The light probe interpolation type.
        */
        public get lightProbeUsage(): UnityEngine_Rendering.LightProbeUsage;
        public set lightProbeUsage(value: UnityEngine_Rendering.LightProbeUsage);
        /**
        * Should reflection probes be used for this Renderer?
        */
        public get reflectionProbeUsage(): UnityEngine_Rendering.ReflectionProbeUsage;
        public set reflectionProbeUsage(value: UnityEngine_Rendering.ReflectionProbeUsage);
        /**
        * Determines which rendering layer this renderer lives on, if you use a.
        */
        public get renderingLayerMask(): uint;
        public set renderingLayerMask(value: uint);
        /**
        * This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
        */
        public get rendererPriority(): int;
        public set rendererPriority(value: int);
        /**
        * Describes how this renderer is updated for ray tracing.
        */
        public get rayTracingMode(): UnityEngine_Experimental_Rendering.RayTracingMode;
        public set rayTracingMode(value: UnityEngine_Experimental_Rendering.RayTracingMode);
        /**
        * Name of the Renderer's sorting layer.
        */
        public get sortingLayerName(): string;
        public set sortingLayerName(value: string);
        /**
        * Unique ID of the Renderer's sorting layer.
        */
        public get sortingLayerID(): int;
        public set sortingLayerID(value: int);
        /**
        * Renderer's order within a sorting layer.
        */
        public get sortingOrder(): int;
        public set sortingOrder(value: int);
        /**
        * Controls if dynamic occlusion culling should be performed for this renderer.
        */
        public get allowOcclusionWhenDynamic(): boolean;
        public set allowOcclusionWhenDynamic(value: boolean);
        /**
        * Indicates whether the renderer is part of a with other renderers.
        */
        public get isPartOfStaticBatch(): boolean;
        /**
        * Matrix that transforms a point from world space into local space (Read Only).
        */
        public get worldToLocalMatrix(): Matrix4x4;
        /**
        * Matrix that transforms a point from local space into world space (Read Only).
        */
        public get localToWorldMatrix(): Matrix4x4;
        /**
        * If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
        */
        public get lightProbeProxyVolumeOverride(): GameObject;
        public set lightProbeProxyVolumeOverride(value: GameObject);
        /**
        * If set, Renderer will use this Transform's position to find the light or reflection probe.
        */
        public get probeAnchor(): Transform;
        public set probeAnchor(value: Transform);
        /**
        * The index of the baked lightmap applied to this renderer.
        */
        public get lightmapIndex(): int;
        public set lightmapIndex(value: int);
        /**
        * The index of the real-time lightmap applied to this renderer.
        */
        public get realtimeLightmapIndex(): int;
        public set realtimeLightmapIndex(value: int);
        /**
        * The UV scale & offset used for a lightmap.
        */
        public get lightmapScaleOffset(): Vector4;
        public set lightmapScaleOffset(value: Vector4);
        /**
        * The UV scale & offset used for a real-time lightmap.
        */
        public get realtimeLightmapScaleOffset(): Vector4;
        public set realtimeLightmapScaleOffset(value: Vector4);
        /**
        * Returns all the instantiated materials of this object.
        */
        public get materials(): Material[];
        public set materials(value: Material[]);
        /**
        * Returns the first instantiated Material assigned to the renderer.
        */
        public get material(): Material;
        public set material(value: Material);
        /**
        * The shared material of this object.
        */
        public get sharedMaterial(): Material;
        public set sharedMaterial(value: Material);
        /**
        * All the shared materials of this object.
        */
        public get sharedMaterials(): Material[];
        public set sharedMaterials(value: Material[]);
        /**
        * How long does the trail take to fade out.
        */
        public get time(): float;
        public set time(value: float);
        /**
        * The width of the trail at the spawning point.
        */
        public get startWidth(): float;
        public set startWidth(value: float);
        /**
        * The width of the trail at the end of the trail.
        */
        public get endWidth(): float;
        public set endWidth(value: float);
        /**
        * Set an overall multiplier that is applied to the TrailRenderer.widthCurve to get the final width of the trail.
        */
        public get widthMultiplier(): float;
        public set widthMultiplier(value: float);
        /**
        * Does the GameObject of this Trail Renderer auto destruct?
        */
        public get autodestruct(): boolean;
        public set autodestruct(value: boolean);
        /**
        * Creates trails when the GameObject moves.
        */
        public get emitting(): boolean;
        public set emitting(value: boolean);
        /**
        * Set this to a value greater than 0, to get rounded corners between each segment of the trail.
        */
        public get numCornerVertices(): int;
        public set numCornerVertices(value: int);
        /**
        * Set this to a value greater than 0, to get rounded corners on each end of the trail.
        */
        public get numCapVertices(): int;
        public set numCapVertices(value: int);
        /**
        * Set the minimum distance the trail can travel before a new vertex is added to it.
        */
        public get minVertexDistance(): float;
        public set minVertexDistance(value: float);
        /**
        * Set the color at the start of the trail.
        */
        public get startColor(): Color;
        public set startColor(value: Color);
        /**
        * Set the color at the end of the trail.
        */
        public get endColor(): Color;
        public set endColor(value: Color);
        /**
        * Get the number of line segments in the trail.
        */
        public get positionCount(): int;
        /**
        * A multiplier for the UV coordinates of the trail texture.
        */
        public get textureScale(): Vector2;
        public set textureScale(value: Vector2);
        /**
        * Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the trail width at each segment.
        */
        public get shadowBias(): float;
        public set shadowBias(value: float);
        /**
        * Configures a trail to generate Normals and Tangents. With this data, Scene lighting can affect the trail via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.
        */
        public get generateLightingData(): boolean;
        public set generateLightingData(value: boolean);
        /**
        * Choose whether the U coordinate of the trail texture is tiled or stretched.
        */
        public get textureMode(): LineTextureMode;
        public set textureMode(value: LineTextureMode);
        /**
        * Select whether the trail will face the camera, or the orientation of the Transform Component.
        */
        public get alignment(): LineAlignment;
        public set alignment(value: LineAlignment);
        /**
        * Specifies how the TrailRenderer interacts with SpriteMask.
        */
        public get maskInteraction(): SpriteMaskInteraction;
        public set maskInteraction(value: SpriteMaskInteraction);
        /**
        * Set the curve describing the width of the trail at various points along its length.
        */
        public get widthCurve(): AnimationCurve;
        public set widthCurve(value: AnimationCurve);
        /**
        * Set the color gradient describing the color of the trail at various points along its length.
        */
        public get colorGradient(): Gradient;
        public set colorGradient(value: Gradient);

        private constructor ()
        /**
        * Set the position of a vertex in the trail.
        * @param index Which position to set.
        * @param position The new position.
        */
        public SetPosition ($index: int, $position: Vector3) : void
        /**
        * Get the position of a vertex in the trail.
        * @param index The index of the position to retrieve.
        * @returns The position at the specified index in the array.
        */
        public GetPosition ($index: int) : Vector3
        /**
        * Removes all points from the TrailRenderer.
        * Useful for restarting a trail from a new position.
        */
        public Clear () : void
        /**
        * Creates a snapshot of TrailRenderer and stores it in mesh.
        * @param mesh A static mesh that will receive the snapshot of the trail.
        * @param camera The camera used for determining which way camera-space trails will face.
        * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
        */
        public BakeMesh ($mesh: Mesh, $useTransform?: boolean) : void
        /**
        * Creates a snapshot of TrailRenderer and stores it in mesh.
        * @param mesh A static mesh that will receive the snapshot of the trail.
        * @param camera The camera used for determining which way camera-space trails will face.
        * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
        */
        public BakeMesh ($mesh: Mesh, $camera: Camera, $useTransform?: boolean) : void
        /**
        * Get the positions of all vertices in the trail.
        * @param positions The array of positions to retrieve.
        * @returns How many positions were actually stored in the output array.
        */
        public GetPositions ($positions: Vector3[]) : int
        /**
        * Get the visible positions of all vertices in the trail.
        * @param positions The array of positions to retrieve.
        * @returns How many positions were actually stored in the output array.
        */
        public GetVisiblePositions ($positions: Vector3[]) : int
        /**
        * Sets the positions of all vertices in the trail.
        * @param positions The array of positions to set.
        */
        public SetPositions ($positions: Vector3[]) : void
        /**
        * Adds a position to the trail.
        * @param position The position to add to the trail.
        */
        public AddPosition ($position: Vector3) : void
        /**
        * Add an array of positions to the trail.
        * @param positions The positions to add to the trail.
        */
        public AddPositions ($positions: Vector3[]) : void
        public SetPositions ($positions: Unity_Collections.NativeArray$1<Vector3>) : void
        public SetPositions ($positions: Unity_Collections.NativeSlice$1<Vector3>) : void
        public GetPositions ($positions: Unity_Collections.NativeArray$1<Vector3>) : int
        public GetPositions ($positions: Unity_Collections.NativeSlice$1<Vector3>) : int
        public GetVisiblePositions ($positions: Unity_Collections.NativeArray$1<Vector3>) : int
        public GetVisiblePositions ($positions: Unity_Collections.NativeSlice$1<Vector3>) : int
        public AddPositions ($positions: Unity_Collections.NativeArray$1<Vector3>) : void
        public AddPositions ($positions: Unity_Collections.NativeSlice$1<Vector3>) : void
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * Choose how textures are applied to Lines and Trails.
    */
    enum LineTextureMode {
        Stretch = 0,
        Tile = 1,
        DistributePerSegment = 2,
        RepeatPerSegment = 3,
        Static = 4 
    }

    /**
    * Control the direction lines face, when using the LineRenderer or TrailRenderer.
    */
    enum LineAlignment {
        View = 0,
        Local = 1,
        TransformZ = 1 
    }

    /**
    * This enum controls the mode under which the sprite will interact with the masking system.
    */
    enum SpriteMaskInteraction {
        None = 0,
        VisibleInsideMask = 1,
        VisibleOutsideMask = 2 
    }

    /**
    * Represents a Gradient used for animating colors.
    */
    class Gradient extends System.Object implements System.IEquatable$1<Gradient> {

        /**
        * All color keys defined in the gradient.
        */
        public get colorKeys(): GradientColorKey[];
        public set colorKeys(value: GradientColorKey[]);
        /**
        * All alpha keys defined in the gradient.
        */
        public get alphaKeys(): GradientAlphaKey[];
        public set alphaKeys(value: GradientAlphaKey[]);
        /**
        * Controls how the gradient colors are interpolated.
        */
        public get mode(): GradientMode;
        public set mode(value: GradientMode);
        /**
        * Indicates the color space that the gradient color keys are using.
        */
        public get colorSpace(): ColorSpace;
        public set colorSpace(value: ColorSpace);

        /**
        * Create a new Gradient object.
        */
        public constructor ()
        /**
        * Calculate color at a given time.
        * @param time Time of the evaluation (0 - 1).
        */
        public Evaluate ($time: float) : Color
        /**
        * Setup Gradient with an array of color keys and alpha keys.
        * @param colorKeys Color keys of the gradient (maximum 8 color keys).
        * @param alphaKeys Alpha keys of the gradient (maximum 8 alpha keys).
        */
        public SetKeys ($colorKeys: GradientColorKey[], $alphaKeys: GradientAlphaKey[]) : void
        public Equals ($o: any) : boolean
        public Equals ($other: Gradient) : boolean
        public GetHashCode () : int
    }

    /**
    * Color key used by Gradient.
    */
    class GradientColorKey extends System.ValueType {

        /**
        * Color of key.
        */
        public color : Color
        /**
        * Time of the key (0 - 1).
        */
        public time : float

        /**
        * Gradient color key.
        * @param color Color of key.
        * @param time Time of the key (0 - 1).
        */
        public constructor ($col: Color, $time: float)
    }

    /**
    * Alpha key used by Gradient.
    */
    class GradientAlphaKey extends System.ValueType {

        /**
        * Alpha channel of key.
        */
        public alpha : float
        /**
        * Time of the key (0 - 1).
        */
        public time : float

        /**
        * Gradient alpha key.
        * @param alpha Alpha of key (0 - 1).
        * @param time Time of the key (0 - 1).
        */
        public constructor ($alpha: float, $time: float)
    }

    /**
    * Color interpolation mode used by Gradient.
    */
    enum GradientMode {
        Blend = 0,
        Fixed = 1,
        PerceptualBlend = 2 
    }

    /**
    * Color space for player settings.
    */
    enum ColorSpace {
        Uninitialized = -1,
        Gamma = 0,
        Linear = 1 
    }

    /**
    * The line renderer is used to draw free-floating lines in 3D space.
    */
    class LineRenderer extends Renderer {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * The bounding box of the renderer in world space.
        */
        public get bounds(): Bounds;
        public set bounds(value: Bounds);
        /**
        * The bounding box of the renderer in local space.
        */
        public get localBounds(): Bounds;
        public set localBounds(value: Bounds);
        /**
        * Makes the rendered 3D object visible if enabled.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Is this renderer visible in any camera? (Read Only)
        */
        public get isVisible(): boolean;
        /**
        * Does this object cast shadows?
        */
        public get shadowCastingMode(): UnityEngine_Rendering.ShadowCastingMode;
        public set shadowCastingMode(value: UnityEngine_Rendering.ShadowCastingMode);
        /**
        * Does this object receive shadows?
        */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
        * Allows turning off rendering for a specific component.
        */
        public get forceRenderingOff(): boolean;
        public set forceRenderingOff(value: boolean);
        /**
        * Is this renderer a static shadow caster?
        */
        public get staticShadowCaster(): boolean;
        public set staticShadowCaster(value: boolean);
        /**
        * Specifies the mode for motion vector rendering.
        */
        public get motionVectorGenerationMode(): MotionVectorGenerationMode;
        public set motionVectorGenerationMode(value: MotionVectorGenerationMode);
        /**
        * The light probe interpolation type.
        */
        public get lightProbeUsage(): UnityEngine_Rendering.LightProbeUsage;
        public set lightProbeUsage(value: UnityEngine_Rendering.LightProbeUsage);
        /**
        * Should reflection probes be used for this Renderer?
        */
        public get reflectionProbeUsage(): UnityEngine_Rendering.ReflectionProbeUsage;
        public set reflectionProbeUsage(value: UnityEngine_Rendering.ReflectionProbeUsage);
        /**
        * Determines which rendering layer this renderer lives on, if you use a.
        */
        public get renderingLayerMask(): uint;
        public set renderingLayerMask(value: uint);
        /**
        * This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
        */
        public get rendererPriority(): int;
        public set rendererPriority(value: int);
        /**
        * Describes how this renderer is updated for ray tracing.
        */
        public get rayTracingMode(): UnityEngine_Experimental_Rendering.RayTracingMode;
        public set rayTracingMode(value: UnityEngine_Experimental_Rendering.RayTracingMode);
        /**
        * Name of the Renderer's sorting layer.
        */
        public get sortingLayerName(): string;
        public set sortingLayerName(value: string);
        /**
        * Unique ID of the Renderer's sorting layer.
        */
        public get sortingLayerID(): int;
        public set sortingLayerID(value: int);
        /**
        * Renderer's order within a sorting layer.
        */
        public get sortingOrder(): int;
        public set sortingOrder(value: int);
        /**
        * Controls if dynamic occlusion culling should be performed for this renderer.
        */
        public get allowOcclusionWhenDynamic(): boolean;
        public set allowOcclusionWhenDynamic(value: boolean);
        /**
        * Indicates whether the renderer is part of a with other renderers.
        */
        public get isPartOfStaticBatch(): boolean;
        /**
        * Matrix that transforms a point from world space into local space (Read Only).
        */
        public get worldToLocalMatrix(): Matrix4x4;
        /**
        * Matrix that transforms a point from local space into world space (Read Only).
        */
        public get localToWorldMatrix(): Matrix4x4;
        /**
        * If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
        */
        public get lightProbeProxyVolumeOverride(): GameObject;
        public set lightProbeProxyVolumeOverride(value: GameObject);
        /**
        * If set, Renderer will use this Transform's position to find the light or reflection probe.
        */
        public get probeAnchor(): Transform;
        public set probeAnchor(value: Transform);
        /**
        * The index of the baked lightmap applied to this renderer.
        */
        public get lightmapIndex(): int;
        public set lightmapIndex(value: int);
        /**
        * The index of the real-time lightmap applied to this renderer.
        */
        public get realtimeLightmapIndex(): int;
        public set realtimeLightmapIndex(value: int);
        /**
        * The UV scale & offset used for a lightmap.
        */
        public get lightmapScaleOffset(): Vector4;
        public set lightmapScaleOffset(value: Vector4);
        /**
        * The UV scale & offset used for a real-time lightmap.
        */
        public get realtimeLightmapScaleOffset(): Vector4;
        public set realtimeLightmapScaleOffset(value: Vector4);
        /**
        * Returns all the instantiated materials of this object.
        */
        public get materials(): Material[];
        public set materials(value: Material[]);
        /**
        * Returns the first instantiated Material assigned to the renderer.
        */
        public get material(): Material;
        public set material(value: Material);
        /**
        * The shared material of this object.
        */
        public get sharedMaterial(): Material;
        public set sharedMaterial(value: Material);
        /**
        * All the shared materials of this object.
        */
        public get sharedMaterials(): Material[];
        public set sharedMaterials(value: Material[]);
        /**
        * Set the width at the start of the line.
        */
        public get startWidth(): float;
        public set startWidth(value: float);
        /**
        * Set the width at the end of the line.
        */
        public get endWidth(): float;
        public set endWidth(value: float);
        /**
        * Set an overall multiplier that is applied to the LineRenderer.widthCurve to get the final width of the line.
        */
        public get widthMultiplier(): float;
        public set widthMultiplier(value: float);
        /**
        * Set this to a value greater than 0, to get rounded corners between each segment of the line.
        */
        public get numCornerVertices(): int;
        public set numCornerVertices(value: int);
        /**
        * Set this to a value greater than 0, to get rounded corners on each end of the line. The default is 0.
        */
        public get numCapVertices(): int;
        public set numCapVertices(value: int);
        /**
        * If enabled, the lines are defined in world space.
        */
        public get useWorldSpace(): boolean;
        public set useWorldSpace(value: boolean);
        /**
        * Connect the start and end positions of the line together to form a continuous loop.
        */
        public get loop(): boolean;
        public set loop(value: boolean);
        /**
        * Set the color at the start of the line.
        */
        public get startColor(): Color;
        public set startColor(value: Color);
        /**
        * Set the color at the end of the line.
        */
        public get endColor(): Color;
        public set endColor(value: Color);
        /**
        * Set/get the number of vertices.
        */
        public get positionCount(): int;
        public set positionCount(value: int);
        /**
        * A multiplier for the UV coordinates of the line texture.
        */
        public get textureScale(): Vector2;
        public set textureScale(value: Vector2);
        /**
        * Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the line width at each segment.
        */
        public get shadowBias(): float;
        public set shadowBias(value: float);
        /**
        * Configures a line to generate Normals and Tangents. With this data, Scene lighting can affect the line via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.
        */
        public get generateLightingData(): boolean;
        public set generateLightingData(value: boolean);
        /**
        * Choose whether the U coordinate of the line texture is tiled or stretched.
        */
        public get textureMode(): LineTextureMode;
        public set textureMode(value: LineTextureMode);
        /**
        * Select whether the line will face the camera, or the orientation of the Transform Component.
        */
        public get alignment(): LineAlignment;
        public set alignment(value: LineAlignment);
        /**
        * Specifies how the LineRenderer interacts with SpriteMask.
        */
        public get maskInteraction(): SpriteMaskInteraction;
        public set maskInteraction(value: SpriteMaskInteraction);
        /**
        * Set the curve describing the width of the line at various points along its length.
        */
        public get widthCurve(): AnimationCurve;
        public set widthCurve(value: AnimationCurve);
        /**
        * Set the color gradient describing the color of the line at various points along its length.
        */
        public get colorGradient(): Gradient;
        public set colorGradient(value: Gradient);

        private constructor ()
        /**
        * Set the position of a vertex in the line.
        * @param index Which position to set.
        * @param position The new position.
        */
        public SetPosition ($index: int, $position: Vector3) : void
        /**
        * Get the position of a vertex in the line.
        * @param index The index of the position to retrieve.
        * @returns The position at the specified index in the array.
        */
        public GetPosition ($index: int) : Vector3
        /**
        * Generates a simplified version of the original line by removing points that fall within the specified tolerance.
        * @param tolerance This value is used to evaluate which points should be removed from the line. A higher value results in a simpler line (less points). A positive value close to zero results in a line with little to no reduction. A value of zero or less has no effect.
        */
        public Simplify ($tolerance: float) : void
        /**
        * Creates a snapshot of LineRenderer and stores it in mesh.
        * @param mesh A static mesh that will receive the snapshot of the line.
        * @param camera The camera used for determining which way camera-space lines will face.
        * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
        */
        public BakeMesh ($mesh: Mesh, $useTransform?: boolean) : void
        /**
        * Creates a snapshot of LineRenderer and stores it in mesh.
        * @param mesh A static mesh that will receive the snapshot of the line.
        * @param camera The camera used for determining which way camera-space lines will face.
        * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
        */
        public BakeMesh ($mesh: Mesh, $camera: Camera, $useTransform?: boolean) : void
        /**
        * Get the positions of all vertices in the line.
        * @param positions The array of positions to retrieve. The array passed should be of at least positionCount in size.
        * @returns How many positions were actually stored in the output array.
        */
        public GetPositions ($positions: Vector3[]) : int
        /**
        * Set the positions of all vertices in the line.
        * @param positions The array of positions to set.
        */
        public SetPositions ($positions: Vector3[]) : void
        public SetPositions ($positions: Unity_Collections.NativeArray$1<Vector3>) : void
        public SetPositions ($positions: Unity_Collections.NativeSlice$1<Vector3>) : void
        public GetPositions ($positions: Unity_Collections.NativeArray$1<Vector3>) : int
        public GetPositions ($positions: Unity_Collections.NativeSlice$1<Vector3>) : int
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * The Render Settings contain values for a range of visual elements in your Scene, like fog and ambient light.
    */
    class RenderSettings extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Is fog enabled?
        */
        public static get fog(): boolean;
        public static set fog(value: boolean);
        /**
        * The starting distance of linear fog.
        */
        public static get fogStartDistance(): float;
        public static set fogStartDistance(value: float);
        /**
        * The ending distance of linear fog.
        */
        public static get fogEndDistance(): float;
        public static set fogEndDistance(value: float);
        /**
        * Fog mode to use.
        */
        public static get fogMode(): FogMode;
        public static set fogMode(value: FogMode);
        /**
        * The color of the fog.
        */
        public static get fogColor(): Color;
        public static set fogColor(value: Color);
        /**
        * The density of the exponential fog.
        */
        public static get fogDensity(): float;
        public static set fogDensity(value: float);
        /**
        * Ambient lighting mode.
        */
        public static get ambientMode(): UnityEngine_Rendering.AmbientMode;
        public static set ambientMode(value: UnityEngine_Rendering.AmbientMode);
        /**
        * Ambient lighting coming from above.
        */
        public static get ambientSkyColor(): Color;
        public static set ambientSkyColor(value: Color);
        /**
        * Ambient lighting coming from the sides.
        */
        public static get ambientEquatorColor(): Color;
        public static set ambientEquatorColor(value: Color);
        /**
        * Ambient lighting coming from below.
        */
        public static get ambientGroundColor(): Color;
        public static set ambientGroundColor(value: Color);
        /**
        * How much the light from the Ambient Source affects the Scene.
        */
        public static get ambientIntensity(): float;
        public static set ambientIntensity(value: float);
        /**
        * Flat ambient lighting color.
        */
        public static get ambientLight(): Color;
        public static set ambientLight(value: Color);
        /**
        * The color used for the sun shadows in the Subtractive lightmode.
        */
        public static get subtractiveShadowColor(): Color;
        public static set subtractiveShadowColor(value: Color);
        /**
        * The global skybox to use.
        */
        public static get skybox(): Material;
        public static set skybox(value: Material);
        /**
        * The light used by the procedural skybox.
        */
        public static get sun(): Light;
        public static set sun(value: Light);
        /**
        * An automatically generated ambient probe that captures environment lighting.
        */
        public static get ambientProbe(): UnityEngine_Rendering.SphericalHarmonicsL2;
        public static set ambientProbe(value: UnityEngine_Rendering.SphericalHarmonicsL2);
        public static get customReflectionTexture(): Texture;
        public static set customReflectionTexture(value: Texture);
        /**
        * How much the skybox / custom cubemap reflection affects the Scene.
        */
        public static get reflectionIntensity(): float;
        public static set reflectionIntensity(value: float);
        /**
        * The number of times a reflection includes other reflections.
        */
        public static get reflectionBounces(): int;
        public static set reflectionBounces(value: int);
        /**
        * Default reflection mode.
        */
        public static get defaultReflectionMode(): UnityEngine_Rendering.DefaultReflectionMode;
        public static set defaultReflectionMode(value: UnityEngine_Rendering.DefaultReflectionMode);
        /**
        * Cubemap resolution for default reflection.
        */
        public static get defaultReflectionResolution(): int;
        public static set defaultReflectionResolution(value: int);
        /**
        * Size of the Light halos.
        */
        public static get haloStrength(): float;
        public static set haloStrength(value: float);
        /**
        * The intensity of all flares in the Scene.
        */
        public static get flareStrength(): float;
        public static set flareStrength(value: float);
        /**
        * The fade speed of all flares in the Scene.
        */
        public static get flareFadeSpeed(): float;
        public static set flareFadeSpeed(value: float);

    }

    /**
    * Fog mode to use.
    */
    enum FogMode {
        Linear = 1,
        Exponential = 2,
        ExponentialSquared = 3 
    }

    /**
    * Script interface for.
    */
    class Light extends Behaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;
        /**
        * The type of the light.
        */
        public get type(): LightType;
        public set type(value: LightType);
        /**
        * This property describes the shape of the spot light. Only Scriptable Render Pipelines use this property; the built-in renderer does not support it.
        */
        public get shape(): LightShape;
        public set shape(value: LightShape);
        /**
        * The angle of the spot light's cone in degrees.
        */
        public get spotAngle(): float;
        public set spotAngle(value: float);
        /**
        * The angle of the spot light's inner cone in degrees.
        */
        public get innerSpotAngle(): float;
        public set innerSpotAngle(value: float);
        /**
        * The color of the light.
        */
        public get color(): Color;
        public set color(value: Color);
        /**
        * The color temperature of the light.
        * Correlated Color Temperature (abbreviated as CCT) is multiplied with the color filter when calculating the final color of a light source. The color temperature of the electromagnetic radiation emitted from an ideal black body is defined as its surface temperature in Kelvin. White is 6500K according to the D65 standard. A candle light is 1800K and a soft warm light bulb is 2700K.
        * If you want to use colorTemperature, GraphicsSettings.lightsUseLinearIntensity and Light.useColorTemperature has to be enabled.
        * Additional resources: GraphicsSettings.lightsUseLinearIntensity, GraphicsSettings.useColorTemperature.
        */
        public get colorTemperature(): float;
        public set colorTemperature(value: float);
        /**
        * Set to true to use the color temperature.
        */
        public get useColorTemperature(): boolean;
        public set useColorTemperature(value: boolean);
        /**
        * The Intensity of a light is multiplied with the Light color.
        */
        public get intensity(): float;
        public set intensity(value: float);
        /**
        * The multiplier that defines the strength of the bounce lighting.
        */
        public get bounceIntensity(): float;
        public set bounceIntensity(value: float);
        /**
        * Set to true to override light bounding sphere for culling.
        */
        public get useBoundingSphereOverride(): boolean;
        public set useBoundingSphereOverride(value: boolean);
        /**
        * Bounding sphere used to override the regular light bounding sphere during culling.
        */
        public get boundingSphereOverride(): Vector4;
        public set boundingSphereOverride(value: Vector4);
        /**
        * Whether to cull shadows for this Light when the Light is outside of the view frustum.
        */
        public get useViewFrustumForShadowCasterCull(): boolean;
        public set useViewFrustumForShadowCasterCull(value: boolean);
        /**
        * The custom resolution of the shadow map.
        */
        public get shadowCustomResolution(): int;
        public set shadowCustomResolution(value: int);
        /**
        * Shadow mapping constant bias.
        */
        public get shadowBias(): float;
        public set shadowBias(value: float);
        /**
        * Shadow mapping normal-based bias.
        */
        public get shadowNormalBias(): float;
        public set shadowNormalBias(value: float);
        /**
        * Near plane value to use for shadow frustums.
        */
        public get shadowNearPlane(): float;
        public set shadowNearPlane(value: float);
        /**
        * Set to true to enable custom matrix for culling during shadows.
        */
        public get useShadowMatrixOverride(): boolean;
        public set useShadowMatrixOverride(value: boolean);
        /**
        * Matrix that overrides the regular light projection matrix during shadow culling. Unity uses this matrix if you set Light.useShadowMatrixOverride to true.
        */
        public get shadowMatrixOverride(): Matrix4x4;
        public set shadowMatrixOverride(value: Matrix4x4);
        /**
        * The range of the light.
        */
        public get range(): float;
        public set range(value: float);
        /**
        * The to use for this light.
        */
        public get flare(): Flare;
        public set flare(value: Flare);
        /**
        * This property describes the output of the last Global Illumination bake.
        */
        public get bakingOutput(): LightBakingOutput;
        public set bakingOutput(value: LightBakingOutput);
        /**
        * This is used to light certain objects in the Scene selectively.
        */
        public get cullingMask(): int;
        public set cullingMask(value: int);
        /**
        * Determines which rendering LayerMask this Light affects.
        */
        public get renderingLayerMask(): int;
        public set renderingLayerMask(value: int);
        /**
        * Allows you to override the global Shadowmask Mode per light. Only use this with render pipelines that can handle per light Shadowmask modes. Incompatible with the legacy renderers.
        */
        public get lightShadowCasterMode(): LightShadowCasterMode;
        public set lightShadowCasterMode(value: LightShadowCasterMode);
        /**
        * How this light casts shadows
        */
        public get shadows(): LightShadows;
        public set shadows(value: LightShadows);
        /**
        * Strength of light's shadows.
        */
        public get shadowStrength(): float;
        public set shadowStrength(value: float);
        /**
        * The resolution of the shadow map.
        */
        public get shadowResolution(): UnityEngine_Rendering.LightShadowResolution;
        public set shadowResolution(value: UnityEngine_Rendering.LightShadowResolution);
        /**
        * Per-light, per-layer shadow culling distances. Directional lights only.
        */
        public get layerShadowCullDistances(): float[];
        public set layerShadowCullDistances(value: float[]);
        /**
        * The size of a directional light's cookie.
        */
        public get cookieSize(): float;
        public set cookieSize(value: float);
        /**
        * The cookie texture projected by the light.
        */
        public get cookie(): Texture;
        public set cookie(value: Texture);
        /**
        * How to render the light.
        */
        public get renderMode(): LightRenderMode;
        public set renderMode(value: LightRenderMode);
        /**
        * Number of command buffers set up on this light (Read Only).
        */
        public get commandBufferCount(): int;

        private constructor ()
        /**
        * Revert all light parameters to default.
        */
        public Reset () : void
        /**
        * Add a command buffer to be executed at a specified place.
        * @param evt When to execute the command buffer during rendering.
        * @param buffer The buffer to execute.
        * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
        */
        public AddCommandBuffer ($evt: UnityEngine_Rendering.LightEvent, $buffer: UnityEngine_Rendering.CommandBuffer) : void
        /**
        * Add a command buffer to be executed at a specified place.
        * @param evt When to execute the command buffer during rendering.
        * @param buffer The buffer to execute.
        * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
        */
        public AddCommandBuffer ($evt: UnityEngine_Rendering.LightEvent, $buffer: UnityEngine_Rendering.CommandBuffer, $shadowPassMask: UnityEngine_Rendering.ShadowMapPass) : void
        /**
        * Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
        * @param evt The point during the graphics processing at which this command buffer should commence on the GPU.
        * @param buffer The buffer to execute.
        * @param queueType The desired async compute queue type to execute the buffer on.
        * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
        */
        public AddCommandBufferAsync ($evt: UnityEngine_Rendering.LightEvent, $buffer: UnityEngine_Rendering.CommandBuffer, $queueType: UnityEngine_Rendering.ComputeQueueType) : void
        /**
        * Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
        * @param evt The point during the graphics processing at which this command buffer should commence on the GPU.
        * @param buffer The buffer to execute.
        * @param queueType The desired async compute queue type to execute the buffer on.
        * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
        */
        public AddCommandBufferAsync ($evt: UnityEngine_Rendering.LightEvent, $buffer: UnityEngine_Rendering.CommandBuffer, $shadowPassMask: UnityEngine_Rendering.ShadowMapPass, $queueType: UnityEngine_Rendering.ComputeQueueType) : void
        /**
        * Remove command buffer from execution at a specified place.
        * @param evt When to execute the command buffer during rendering.
        * @param buffer The buffer to execute.
        */
        public RemoveCommandBuffer ($evt: UnityEngine_Rendering.LightEvent, $buffer: UnityEngine_Rendering.CommandBuffer) : void
        /**
        * Remove command buffers from execution at a specified place.
        * @param evt When to execute the command buffer during rendering.
        */
        public RemoveCommandBuffers ($evt: UnityEngine_Rendering.LightEvent) : void
        /**
        * Remove all command buffers set on this light.
        */
        public RemoveAllCommandBuffers () : void
        /**
        * Get command buffers to be executed at a specified place.
        * @param evt When to execute the command buffer during rendering.
        * @returns Array of command buffers.
        */
        public GetCommandBuffers ($evt: UnityEngine_Rendering.LightEvent) : UnityEngine_Rendering.CommandBuffer[]
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * The type of a Light.
    */
    enum LightType {
        Spot = 0,
        Directional = 1,
        Point = 2,
        Area = 3,
        Rectangle = 3,
        Disc = 4 
    }

    /**
    * Describes the shape of a spot light.
    */
    enum LightShape {
        Cone = 0,
        Pyramid = 1,
        Box = 2 
    }

    /**
    * A flare asset. Read more about flares in the.
    */
    class Flare extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);

        public constructor ()
    }

    /**
    * Struct describing the result of a Global Illumination bake for a given light.
    */
    class LightBakingOutput extends System.ValueType {

        /**
        * In case of a LightmapBakeType.Mixed light, contains the index of the light as seen from the occlusion probes point of view if any, otherwise -1.
        */
        public probeOcclusionLightIndex : int
        /**
        * In case of a LightmapBakeType.Mixed light, contains the index of the occlusion mask channel to use if any, otherwise -1.
        */
        public occlusionMaskChannel : int
        /**
        * This property describes what part of a light's contribution was baked.
        */
        public lightmapBakeType : LightmapBakeType
        /**
        * In case of a LightmapBakeType.Mixed light, describes what Mixed mode was used to bake the light, irrelevant otherwise.
        */
        public mixedLightingMode : MixedLightingMode
        /**
        * Is the light contribution already stored in lightmaps and/or lightprobes?
        */
        public isBaked : boolean

    }

    /**
    * Enum describing what part of a light contribution can be baked.
    */
    enum LightmapBakeType {
        Realtime = 4,
        Baked = 2,
        Mixed = 1 
    }

    /**
    * Enum describing what lighting mode to be used with Mixed lights.
    */
    enum MixedLightingMode {
        IndirectOnly = 0,
        Shadowmask = 2,
        Subtractive = 1 
    }

    /**
    * Allows mixed lights to control shadow caster culling when Shadowmasks are present.
    */
    enum LightShadowCasterMode {
        Default = 0,
        NonLightmappedOnly = 1,
        Everything = 2 
    }

    /**
    * Shadow casting options for a Light.
    */
    enum LightShadows {
        None = 0,
        Hard = 1,
        Soft = 2 
    }

    /**
    * How the Light is rendered.
    */
    enum LightRenderMode {
        Auto = 0,
        ForcePixel = 1,
        ForceVertex = 2 
    }

    /**
    * The portal for dynamically changing occlusion at runtime.
    */
    class OcclusionPortal extends Component {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Gets / sets the portal's open state.
        */
        public get open(): boolean;
        public set open(value: boolean);

        private constructor ()
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * OcclusionArea is an area in which occlusion culling is performed.
    */
    class OcclusionArea extends Component {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Center of the occlusion area relative to the transform.
        */
        public get center(): Vector3;
        public set center(value: Vector3);
        /**
        * Size that the occlusion area will have.
        */
        public get size(): Vector3;
        public set size(value: Vector3);

        private constructor ()
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * Script interface for a.
    */
    class LensFlare extends Behaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;
        /**
        * The strength of the flare.
        */
        public get brightness(): float;
        public set brightness(value: float);
        /**
        * The fade speed of the flare.
        */
        public get fadeSpeed(): float;
        public set fadeSpeed(value: float);
        /**
        * The color of the flare.
        */
        public get color(): Color;
        public set color(value: Color);
        /**
        * The to use.
        */
        public get flare(): Flare;
        public set flare(value: Flare);

        private constructor ()
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * A script interface for the.
    */
    class Skybox extends Behaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;
        /**
        * The material used by the skybox.
        */
        public get material(): Material;
        public set material(value: Material);

        private constructor ()
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * A class to access the Mesh of the.
    */
    class MeshFilter extends Component {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Returns the shared mesh of the mesh filter.
        */
        public get sharedMesh(): Mesh;
        public set sharedMesh(value: Mesh);
        /**
        * Returns either a new Mesh|mesh or a duplicate of the existing mesh, and assigns it to the mesh filter.
        */
        public get mesh(): Mesh;
        public set mesh(value: Mesh);

        private constructor ()
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * This property only takes effect if you enable a global illumination setting such as for the GameObject associated with the target Mesh Renderer. Otherwise this property defaults to the Light Probes setting.
    */
    enum ReceiveGI {
        Lightmaps = 1,
        LightProbes = 2 
    }

    /**
    * A set of options for the level of compression the Editor uses for lightmaps.
    */
    enum LightmapCompression {
        None = 0,
        LowQuality = 1,
        NormalQuality = 2,
        HighQuality = 3 
    }

    /**
    * Shadow projection type for.
    */
    enum ShadowProjection {
        CloseFit = 0,
        StableFit = 1 
    }

    /**
    * Determines which type of shadows should be used.
    */
    enum ShadowQuality {
        Disable = 0,
        HardOnly = 1,
        All = 2 
    }

    /**
    * Default shadow resolution. Each decrease in quality level halves the resolution of shadows.
    */
    enum ShadowResolution {
        Low = 0,
        Medium = 1,
        High = 2,
        VeryHigh = 3 
    }

    /**
    * The rendering mode of Shadowmask.
    */
    enum ShadowmaskMode {
        Shadowmask = 0,
        DistanceShadowmask = 1 
    }

    /**
    * The filters that Unity can use when it renders GameObjects in the shadow pass.
    */
    enum ShadowObjectsFilter {
        AllObjects = 0,
        DynamicOnly = 1,
        StaticOnly = 2 
    }

    enum TexGenMode {
        None = 0,
        SphereMap = 1,
        Object = 2,
        EyeLinear = 3,
        CubeReflect = 4,
        CubeNormal = 5 
    }

    /**
    * The maximum number of bones affecting a single vertex.
    */
    enum SkinQuality {
        Auto = 0,
        Bone1 = 1,
        Bone2 = 2,
        Bone4 = 4 
    }

    /**
    * NPOT Texture2D|textures support.
    */
    enum NPOTSupport {
        None = 0,
        Restricted = 1,
        Full = 2 
    }

    /**
    * A set of flags that describe the level of HDR display support available on the GPU and driver.
    */
    enum HDRDisplaySupportFlags {
        None = 0,
        Supported = 1,
        RuntimeSwitchable = 2,
        AutomaticTonemapping = 4 
    }

    /**
    * Options for the number of bits for HDR output in each color channel of swap chain buffers. Applicable when an HDR display is active.
    */
    enum HDRDisplayBitDepth {
        BitDepth10 = 0,
        BitDepth16 = 1 
    }

    /**
    * An enumeration that represents the bias mode to use for TextureMipmapLimitSettings.limitBias.
    */
    enum TextureMipmapLimitBiasMode {
        OffsetGlobalLimit = 0,
        OverrideGlobalLimit = 1 
    }

    /**
    * Flags used by QualitySettings to specify which Terrain fields the quality settings should override.
    */
    enum TerrainQualityOverrides {
        None = 0,
        PixelError = 1,
        BasemapDistance = 2,
        DetailDensity = 4,
        DetailDistance = 8,
        TreeDistance = 16,
        BillboardStart = 32,
        FadeLength = 64,
        MaxTrees = 128 
    }

    /**
    * Structure that represents texture mipmap limit settings.
    */
    class TextureMipmapLimitSettings extends System.ValueType {

        /**
        * Indicates whether the limitBias functions as an offset to the global texture mipmap limit or, instead, acts as an override to it.
        */
        public get limitBiasMode(): TextureMipmapLimitBiasMode;
        public set limitBiasMode(value: TextureMipmapLimitBiasMode);
        /**
        * The new value to apply on top of the global texture mipmap limit. Can act as an offset (default) or an override to it.
        */
        public get limitBias(): int;
        public set limitBias(value: int);

    }

    /**
    * Script interface for texture mipmap limit groups.
    */
    class TextureMipmapLimitGroups {

        /**
        * Retrieves a string array containing the name of all texture mipmap limit groups available in the project.
        * @returns String array of texture mipmap limit group names.
        */
        public static GetGroups () : string[]
        /**
        * Checks whether a texture mipmap limit group with the indicated groupName exists in the project. This operation fails and throws an exception if groupName is null.
        * @param groupName Name of the texture mipmap limit group to verify.
        * @returns Returns true if a texture mipmap limit group named groupName exists in the project. If that is not the case, returns false.
        */
        public static HasGroup ($groupName: string) : boolean
    }

    /**
    * The Skinned Mesh filter.
    */
    class SkinnedMeshRenderer extends Renderer {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * The bounding box of the renderer in world space.
        */
        public get bounds(): Bounds;
        public set bounds(value: Bounds);
        /**
        * The bounding box of the renderer in local space.
        */
        public get localBounds(): Bounds;
        public set localBounds(value: Bounds);
        /**
        * Makes the rendered 3D object visible if enabled.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Is this renderer visible in any camera? (Read Only)
        */
        public get isVisible(): boolean;
        /**
        * Does this object cast shadows?
        */
        public get shadowCastingMode(): UnityEngine_Rendering.ShadowCastingMode;
        public set shadowCastingMode(value: UnityEngine_Rendering.ShadowCastingMode);
        /**
        * Does this object receive shadows?
        */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
        * Allows turning off rendering for a specific component.
        */
        public get forceRenderingOff(): boolean;
        public set forceRenderingOff(value: boolean);
        /**
        * Is this renderer a static shadow caster?
        */
        public get staticShadowCaster(): boolean;
        public set staticShadowCaster(value: boolean);
        /**
        * Specifies the mode for motion vector rendering.
        */
        public get motionVectorGenerationMode(): MotionVectorGenerationMode;
        public set motionVectorGenerationMode(value: MotionVectorGenerationMode);
        /**
        * The light probe interpolation type.
        */
        public get lightProbeUsage(): UnityEngine_Rendering.LightProbeUsage;
        public set lightProbeUsage(value: UnityEngine_Rendering.LightProbeUsage);
        /**
        * Should reflection probes be used for this Renderer?
        */
        public get reflectionProbeUsage(): UnityEngine_Rendering.ReflectionProbeUsage;
        public set reflectionProbeUsage(value: UnityEngine_Rendering.ReflectionProbeUsage);
        /**
        * Determines which rendering layer this renderer lives on, if you use a.
        */
        public get renderingLayerMask(): uint;
        public set renderingLayerMask(value: uint);
        /**
        * This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
        */
        public get rendererPriority(): int;
        public set rendererPriority(value: int);
        /**
        * Describes how this renderer is updated for ray tracing.
        */
        public get rayTracingMode(): UnityEngine_Experimental_Rendering.RayTracingMode;
        public set rayTracingMode(value: UnityEngine_Experimental_Rendering.RayTracingMode);
        /**
        * Name of the Renderer's sorting layer.
        */
        public get sortingLayerName(): string;
        public set sortingLayerName(value: string);
        /**
        * Unique ID of the Renderer's sorting layer.
        */
        public get sortingLayerID(): int;
        public set sortingLayerID(value: int);
        /**
        * Renderer's order within a sorting layer.
        */
        public get sortingOrder(): int;
        public set sortingOrder(value: int);
        /**
        * Controls if dynamic occlusion culling should be performed for this renderer.
        */
        public get allowOcclusionWhenDynamic(): boolean;
        public set allowOcclusionWhenDynamic(value: boolean);
        /**
        * Indicates whether the renderer is part of a with other renderers.
        */
        public get isPartOfStaticBatch(): boolean;
        /**
        * Matrix that transforms a point from world space into local space (Read Only).
        */
        public get worldToLocalMatrix(): Matrix4x4;
        /**
        * Matrix that transforms a point from local space into world space (Read Only).
        */
        public get localToWorldMatrix(): Matrix4x4;
        /**
        * If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
        */
        public get lightProbeProxyVolumeOverride(): GameObject;
        public set lightProbeProxyVolumeOverride(value: GameObject);
        /**
        * If set, Renderer will use this Transform's position to find the light or reflection probe.
        */
        public get probeAnchor(): Transform;
        public set probeAnchor(value: Transform);
        /**
        * The index of the baked lightmap applied to this renderer.
        */
        public get lightmapIndex(): int;
        public set lightmapIndex(value: int);
        /**
        * The index of the real-time lightmap applied to this renderer.
        */
        public get realtimeLightmapIndex(): int;
        public set realtimeLightmapIndex(value: int);
        /**
        * The UV scale & offset used for a lightmap.
        */
        public get lightmapScaleOffset(): Vector4;
        public set lightmapScaleOffset(value: Vector4);
        /**
        * The UV scale & offset used for a real-time lightmap.
        */
        public get realtimeLightmapScaleOffset(): Vector4;
        public set realtimeLightmapScaleOffset(value: Vector4);
        /**
        * Returns all the instantiated materials of this object.
        */
        public get materials(): Material[];
        public set materials(value: Material[]);
        /**
        * Returns the first instantiated Material assigned to the renderer.
        */
        public get material(): Material;
        public set material(value: Material);
        /**
        * The shared material of this object.
        */
        public get sharedMaterial(): Material;
        public set sharedMaterial(value: Material);
        /**
        * All the shared materials of this object.
        */
        public get sharedMaterials(): Material[];
        public set sharedMaterials(value: Material[]);
        /**
        * The maximum number of bones per vertex that are taken into account during skinning.
        */
        public get quality(): SkinQuality;
        public set quality(value: SkinQuality);
        /**
        * If enabled, the Skinned Mesh will be updated when offscreen. If disabled, this also disables updating animations.
        */
        public get updateWhenOffscreen(): boolean;
        public set updateWhenOffscreen(value: boolean);
        /**
        * Forces the Skinned Mesh to recalculate its matricies when rendered
        */
        public get forceMatrixRecalculationPerRender(): boolean;
        public set forceMatrixRecalculationPerRender(value: boolean);
        public get rootBone(): Transform;
        public set rootBone(value: Transform);
        /**
        * The bones used to skin the mesh.
        */
        public get bones(): Transform[];
        public set bones(value: Transform[]);
        /**
        * The mesh used for skinning.
        */
        public get sharedMesh(): Mesh;
        public set sharedMesh(value: Mesh);
        /**
        * Specifies whether skinned motion vectors should be used for this renderer.
        */
        public get skinnedMotionVectors(): boolean;
        public set skinnedMotionVectors(value: boolean);
        /**
        * The intended target usage of the skinned mesh GPU vertex buffer.
        */
        public get vertexBufferTarget(): UnityEngine_GraphicsBuffer.Target;
        public set vertexBufferTarget(value: UnityEngine_GraphicsBuffer.Target);

        private constructor ()
        /**
        * Returns the weight of a BlendShape for this Renderer.
        * @param index The index of the BlendShape whose weight you want to retrieve. Index must be smaller than the Mesh.blendShapeCount of the Mesh attached to this Renderer.
        * @returns The weight of the BlendShape.
        */
        public GetBlendShapeWeight ($index: int) : float
        /**
        * Sets the weight of a BlendShape for this Renderer.
        * @param index The index of the BlendShape to modify. Index must be smaller than the Mesh.blendShapeCount of the Mesh attached to this Renderer.
        * @param value The weight for this BlendShape.
        */
        public SetBlendShapeWeight ($index: int, $value: float) : void
        /**
        * Creates a snapshot of SkinnedMeshRenderer and stores it in mesh.
        * @param mesh A static mesh that will receive the snapshot of the skinned mesh.
        * @param useScale Whether to use the SkinnedMeshRenderer's Transform scale when baking the Mesh. If this is true, Unity bakes the Mesh using the position, rotation, and scale values from the SkinnedMeshRenderer's Transform. If this is false, Unity bakes the Mesh using the position and rotation values from the SkinnedMeshRenderer's Transform, but without using the scale value from the SkinnedMeshRenderer's Transform. The default value is false.
        */
        public BakeMesh ($mesh: Mesh) : void
        /**
        * Creates a snapshot of SkinnedMeshRenderer and stores it in mesh.
        * @param mesh A static mesh that will receive the snapshot of the skinned mesh.
        * @param useScale Whether to use the SkinnedMeshRenderer's Transform scale when baking the Mesh. If this is true, Unity bakes the Mesh using the position, rotation, and scale values from the SkinnedMeshRenderer's Transform. If this is false, Unity bakes the Mesh using the position and rotation values from the SkinnedMeshRenderer's Transform, but without using the scale value from the SkinnedMeshRenderer's Transform. The default value is false.
        */
        public BakeMesh ($mesh: Mesh, $useScale: boolean) : void
        /**
        * Retrieves a GraphicsBuffer that provides direct access to the GPU vertex buffer for this skinned mesh, for the current frame.
        * @returns The skinned mesh vertex buffer as a GraphicsBuffer.
        */
        public GetVertexBuffer () : GraphicsBuffer
        /**
        * Retrieves a GraphicsBuffer that provides direct access to the GPU vertex buffer for this skinned mesh, for the previous frame.
        * @returns The skinned mesh vertex buffer as a GraphicsBuffer.
        */
        public GetPreviousVertexBuffer () : GraphicsBuffer
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * Renders meshes inserted by the MeshFilter or TextMesh.
    */
    class MeshRenderer extends Renderer {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * The bounding box of the renderer in world space.
        */
        public get bounds(): Bounds;
        public set bounds(value: Bounds);
        /**
        * The bounding box of the renderer in local space.
        */
        public get localBounds(): Bounds;
        public set localBounds(value: Bounds);
        /**
        * Makes the rendered 3D object visible if enabled.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Is this renderer visible in any camera? (Read Only)
        */
        public get isVisible(): boolean;
        /**
        * Does this object cast shadows?
        */
        public get shadowCastingMode(): UnityEngine_Rendering.ShadowCastingMode;
        public set shadowCastingMode(value: UnityEngine_Rendering.ShadowCastingMode);
        /**
        * Does this object receive shadows?
        */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
        * Allows turning off rendering for a specific component.
        */
        public get forceRenderingOff(): boolean;
        public set forceRenderingOff(value: boolean);
        /**
        * Is this renderer a static shadow caster?
        */
        public get staticShadowCaster(): boolean;
        public set staticShadowCaster(value: boolean);
        /**
        * Specifies the mode for motion vector rendering.
        */
        public get motionVectorGenerationMode(): MotionVectorGenerationMode;
        public set motionVectorGenerationMode(value: MotionVectorGenerationMode);
        /**
        * The light probe interpolation type.
        */
        public get lightProbeUsage(): UnityEngine_Rendering.LightProbeUsage;
        public set lightProbeUsage(value: UnityEngine_Rendering.LightProbeUsage);
        /**
        * Should reflection probes be used for this Renderer?
        */
        public get reflectionProbeUsage(): UnityEngine_Rendering.ReflectionProbeUsage;
        public set reflectionProbeUsage(value: UnityEngine_Rendering.ReflectionProbeUsage);
        /**
        * Determines which rendering layer this renderer lives on, if you use a.
        */
        public get renderingLayerMask(): uint;
        public set renderingLayerMask(value: uint);
        /**
        * This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
        */
        public get rendererPriority(): int;
        public set rendererPriority(value: int);
        /**
        * Describes how this renderer is updated for ray tracing.
        */
        public get rayTracingMode(): UnityEngine_Experimental_Rendering.RayTracingMode;
        public set rayTracingMode(value: UnityEngine_Experimental_Rendering.RayTracingMode);
        /**
        * Name of the Renderer's sorting layer.
        */
        public get sortingLayerName(): string;
        public set sortingLayerName(value: string);
        /**
        * Unique ID of the Renderer's sorting layer.
        */
        public get sortingLayerID(): int;
        public set sortingLayerID(value: int);
        /**
        * Renderer's order within a sorting layer.
        */
        public get sortingOrder(): int;
        public set sortingOrder(value: int);
        /**
        * Controls if dynamic occlusion culling should be performed for this renderer.
        */
        public get allowOcclusionWhenDynamic(): boolean;
        public set allowOcclusionWhenDynamic(value: boolean);
        /**
        * Indicates whether the renderer is part of a with other renderers.
        */
        public get isPartOfStaticBatch(): boolean;
        /**
        * Matrix that transforms a point from world space into local space (Read Only).
        */
        public get worldToLocalMatrix(): Matrix4x4;
        /**
        * Matrix that transforms a point from local space into world space (Read Only).
        */
        public get localToWorldMatrix(): Matrix4x4;
        /**
        * If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
        */
        public get lightProbeProxyVolumeOverride(): GameObject;
        public set lightProbeProxyVolumeOverride(value: GameObject);
        /**
        * If set, Renderer will use this Transform's position to find the light or reflection probe.
        */
        public get probeAnchor(): Transform;
        public set probeAnchor(value: Transform);
        /**
        * The index of the baked lightmap applied to this renderer.
        */
        public get lightmapIndex(): int;
        public set lightmapIndex(value: int);
        /**
        * The index of the real-time lightmap applied to this renderer.
        */
        public get realtimeLightmapIndex(): int;
        public set realtimeLightmapIndex(value: int);
        /**
        * The UV scale & offset used for a lightmap.
        */
        public get lightmapScaleOffset(): Vector4;
        public set lightmapScaleOffset(value: Vector4);
        /**
        * The UV scale & offset used for a real-time lightmap.
        */
        public get realtimeLightmapScaleOffset(): Vector4;
        public set realtimeLightmapScaleOffset(value: Vector4);
        /**
        * Returns all the instantiated materials of this object.
        */
        public get materials(): Material[];
        public set materials(value: Material[]);
        /**
        * Returns the first instantiated Material assigned to the renderer.
        */
        public get material(): Material;
        public set material(value: Material);
        /**
        * The shared material of this object.
        */
        public get sharedMaterial(): Material;
        public set sharedMaterial(value: Material);
        /**
        * All the shared materials of this object.
        */
        public get sharedMaterials(): Material[];
        public set sharedMaterials(value: Material[]);
        /**
        * Vertex attributes in this mesh will override or add attributes of the primary mesh in the MeshRenderer.
        */
        public get additionalVertexStreams(): Mesh;
        public set additionalVertexStreams(value: Mesh);
        /**
        * Vertex attributes that override the primary mesh when the MeshRenderer uses lightmaps in the Realtime Global Illumination system.
        */
        public get enlightenVertexStream(): Mesh;
        public set enlightenVertexStream(value: Mesh);
        /**
        * Index of the first sub-mesh to use from the Mesh associated with this MeshRenderer (Read Only).
        */
        public get subMeshStartIndex(): int;

        private constructor ()
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * The LOD (level of detail) fade modes. Modes other than LODFadeMode.None will result in Unity calculating a blend factor for blending/interpolating between two neighbouring LODs and pass it to your shader.
    */
    enum LODFadeMode {
        None = 0,
        CrossFade = 1,
        SpeedTree = 2 
    }

    /**
    * Structure for building a LOD for passing to the SetLODs function.
    */
    class LOD extends System.ValueType {

        /**
        * The screen relative height to use for the transition [0-1].
        */
        public screenRelativeTransitionHeight : float
        /**
        * Width of the cross-fade transition zone (proportion to the current LOD's whole length) [0-1]. Only used if it's not animated.
        */
        public fadeTransitionWidth : float
        /**
        * List of renderers for this LOD level.
        */
        public renderers : Renderer[]

        /**
        * Construct a LOD.
        * @param screenRelativeTransitionHeight The screen relative height to use for the transition [0-1].
        * @param renderers An array of renderers to use for this LOD level.
        */
        public constructor ($screenRelativeTransitionHeight: float, $renderers: Renderer[])
    }

    /**
    * LODGroup lets you group multiple Renderers into LOD levels.
    */
    class LODGroup extends Component {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * The local reference point against which the LOD distance is calculated.
        */
        public get localReferencePoint(): Vector3;
        public set localReferencePoint(value: Vector3);
        /**
        * The size of the LOD object in local space.
        */
        public get size(): float;
        public set size(value: float);
        /**
        * The number of LOD levels.
        */
        public get lodCount(): int;
        /**
        * Specify whether the last LOD level is a BillboardRenderer.
        */
        public get lastLODBillboard(): boolean;
        public set lastLODBillboard(value: boolean);
        /**
        * The LOD fade mode used.
        */
        public get fadeMode(): LODFadeMode;
        public set fadeMode(value: LODFadeMode);
        /**
        * Specify if the cross-fading should be animated by time. The animation duration is specified globally as crossFadeAnimationDuration.
        */
        public get animateCrossFading(): boolean;
        public set animateCrossFading(value: boolean);
        /**
        * Allows you to enable or disable the LODGroup.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * The cross-fading animation duration in seconds. ArgumentException will be thrown if it is set to zero or a negative value.
        */
        public static get crossFadeAnimationDuration(): float;
        public static set crossFadeAnimationDuration(value: float);

        private constructor ()
        /**
        * Recalculate the bounding region for the LODGroup (Relatively slow, do not call often).
        */
        public RecalculateBounds () : void
        /**
        * Returns the array of LODs.
        * @returns The LOD array.
        */
        public GetLODs () : LOD[]
        /**
        * Set the LODs for the LOD group. This will remove any existing LODs configured on the LODGroup.
        * @param lods The LODs to use for this group.
        */
        public SetLODs ($lods: LOD[]) : void
        /**
        * @param index The LOD level to use. Passing index < 0 will return to standard LOD processing.
        */
        public ForceLOD ($index: int) : void
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * Light Probe Group.
    */
    class LightProbeGroup extends Behaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;

        private constructor ()
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * A collection of common line functions.
    */
    class LineUtility extends System.Object {

        public constructor ()
        /**
        * @methodSwap Simplify_EBB7509C_B4F59DDC
        */
        public static Simplify ($points: System_Collections_Generic.List$1<Vector3>, $tolerance: float, $pointsToKeep: System_Collections_Generic.List$1<int>) : void
        /**
        * @methodSwap Simplify_EBB7509C_FCF91868
        */
        public static Simplify ($points: System_Collections_Generic.List$1<Vector3>, $tolerance: float, $simplifiedPoints: System_Collections_Generic.List$1<Vector3>) : void
        /**
        * @methodSwap Simplify_EBB7509C_H98CB63D1
        */
        public static Simplify ($points: System_Collections_Generic.List$1<Vector2>, $tolerance: float, $pointsToKeep: System_Collections_Generic.List$1<int>) : void
        /**
        * @methodSwap Simplify_EBB7509C_H656679DE
        */
        public static Simplify ($points: System_Collections_Generic.List$1<Vector2>, $tolerance: float, $simplifiedPoints: System_Collections_Generic.List$1<Vector2>) : void
    }

    /**
    * Class for handling 3D Textures, Use this to create.
    */
    class Texture3D extends Texture {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
        */
        public static GenerateAllMips : int
        /**
        * How many mipmap levels are in this Texture (Read Only).
        */
        public get mipmapCount(): int;
        public static get anisotropicFiltering(): AnisotropicFiltering;
        public static set anisotropicFiltering(value: AnisotropicFiltering);
        /**
        * Returns the GraphicsFormat format or color format of a Texture object.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
        * Width of the Texture in pixels (Read Only).
        */
        public get width(): int;
        public set width(value: int);
        /**
        * Height of the Texture in pixels (Read Only).
        */
        public get height(): int;
        public set height(value: int);
        /**
        * Dimensionality (type) of the Texture (Read Only).
        */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
        * Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
        */
        public get isReadable(): boolean;
        /**
        * Texture coordinate wrapping mode.
        */
        public get wrapMode(): TextureWrapMode;
        public set wrapMode(value: TextureWrapMode);
        /**
        * Texture U coordinate wrapping mode.
        */
        public get wrapModeU(): TextureWrapMode;
        public set wrapModeU(value: TextureWrapMode);
        /**
        * Texture V coordinate wrapping mode.
        */
        public get wrapModeV(): TextureWrapMode;
        public set wrapModeV(value: TextureWrapMode);
        /**
        * Texture W coordinate wrapping mode for Texture3D.
        */
        public get wrapModeW(): TextureWrapMode;
        public set wrapModeW(value: TextureWrapMode);
        /**
        * Filtering mode of the Texture.
        */
        public get filterMode(): FilterMode;
        public set filterMode(value: FilterMode);
        /**
        * Defines the anisotropic filtering level of the Texture.
        */
        public get anisoLevel(): int;
        public set anisoLevel(value: int);
        /**
        * The mipmap bias of the Texture.
        */
        public get mipMapBias(): float;
        public set mipMapBias(value: float);
        public get texelSize(): Vector2;
        /**
        * This counter is incremented when the Texture is updated.
        */
        public get updateCount(): uint;
        /**
        * Returns true if the texture pixel data is in sRGB color space (Read Only).
        */
        public get isDataSRGB(): boolean;
        /**
        * The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0.
        * This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually.
        * To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`.
        * `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get totalTextureMemory(): bigint;
        /**
        * The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.
        * For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.
        * The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
        */
        public static get desiredTextureMemory(): bigint;
        /**
        * The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get targetTextureMemory(): bigint;
        /**
        * The amount of memory that all Textures in the scene use.
        */
        public static get currentTextureMemory(): bigint;
        /**
        * The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureMemory(): bigint;
        /**
        * How many times has a Texture been uploaded due to Texture mipmap streaming.
        */
        public static get streamingMipmapUploadCount(): bigint;
        /**
        * Number of renderers registered with the Texture streaming system.
        */
        public static get streamingRendererCount(): bigint;
        /**
        * Number of streaming Textures.
        */
        public static get streamingTextureCount(): bigint;
        /**
        * The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureCount(): bigint;
        /**
        * Number of streaming Textures with outstanding mipmaps to be loaded.
        */
        public static get streamingTexturePendingLoadCount(): bigint;
        /**
        * Number of streaming Textures with mipmaps currently loading.
        */
        public static get streamingTextureLoadingCount(): bigint;
        /**
        * Force streaming Textures to load all mipmap levels.
        */
        public static get streamingTextureForceLoadAll(): boolean;
        public static set streamingTextureForceLoadAll(value: boolean);
        /**
        * This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
        */
        public static get streamingTextureDiscardUnusedMips(): boolean;
        public static set streamingTextureDiscardUnusedMips(value: boolean);
        /**
        * Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
        */
        public static get allowThreadedTextureCreation(): boolean;
        public static set allowThreadedTextureCreation(value: boolean);
        /**
        * The depth of the texture (Read Only).
        */
        public get depth(): int;
        /**
        * The format of the pixel data in the texture (Read Only).
        */
        public get format(): TextureFormat;

        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: int)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: int)
        public constructor ($width: int, $height: int, $depth: int, $textureFormat: TextureFormat, $mipCount: int)
        /**
        * Create a new empty 3D Texture.
        * @param width Width of texture in pixels.
        * @param height Height of texture in pixels.
        * @param depth Depth of texture in pixels.
        * @param textureFormat Texture data format.
        * @param mipChain Determines whether the texture has mipmaps or not. A value of 1 (true) means the texture does have mipmaps, and a value of 0 (false) means the texture doesn't have mipmaps.
        * @param nativeTex External native texture pointer to use. Defaults to generating its own internal native texture.
        * @param mipCount Amount of mipmaps to allocate for the texture.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $height: int, $depth: int, $textureFormat: TextureFormat, $mipCount: int, $nativeTex: System.IntPtr)
        /**
        * Create a new empty 3D Texture.
        * @param width Width of texture in pixels.
        * @param height Height of texture in pixels.
        * @param depth Depth of texture in pixels.
        * @param textureFormat Texture data format.
        * @param mipChain Determines whether the texture has mipmaps or not. A value of 1 (true) means the texture does have mipmaps, and a value of 0 (false) means the texture doesn't have mipmaps.
        * @param nativeTex External native texture pointer to use. Defaults to generating its own internal native texture.
        * @param mipCount Amount of mipmaps to allocate for the texture.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $height: int, $depth: int, $textureFormat: TextureFormat, $mipCount: int, $nativeTex: System.IntPtr, $createUninitialized: boolean)
        /**
        * Create a new empty 3D Texture.
        * @param width Width of texture in pixels.
        * @param height Height of texture in pixels.
        * @param depth Depth of texture in pixels.
        * @param textureFormat Texture data format.
        * @param mipChain Determines whether the texture has mipmaps or not. A value of 1 (true) means the texture does have mipmaps, and a value of 0 (false) means the texture doesn't have mipmaps.
        * @param nativeTex External native texture pointer to use. Defaults to generating its own internal native texture.
        * @param mipCount Amount of mipmaps to allocate for the texture.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $height: int, $depth: int, $textureFormat: TextureFormat, $mipChain: boolean)
        /**
        * Create a new empty 3D Texture.
        * @param width Width of texture in pixels.
        * @param height Height of texture in pixels.
        * @param depth Depth of texture in pixels.
        * @param textureFormat Texture data format.
        * @param mipChain Determines whether the texture has mipmaps or not. A value of 1 (true) means the texture does have mipmaps, and a value of 0 (false) means the texture doesn't have mipmaps.
        * @param nativeTex External native texture pointer to use. Defaults to generating its own internal native texture.
        * @param mipCount Amount of mipmaps to allocate for the texture.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $height: int, $depth: int, $textureFormat: TextureFormat, $mipChain: boolean, $createUninitialized: boolean)
        /**
        * Create a new empty 3D Texture.
        * @param width Width of texture in pixels.
        * @param height Height of texture in pixels.
        * @param depth Depth of texture in pixels.
        * @param textureFormat Texture data format.
        * @param mipChain Determines whether the texture has mipmaps or not. A value of 1 (true) means the texture does have mipmaps, and a value of 0 (false) means the texture doesn't have mipmaps.
        * @param nativeTex External native texture pointer to use. Defaults to generating its own internal native texture.
        * @param mipCount Amount of mipmaps to allocate for the texture.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $height: int, $depth: int, $textureFormat: TextureFormat, $mipChain: boolean, $nativeTex: System.IntPtr)
        /**
        * Updates Unity texture to use different native texture object.
        * @param nativeTex Native 3D texture object.
        */
        public UpdateExternalTexture ($nativeTex: System.IntPtr) : void
        /**
        * Gets the pixel color data for a mipmap level as Color structs.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels_EBB7509C_F92D023A
        */
        public GetPixels ($miplevel: int) : Color[]
        /**
        * Gets the pixel color data for a mipmap level as Color structs.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        */
        public GetPixels () : Color[]
        /**
        * Gets the pixel color data for a mipmap level as Color32 structs.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels32_EBB7509C_F92D023A
        */
        public GetPixels32 ($miplevel: int) : Color32[]
        /**
        * Gets the pixel color data for a mipmap level as Color32 structs.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        */
        public GetPixels32 () : Color32[]
        /**
        * Sets the pixel colors of an entire mipmap level.
        * @param colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels_EBB7509C_H813F99E
        */
        public SetPixels ($colors: Color[], $miplevel: int) : void
        /**
        * Sets the pixel colors of an entire mipmap level.
        * @param colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        */
        public SetPixels ($colors: Color[]) : void
        /**
        * Sets the pixel colors of an entire mipmap level.
        * @param colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels32_EBB7509C_H74E0DA77
        */
        public SetPixels32 ($colors: Color32[], $miplevel: int) : void
        /**
        * Sets the pixel colors of an entire mipmap level.
        * @param colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        */
        public SetPixels32 ($colors: Color32[]) : void
        /**
        * Creates Unity Texture out of externally created native texture object.
        * @param nativeTex Native 3D texture object.
        * @param width Width of texture in pixels.
        * @param height Height of texture in pixels.
        * @param depth Depth of texture in pixels
        * @param format Format of underlying texture object.
        * @param mipmap Does the texture have mipmaps?
        */
        public static CreateExternalTexture ($width: int, $height: int, $depth: int, $format: TextureFormat, $mipChain: boolean, $nativeTex: System.IntPtr) : Texture3D
        /**
        * Copies changes you've made in a CPU texture to the GPU.
        * @param updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
        * @param makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
        */
        public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
        public Apply ($updateMipmaps: boolean) : void
        public Apply () : void
        /**
        * Sets the pixel color at coordinates (x, y, z).
        * @param x The x coordinate of the pixel to set. The range is 0 through the (texture width - 1).
        * @param y The y coordinate of the pixel to set. The range is 0 through the (texture height - 1).
        * @param z The z coordinate of the pixel to set. The range is 0 through the (texture depth - 1).
        * @param color The color to set.
        * @param mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixel_EBB7509C_A93C30D0
        */
        public SetPixel ($x: int, $y: int, $z: int, $color: Color) : void
        /**
        * Sets the pixel color at coordinates (x, y, z).
        * @param x The x coordinate of the pixel to set. The range is 0 through the (texture width - 1).
        * @param y The y coordinate of the pixel to set. The range is 0 through the (texture height - 1).
        * @param z The z coordinate of the pixel to set. The range is 0 through the (texture depth - 1).
        * @param color The color to set.
        * @param mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixel_EBB7509C_H5A7C86A3
        */
        public SetPixel ($x: int, $y: int, $z: int, $color: Color, $mipLevel: int) : void
        /**
        * Gets the pixel color at coordinates (x, y, z).
        * @param x The x coordinate of the pixel to get. The range is 0 through the (texture width - 1).
        * @param y The y coordinate of the pixel to get. The range is 0 through the (texture height - 1).
        * @param z The z coordinate of the pixel to get. The range is 0 through the (texture depth - 1).
        * @param mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns The pixel color.
        * @methodSwap GetPixel_EBB7509C_H71E348A6
        */
        public GetPixel ($x: int, $y: int, $z: int) : Color
        /**
        * Gets the pixel color at coordinates (x, y, z).
        * @param x The x coordinate of the pixel to get. The range is 0 through the (texture width - 1).
        * @param y The y coordinate of the pixel to get. The range is 0 through the (texture height - 1).
        * @param z The z coordinate of the pixel to get. The range is 0 through the (texture depth - 1).
        * @param mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns The pixel color.
        * @methodSwap GetPixel_EBB7509C_H7CC42739
        */
        public GetPixel ($x: int, $y: int, $z: int, $mipLevel: int) : Color
        /**
        * Gets the filtered pixel color at the normalized coordinates (u, v, w).
        * @param u The u coordinate of the pixel to get.
        * @param v The v coordinate of the pixel to get.
        * @param w The w coordinate of the pixel to get.
        * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns The pixel color.
        * @methodSwap GetPixelBilinear_EBB7509C_E4172388
        */
        public GetPixelBilinear ($u: float, $v: float, $w: float) : Color
        /**
        * Gets the filtered pixel color at the normalized coordinates (u, v, w).
        * @param u The u coordinate of the pixel to get.
        * @param v The v coordinate of the pixel to get.
        * @param w The w coordinate of the pixel to get.
        * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns The pixel color.
        * @methodSwap GetPixelBilinear_EBB7509C_F9F92CDB
        */
        public GetPixelBilinear ($u: float, $v: float, $w: float, $mipLevel: int) : Color
        /**
        * @methodSwap SetPixelData_EBB7509C_D5108AF9
        */
        public SetPixelData<T> ($data: T[], $mipLevel: int, $sourceDataStartIndex?: int) : void
        /**
        * @methodSwap SetPixelData_EBB7509C_H51A2967A
        */
        public SetPixelData<T> ($data: Unity_Collections.NativeArray$1<T>, $mipLevel: int, $sourceDataStartIndex?: int) : void
        /**
        * Gets the raw data from a texture.
        * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns A native array that points directly to the texture's data buffer in CPU memory.
        */
        public GetPixelData<T> ($mipLevel: int) : Unity_Collections.NativeArray$1<T>
        public constructor ()
    }

    /**
    * Class for handling 2D texture arrays.
    */
    class Texture2DArray extends Texture {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
        */
        public static GenerateAllMips : int
        /**
        * How many mipmap levels are in this Texture (Read Only).
        */
        public get mipmapCount(): int;
        public static get anisotropicFiltering(): AnisotropicFiltering;
        public static set anisotropicFiltering(value: AnisotropicFiltering);
        /**
        * Returns the GraphicsFormat format or color format of a Texture object.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
        * Width of the Texture in pixels (Read Only).
        */
        public get width(): int;
        public set width(value: int);
        /**
        * Height of the Texture in pixels (Read Only).
        */
        public get height(): int;
        public set height(value: int);
        /**
        * Dimensionality (type) of the Texture (Read Only).
        */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
        * Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
        */
        public get isReadable(): boolean;
        /**
        * Texture coordinate wrapping mode.
        */
        public get wrapMode(): TextureWrapMode;
        public set wrapMode(value: TextureWrapMode);
        /**
        * Texture U coordinate wrapping mode.
        */
        public get wrapModeU(): TextureWrapMode;
        public set wrapModeU(value: TextureWrapMode);
        /**
        * Texture V coordinate wrapping mode.
        */
        public get wrapModeV(): TextureWrapMode;
        public set wrapModeV(value: TextureWrapMode);
        /**
        * Texture W coordinate wrapping mode for Texture3D.
        */
        public get wrapModeW(): TextureWrapMode;
        public set wrapModeW(value: TextureWrapMode);
        /**
        * Filtering mode of the Texture.
        */
        public get filterMode(): FilterMode;
        public set filterMode(value: FilterMode);
        /**
        * Defines the anisotropic filtering level of the Texture.
        */
        public get anisoLevel(): int;
        public set anisoLevel(value: int);
        /**
        * The mipmap bias of the Texture.
        */
        public get mipMapBias(): float;
        public set mipMapBias(value: float);
        public get texelSize(): Vector2;
        /**
        * This counter is incremented when the Texture is updated.
        */
        public get updateCount(): uint;
        /**
        * Returns true if the texture pixel data is in sRGB color space (Read Only).
        */
        public get isDataSRGB(): boolean;
        /**
        * The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0.
        * This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually.
        * To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`.
        * `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get totalTextureMemory(): bigint;
        /**
        * The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.
        * For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.
        * The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
        */
        public static get desiredTextureMemory(): bigint;
        /**
        * The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get targetTextureMemory(): bigint;
        /**
        * The amount of memory that all Textures in the scene use.
        */
        public static get currentTextureMemory(): bigint;
        /**
        * The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureMemory(): bigint;
        /**
        * How many times has a Texture been uploaded due to Texture mipmap streaming.
        */
        public static get streamingMipmapUploadCount(): bigint;
        /**
        * Number of renderers registered with the Texture streaming system.
        */
        public static get streamingRendererCount(): bigint;
        /**
        * Number of streaming Textures.
        */
        public static get streamingTextureCount(): bigint;
        /**
        * The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureCount(): bigint;
        /**
        * Number of streaming Textures with outstanding mipmaps to be loaded.
        */
        public static get streamingTexturePendingLoadCount(): bigint;
        /**
        * Number of streaming Textures with mipmaps currently loading.
        */
        public static get streamingTextureLoadingCount(): bigint;
        /**
        * Force streaming Textures to load all mipmap levels.
        */
        public static get streamingTextureForceLoadAll(): boolean;
        public static set streamingTextureForceLoadAll(value: boolean);
        /**
        * This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
        */
        public static get streamingTextureDiscardUnusedMips(): boolean;
        public static set streamingTextureDiscardUnusedMips(value: boolean);
        /**
        * Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
        */
        public static get allowThreadedTextureCreation(): boolean;
        public static set allowThreadedTextureCreation(value: boolean);
        /**
        * Read Only. This property is used as a parameter in some overloads of the CommandBuffer.Blit, Graphics.Blit, CommandBuffer.SetRenderTarget, and Graphics.SetRenderTarget methods to indicate that all texture array slices are bound. The value of this property is -1.
        */
        public static get allSlices(): int;
        /**
        * Number of elements in a texture array (Read Only).
        */
        public get depth(): int;
        /**
        * Texture format (Read Only).
        */
        public get format(): TextureFormat;

        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: int)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $height: int, $depth: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: int)
        /**
        * Create a new texture array.
        * @param width Width of texture array in pixels.
        * @param height Height of texture array in pixels.
        * @param depth Number of elements in the texture array.
        * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
        * @param textureFormat Format of the texture.
        * @param mipChain Should mipmaps be created?
        * @param mipCount Amount of mips to allocate for the texture array.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $height: int, $depth: int, $textureFormat: TextureFormat, $mipCount: int, $linear: boolean, $createUninitialized: boolean)
        /**
        * Create a new texture array.
        * @param width Width of texture array in pixels.
        * @param height Height of texture array in pixels.
        * @param depth Number of elements in the texture array.
        * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
        * @param textureFormat Format of the texture.
        * @param mipChain Should mipmaps be created?
        * @param mipCount Amount of mips to allocate for the texture array.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $height: int, $depth: int, $textureFormat: TextureFormat, $mipCount: int, $linear: boolean)
        /**
        * Create a new texture array.
        * @param width Width of texture array in pixels.
        * @param height Height of texture array in pixels.
        * @param depth Number of elements in the texture array.
        * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
        * @param textureFormat Format of the texture.
        * @param mipChain Should mipmaps be created?
        * @param mipCount Amount of mips to allocate for the texture array.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $height: int, $depth: int, $textureFormat: TextureFormat, $mipChain: boolean, $linear: boolean, $createUninitialized: boolean)
        /**
        * Create a new texture array.
        * @param width Width of texture array in pixels.
        * @param height Height of texture array in pixels.
        * @param depth Number of elements in the texture array.
        * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
        * @param textureFormat Format of the texture.
        * @param mipChain Should mipmaps be created?
        * @param mipCount Amount of mips to allocate for the texture array.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $height: int, $depth: int, $textureFormat: TextureFormat, $mipChain: boolean, $linear: boolean)
        /**
        * Create a new texture array.
        * @param width Width of texture array in pixels.
        * @param height Height of texture array in pixels.
        * @param depth Number of elements in the texture array.
        * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
        * @param textureFormat Format of the texture.
        * @param mipChain Should mipmaps be created?
        * @param mipCount Amount of mips to allocate for the texture array.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $height: int, $depth: int, $textureFormat: TextureFormat, $mipChain: boolean)
        /**
        * Gets the pixel color data for a mipmap level of a slice as Color structs.
        * @param arrayElement The array slice to read pixel data from.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels_EBB7509C_H2CFB2EE5
        */
        public GetPixels ($arrayElement: int, $miplevel: int) : Color[]
        /**
        * Gets the pixel color data for a mipmap level of a slice as Color structs.
        * @param arrayElement The array slice to read pixel data from.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels_EBB7509C_F92D023A
        */
        public GetPixels ($arrayElement: int) : Color[]
        /**
        * Gets the pixel color data for a mipmap level of a slice as Color32 structs.
        * @param arrayElement The array slice to read pixel data from.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels32_EBB7509C_H2CFB2EE5
        */
        public GetPixels32 ($arrayElement: int, $miplevel: int) : Color32[]
        /**
        * Gets the pixel color data for a mipmap level of a slice as Color32 structs.
        * @param arrayElement The array slice to read pixel data from.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels32_EBB7509C_F92D023A
        */
        public GetPixels32 ($arrayElement: int) : Color32[]
        /**
        * Sets the pixel colors of an entire mipmap level of a slice.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param arrayElement The array slice to write to.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels_EBB7509C_H6C48EC51
        */
        public SetPixels ($colors: Color[], $arrayElement: int, $miplevel: int) : void
        /**
        * Sets the pixel colors of an entire mipmap level of a slice.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param arrayElement The array slice to write to.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels_EBB7509C_H813F99E
        */
        public SetPixels ($colors: Color[], $arrayElement: int) : void
        /**
        * Sets the pixel colors of an entire mipmap level of a slice.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param arrayElement The array slice to write colors to.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels32_EBB7509C_E139A550
        */
        public SetPixels32 ($colors: Color32[], $arrayElement: int, $miplevel: int) : void
        /**
        * Sets the pixel colors of an entire mipmap level of a slice.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param arrayElement The array slice to write colors to.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels32_EBB7509C_H74E0DA77
        */
        public SetPixels32 ($colors: Color32[], $arrayElement: int) : void
        /**
        * Copies changes you've made in a CPU texture to the GPU.
        * @param updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
        * @param makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
        */
        public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
        public Apply ($updateMipmaps: boolean) : void
        public Apply () : void
        /**
        * @methodSwap SetPixelData_EBB7509C_H8F715062
        */
        public SetPixelData<T> ($data: T[], $mipLevel: int, $element: int, $sourceDataStartIndex?: int) : void
        /**
        * @methodSwap SetPixelData_EBB7509C_H2855E7A5
        */
        public SetPixelData<T> ($data: Unity_Collections.NativeArray$1<T>, $mipLevel: int, $element: int, $sourceDataStartIndex?: int) : void
        /**
        * Gets the raw data from a texture.
        * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param element The array slice to read from.
        * @returns A native array that points directly to the texture's data buffer in CPU memory.
        */
        public GetPixelData<T> ($mipLevel: int, $element: int) : Unity_Collections.NativeArray$1<T>
        public constructor ()
    }

    /**
    * Class for handling Cubemap arrays.
    */
    class CubemapArray extends Texture {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
        */
        public static GenerateAllMips : int
        /**
        * How many mipmap levels are in this Texture (Read Only).
        */
        public get mipmapCount(): int;
        public static get anisotropicFiltering(): AnisotropicFiltering;
        public static set anisotropicFiltering(value: AnisotropicFiltering);
        /**
        * Returns the GraphicsFormat format or color format of a Texture object.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
        * Width of the Texture in pixels (Read Only).
        */
        public get width(): int;
        public set width(value: int);
        /**
        * Height of the Texture in pixels (Read Only).
        */
        public get height(): int;
        public set height(value: int);
        /**
        * Dimensionality (type) of the Texture (Read Only).
        */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
        * Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
        */
        public get isReadable(): boolean;
        /**
        * Texture coordinate wrapping mode.
        */
        public get wrapMode(): TextureWrapMode;
        public set wrapMode(value: TextureWrapMode);
        /**
        * Texture U coordinate wrapping mode.
        */
        public get wrapModeU(): TextureWrapMode;
        public set wrapModeU(value: TextureWrapMode);
        /**
        * Texture V coordinate wrapping mode.
        */
        public get wrapModeV(): TextureWrapMode;
        public set wrapModeV(value: TextureWrapMode);
        /**
        * Texture W coordinate wrapping mode for Texture3D.
        */
        public get wrapModeW(): TextureWrapMode;
        public set wrapModeW(value: TextureWrapMode);
        /**
        * Filtering mode of the Texture.
        */
        public get filterMode(): FilterMode;
        public set filterMode(value: FilterMode);
        /**
        * Defines the anisotropic filtering level of the Texture.
        */
        public get anisoLevel(): int;
        public set anisoLevel(value: int);
        /**
        * The mipmap bias of the Texture.
        */
        public get mipMapBias(): float;
        public set mipMapBias(value: float);
        public get texelSize(): Vector2;
        /**
        * This counter is incremented when the Texture is updated.
        */
        public get updateCount(): uint;
        /**
        * Returns true if the texture pixel data is in sRGB color space (Read Only).
        */
        public get isDataSRGB(): boolean;
        /**
        * The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0.
        * This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually.
        * To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`.
        * `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get totalTextureMemory(): bigint;
        /**
        * The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.
        * For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.
        * The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
        */
        public static get desiredTextureMemory(): bigint;
        /**
        * The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get targetTextureMemory(): bigint;
        /**
        * The amount of memory that all Textures in the scene use.
        */
        public static get currentTextureMemory(): bigint;
        /**
        * The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureMemory(): bigint;
        /**
        * How many times has a Texture been uploaded due to Texture mipmap streaming.
        */
        public static get streamingMipmapUploadCount(): bigint;
        /**
        * Number of renderers registered with the Texture streaming system.
        */
        public static get streamingRendererCount(): bigint;
        /**
        * Number of streaming Textures.
        */
        public static get streamingTextureCount(): bigint;
        /**
        * The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureCount(): bigint;
        /**
        * Number of streaming Textures with outstanding mipmaps to be loaded.
        */
        public static get streamingTexturePendingLoadCount(): bigint;
        /**
        * Number of streaming Textures with mipmaps currently loading.
        */
        public static get streamingTextureLoadingCount(): bigint;
        /**
        * Force streaming Textures to load all mipmap levels.
        */
        public static get streamingTextureForceLoadAll(): boolean;
        public static set streamingTextureForceLoadAll(value: boolean);
        /**
        * This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
        */
        public static get streamingTextureDiscardUnusedMips(): boolean;
        public static set streamingTextureDiscardUnusedMips(value: boolean);
        /**
        * Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
        */
        public static get allowThreadedTextureCreation(): boolean;
        public static set allowThreadedTextureCreation(value: boolean);
        /**
        * Number of cubemaps in the array (Read Only).
        */
        public get cubemapCount(): int;
        /**
        * Texture format (Read Only).
        */
        public get format(): TextureFormat;

        public constructor ($width: int, $cubemapCount: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $cubemapCount: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: int)
        public constructor ($width: int, $cubemapCount: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags)
        public constructor ($width: int, $cubemapCount: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: int)
        /**
        * Create a new cubemap array.
        * @param cubemapCount Number of elements in the cubemap array.
        * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
        * @param width Width of each cubemap face.
        * @param textureFormat Format of the cubemaps.
        * @param mipChain Should mipmaps be generated ?
        * @param mipCount Amount of mipmaps to generate.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $cubemapCount: int, $textureFormat: TextureFormat, $mipCount: int, $linear: boolean, $createUninitialized: boolean)
        /**
        * Create a new cubemap array.
        * @param cubemapCount Number of elements in the cubemap array.
        * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
        * @param width Width of each cubemap face.
        * @param textureFormat Format of the cubemaps.
        * @param mipChain Should mipmaps be generated ?
        * @param mipCount Amount of mipmaps to generate.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $cubemapCount: int, $textureFormat: TextureFormat, $mipCount: int, $linear: boolean)
        /**
        * Create a new cubemap array.
        * @param cubemapCount Number of elements in the cubemap array.
        * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
        * @param width Width of each cubemap face.
        * @param textureFormat Format of the cubemaps.
        * @param mipChain Should mipmaps be generated ?
        * @param mipCount Amount of mipmaps to generate.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $cubemapCount: int, $textureFormat: TextureFormat, $mipChain: boolean, $linear: boolean, $createUninitialized: boolean)
        /**
        * Create a new cubemap array.
        * @param cubemapCount Number of elements in the cubemap array.
        * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
        * @param width Width of each cubemap face.
        * @param textureFormat Format of the cubemaps.
        * @param mipChain Should mipmaps be generated ?
        * @param mipCount Amount of mipmaps to generate.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $cubemapCount: int, $textureFormat: TextureFormat, $mipChain: boolean, $linear: boolean)
        /**
        * Create a new cubemap array.
        * @param cubemapCount Number of elements in the cubemap array.
        * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
        * @param width Width of each cubemap face.
        * @param textureFormat Format of the cubemaps.
        * @param mipChain Should mipmaps be generated ?
        * @param mipCount Amount of mipmaps to generate.
        * @param createUninitialized Use this flag to create the texture with uninitialized data. When overriding all texels anyway, this can lead to improved performance and reduced memory usage.
        */
        public constructor ($width: int, $cubemapCount: int, $textureFormat: TextureFormat, $mipChain: boolean)
        /**
        * Gets the pixel color data for a mipmap level of a face of a slice as Color structs.
        * @param face The CubemapFace to read from.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param arrayElement The array slice to read pixel data from.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels_EBB7509C_H6FD174A
        */
        public GetPixels ($face: CubemapFace, $arrayElement: int, $miplevel: int) : Color[]
        /**
        * Gets the pixel color data for a mipmap level of a face of a slice as Color structs.
        * @param face The CubemapFace to read from.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param arrayElement The array slice to read pixel data from.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels_EBB7509C_H748E2F61
        */
        public GetPixels ($face: CubemapFace, $arrayElement: int) : Color[]
        /**
        * Gets the pixel color data for a mipmap level of a face of a slice as Color32 structs.
        * @param face The CubemapFace to read pixel data from.
        * @param arrayElement The array slice to read pixel data from.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels32_EBB7509C_H6FD174A
        */
        public GetPixels32 ($face: CubemapFace, $arrayElement: int, $miplevel: int) : Color32[]
        /**
        * Gets the pixel color data for a mipmap level of a face of a slice as Color32 structs.
        * @param face The CubemapFace to read pixel data from.
        * @param arrayElement The array slice to read pixel data from.
        * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @returns An array that contains the pixel colors.
        * @methodSwap GetPixels32_EBB7509C_H748E2F61
        */
        public GetPixels32 ($face: CubemapFace, $arrayElement: int) : Color32[]
        /**
        * Sets the pixel colors of an entire mipmap level of a face of a slice.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param face The CubemapFace to write colors to.
        * @param arrayElement The array slice to write colors to.
        * @methodSwap SetPixels_EBB7509C_H4CFFB966
        */
        public SetPixels ($colors: Color[], $face: CubemapFace, $arrayElement: int, $miplevel: int) : void
        /**
        * Sets the pixel colors of an entire mipmap level of a face of a slice.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param face The CubemapFace to write colors to.
        * @param arrayElement The array slice to write colors to.
        * @methodSwap SetPixels_EBB7509C_H78407925
        */
        public SetPixels ($colors: Color[], $face: CubemapFace, $arrayElement: int) : void
        /**
        * Sets the pixel colors of an entire mipmap level of a face of a slice.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param face The CubemapFace to write colors to.
        * @param arrayElement The array slice to write colors to.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels32_EBB7509C_E489AE11
        */
        public SetPixels32 ($colors: Color32[], $face: CubemapFace, $arrayElement: int, $miplevel: int) : void
        /**
        * Sets the pixel colors of an entire mipmap level of a face of a slice.
        * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
        * @param face The CubemapFace to write colors to.
        * @param arrayElement The array slice to write colors to.
        * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @methodSwap SetPixels32_EBB7509C_E3DEB6DE
        */
        public SetPixels32 ($colors: Color32[], $face: CubemapFace, $arrayElement: int) : void
        /**
        * Copies changes you've made in a CPU texture to the GPU.
        * @param updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
        * @param makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
        */
        public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
        public Apply ($updateMipmaps: boolean) : void
        public Apply () : void
        /**
        * @methodSwap SetPixelData_EBB7509C_H2C9CDC43
        */
        public SetPixelData<T> ($data: T[], $mipLevel: int, $face: CubemapFace, $element: int, $sourceDataStartIndex?: int) : void
        /**
        * @methodSwap SetPixelData_EBB7509C_H3C9CCD8A
        */
        public SetPixelData<T> ($data: Unity_Collections.NativeArray$1<T>, $mipLevel: int, $face: CubemapFace, $element: int, $sourceDataStartIndex?: int) : void
        /**
        * Gets the raw data from a texture.
        * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param face The CubemapFace to read from.
        * @param element The array slice to read from.
        * @returns A native array that points directly to the texture's data buffer in CPU memory.
        */
        public GetPixelData<T> ($mipLevel: int, $face: CubemapFace, $element: int) : Unity_Collections.NativeArray$1<T>
        public constructor ()
    }

    /**
    * Class for handling Sparse Textures.
    */
    class SparseTexture extends Texture {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
        */
        public static GenerateAllMips : int
        /**
        * How many mipmap levels are in this Texture (Read Only).
        */
        public get mipmapCount(): int;
        public static get anisotropicFiltering(): AnisotropicFiltering;
        public static set anisotropicFiltering(value: AnisotropicFiltering);
        /**
        * Returns the GraphicsFormat format or color format of a Texture object.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
        * Width of the Texture in pixels (Read Only).
        */
        public get width(): int;
        public set width(value: int);
        /**
        * Height of the Texture in pixels (Read Only).
        */
        public get height(): int;
        public set height(value: int);
        /**
        * Dimensionality (type) of the Texture (Read Only).
        */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
        * Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
        */
        public get isReadable(): boolean;
        /**
        * Texture coordinate wrapping mode.
        */
        public get wrapMode(): TextureWrapMode;
        public set wrapMode(value: TextureWrapMode);
        /**
        * Texture U coordinate wrapping mode.
        */
        public get wrapModeU(): TextureWrapMode;
        public set wrapModeU(value: TextureWrapMode);
        /**
        * Texture V coordinate wrapping mode.
        */
        public get wrapModeV(): TextureWrapMode;
        public set wrapModeV(value: TextureWrapMode);
        /**
        * Texture W coordinate wrapping mode for Texture3D.
        */
        public get wrapModeW(): TextureWrapMode;
        public set wrapModeW(value: TextureWrapMode);
        /**
        * Filtering mode of the Texture.
        */
        public get filterMode(): FilterMode;
        public set filterMode(value: FilterMode);
        /**
        * Defines the anisotropic filtering level of the Texture.
        */
        public get anisoLevel(): int;
        public set anisoLevel(value: int);
        /**
        * The mipmap bias of the Texture.
        */
        public get mipMapBias(): float;
        public set mipMapBias(value: float);
        public get texelSize(): Vector2;
        /**
        * This counter is incremented when the Texture is updated.
        */
        public get updateCount(): uint;
        /**
        * Returns true if the texture pixel data is in sRGB color space (Read Only).
        */
        public get isDataSRGB(): boolean;
        /**
        * The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0.
        * This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually.
        * To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`.
        * `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get totalTextureMemory(): bigint;
        /**
        * The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.
        * For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.
        * The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
        */
        public static get desiredTextureMemory(): bigint;
        /**
        * The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get targetTextureMemory(): bigint;
        /**
        * The amount of memory that all Textures in the scene use.
        */
        public static get currentTextureMemory(): bigint;
        /**
        * The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureMemory(): bigint;
        /**
        * How many times has a Texture been uploaded due to Texture mipmap streaming.
        */
        public static get streamingMipmapUploadCount(): bigint;
        /**
        * Number of renderers registered with the Texture streaming system.
        */
        public static get streamingRendererCount(): bigint;
        /**
        * Number of streaming Textures.
        */
        public static get streamingTextureCount(): bigint;
        /**
        * The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
        */
        public static get nonStreamingTextureCount(): bigint;
        /**
        * Number of streaming Textures with outstanding mipmaps to be loaded.
        */
        public static get streamingTexturePendingLoadCount(): bigint;
        /**
        * Number of streaming Textures with mipmaps currently loading.
        */
        public static get streamingTextureLoadingCount(): bigint;
        /**
        * Force streaming Textures to load all mipmap levels.
        */
        public static get streamingTextureForceLoadAll(): boolean;
        public static set streamingTextureForceLoadAll(value: boolean);
        /**
        * This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
        */
        public static get streamingTextureDiscardUnusedMips(): boolean;
        public static set streamingTextureDiscardUnusedMips(value: boolean);
        /**
        * Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
        */
        public static get allowThreadedTextureCreation(): boolean;
        public static set allowThreadedTextureCreation(value: boolean);
        /**
        * Get sparse texture tile width (Read Only).
        */
        public get tileWidth(): int;
        /**
        * Get sparse texture tile height (Read Only).
        */
        public get tileHeight(): int;
        /**
        * Is the sparse texture actually created? (Read Only)
        */
        public get isCreated(): boolean;

        public constructor ($width: int, $height: int, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $mipCount: int)
        public constructor ($width: int, $height: int, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: int)
        /**
        * Create a sparse texture.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param mipCount Mipmap count. Pass -1 to create full mipmap chain.
        * @param linear Whether texture data will be in linear or sRGB color space (default is sRGB).
        * @param textureFormat Texture Format.
        */
        public constructor ($width: int, $height: int, $textureFormat: TextureFormat, $mipCount: int)
        /**
        * Create a sparse texture.
        * @param width Texture width in pixels.
        * @param height Texture height in pixels.
        * @param mipCount Mipmap count. Pass -1 to create full mipmap chain.
        * @param linear Whether texture data will be in linear or sRGB color space (default is sRGB).
        * @param textureFormat Texture Format.
        */
        public constructor ($width: int, $height: int, $textureFormat: TextureFormat, $mipCount: int, $linear: boolean)
        /**
        * Update sparse texture tile with color values.
        * @param tileX Tile X coordinate.
        * @param tileY Tile Y coordinate.
        * @param miplevel Mipmap level of the texture.
        * @param data Tile color data.
        */
        public UpdateTile ($tileX: int, $tileY: int, $miplevel: int, $data: Color32[]) : void
        /**
        * Update sparse texture tile with raw pixel values.
        * @param tileX Tile X coordinate.
        * @param tileY Tile Y coordinate.
        * @param miplevel Mipmap level of the texture.
        * @param data Tile raw pixel data.
        */
        public UpdateTileRaw ($tileX: int, $tileY: int, $miplevel: int, $data: byte[]) : void
        /**
        * Unload sparse texture tile.
        * @param tileX Tile X coordinate.
        * @param tileY Tile Y coordinate.
        * @param miplevel Mipmap level of the texture.
        */
        public UnloadTile ($tileX: int, $tileY: int, $miplevel: int) : void
        public constructor ()
    }

    /**
    * Describes options for displaying movie playback controls.
    */
    enum FullScreenMovieControlMode {
        Full = 0,
        Minimal = 1,
        CancelOnInput = 2,
        Hidden = 3 
    }

    /**
    * Describes scaling modes for displaying movies.
    */
    enum FullScreenMovieScalingMode {
        None = 0,
        AspectFit = 1,
        AspectFill = 2,
        Fill = 3 
    }

    /**
    * Represents  a 128-bit hash value.
    */
    class Hash128 extends System.ValueType implements System.IComparable, System.IComparable$1<Hash128>, System.IEquatable$1<Hash128> {

        /**
        * Returns true is the hash value is valid. (Read Only)
        */
        public get isValid(): boolean;

        /**
        * Directly initialize a Hash128 with a 128-bit value.
        * @param u32_0 First 32 bits of hash value.
        * @param u32_1 Second 32 bits of hash value.
        * @param u32_2 Third 32 bits of hash value.
        * @param u32_3 Fourth 32 bits of hash value.
        * @param u64_0 First 64 bits of hash value.
        * @param u64_1 Second 64 bits of hash value.
        */
        public constructor ($u32_0: uint, $u32_1: uint, $u32_2: uint, $u32_3: uint)
        /**
        * Directly initialize a Hash128 with a 128-bit value.
        * @param u32_0 First 32 bits of hash value.
        * @param u32_1 Second 32 bits of hash value.
        * @param u32_2 Third 32 bits of hash value.
        * @param u32_3 Fourth 32 bits of hash value.
        * @param u64_0 First 64 bits of hash value.
        * @param u64_1 Second 64 bits of hash value.
        */
        public constructor ($u64_0: bigint, $u64_1: bigint)
        public CompareTo ($rhs: Hash128) : int
        /**
        * Convert a Hash128 to string.
        */
        public ToString () : string
        /**
        * Convert a hex-encoded string into Hash128 value.
        * @param hashString A hexadecimal-encoded hash string.
        * @returns The 128-bit hash.
        */
        public static Parse ($hashString: string) : Hash128
        /**
        * Compute a hash of input data string.
        * @param data Input data string. Note that Unity interprets the string as UTF-8 data, even if internally in C# strings are UTF-16.
        * @returns The 128-bit hash.
        */
        public static Compute ($data: string) : Hash128
        public static Compute<T> ($data: Unity_Collections.NativeArray$1<T>) : Hash128
        /**
        * @methodSwap Compute_EBB7509C_H51A2967A
        */
        public static Compute<T> ($data: Unity_Collections.NativeArray$1<T>, $start: int, $count: int) : Hash128
        public static Compute<T> ($data: T[]) : Hash128
        /**
        * @methodSwap Compute_EBB7509C_D5108AF9
        */
        public static Compute<T> ($data: T[], $start: int, $count: int) : Hash128
        public static Compute<T> ($data: System_Collections_Generic.List$1<T>) : Hash128
        /**
        * @methodSwap Compute_EBB7509C_H7B64D5A3
        */
        public static Compute<T> ($data: System_Collections_Generic.List$1<T>, $start: int, $count: int) : Hash128
        public static Compute<T> ($val: $Ref<T>) : Hash128
        /**
        * Compute a hash of input data.
        * @param val Input value.
        * @returns The 128-bit hash.
        * @methodSwap Compute_EBB7509C_F92D023A
        */
        public static Compute ($val: int) : Hash128
        /**
        * Compute a hash of input data.
        * @param val Input value.
        * @returns The 128-bit hash.
        * @methodSwap Compute_EBB7509C_H82424F3E
        */
        public static Compute ($val: float) : Hash128
        /**
        * Hash new input string and combine with the current hash value.
        * @param data Input data string. Note that Unity interprets the string as UTF-8 data, even if internally in C# strings are UTF-16.
        */
        public Append ($data: string) : void
        public Append<T> ($data: Unity_Collections.NativeArray$1<T>) : void
        /**
        * @methodSwap Append_EBB7509C_H51A2967A
        */
        public Append<T> ($data: Unity_Collections.NativeArray$1<T>, $start: int, $count: int) : void
        public Append<T> ($data: T[]) : void
        /**
        * @methodSwap Append_EBB7509C_D5108AF9
        */
        public Append<T> ($data: T[], $start: int, $count: int) : void
        public Append<T> ($data: System_Collections_Generic.List$1<T>) : void
        /**
        * @methodSwap Append_EBB7509C_H7B64D5A3
        */
        public Append<T> ($data: System_Collections_Generic.List$1<T>, $start: int, $count: int) : void
        public Append<T> ($val: $Ref<T>) : void
        /**
        * Hash new input data and combine with the current hash value.
        * @param val Input value.
        * @methodSwap Append_EBB7509C_F92D023A
        */
        public Append ($val: int) : void
        /**
        * Hash new input data and combine with the current hash value.
        * @param val Input value.
        * @methodSwap Append_EBB7509C_H82424F3E
        */
        public Append ($val: float) : void
        public Equals ($obj: any) : boolean
        public Equals ($obj: Hash128) : boolean
        public GetHashCode () : int
        public CompareTo ($obj: any) : int
        public static op_Equality ($hash1: Hash128, $hash2: Hash128) : boolean
        public static op_Inequality ($hash1: Hash128, $hash2: Hash128) : boolean
        public static op_LessThan ($x: Hash128, $y: Hash128) : boolean
        public static op_GreaterThan ($x: Hash128, $y: Hash128) : boolean
    }

    /**
    * Utilities to compute hashes.
    */
    class HashUtilities {

        /**
        * Append inHash in outHash.
        * @param inHash Hash to append.
        * @param outHash Hash that will be updated.
        */
        public static AppendHash ($inHash: $Ref<Hash128>, $outHash: $Ref<Hash128>) : void
        /**
        * Compute a Hash128 of a Matrix4x4.
        * @param value The Matrix4x4 to hash.
        * @param hash The computed hash.
        */
        public static QuantisedMatrixHash ($value: $Ref<Matrix4x4>, $hash: $Ref<Hash128>) : void
        /**
        * Compute a Hash128 of a Vector3.
        * @param hash The Vector3 to hash.
        * @param value The computed hash.
        */
        public static QuantisedVectorHash ($value: $Ref<Vector3>, $hash: $Ref<Hash128>) : void
        public static ComputeHash128<T> ($value: $Ref<T>, $hash: $Ref<Hash128>) : void
        /**
        * Compute a 128 bit hash based on a value. the type of the value must be a value type.
        * @param value A reference to the value to hash.
        * @param hash A reference to the Hash128 to updated with the computed hash.
        */
        public static ComputeHash128 ($value: byte[], $hash: $Ref<Hash128>) : void
    }

    /**
    * Utilities to compute hashes with unsafe code.
    */
    class HashUnsafeUtilities {

    }

    /**
    * Determines whether the mouse cursor is rendered using software rendering or, on supported platforms, hardware rendering.
    */
    enum CursorMode {
        Auto = 0,
        ForceSoftware = 1 
    }

    /**
    * How the cursor should behave.
    */
    enum CursorLockMode {
        None = 0,
        Locked = 1,
        Confined = 2 
    }

    /**
    * Cursor API for setting the cursor (mouse pointer).
    */
    class Cursor extends System.Object {

        /**
        * Determines whether the hardware pointer is visible or not.
        */
        public static get visible(): boolean;
        public static set visible(value: boolean);
        /**
        * Determines whether the hardware pointer is locked to the center of the view, constrained to the window, or not constrained at all.
        */
        public static get lockState(): CursorLockMode;
        public static set lockState(value: CursorLockMode);

        public constructor ()
        /**
        * Sets a custom cursor to use as your cursor.
        * @param texture The texture to use for the cursor. To use a texture, import it with `Read/Write` enabled. Alternatively, you can use the default cursor import setting. If you created your cursor texture from code, it must be in RGBA32 format, have alphaIsTransparency enabled, and have no mip chain. To use the default cursor, set the texture to `Null`.
        * @param hotspot The offset from the top left of the texture to use as the target point. This must be in the bounds of the cursor.
        * @param cursorMode Whether to render this cursor as a hardware cursor on supported platforms, or force software cursor.
        */
        public static SetCursor ($texture: Texture2D, $hotspot: Vector2, $cursorMode: CursorMode) : void
    }

    /**
    * Key codes returned by Event.keyCode. These map directly to a physical key on the keyboard. If "Use Physical Keys" is enabled in, these map directly to a physical key on the keyboard. If "Use Physical Keys" is disabled these map to language dependent mapping, different for every platform and cannot be guaranteed to work. "Use Physical Keys" is enabled by default from 2022.1
    */
    enum KeyCode {
        None = 0,
        Backspace = 8,
        Delete = 127,
        Tab = 9,
        Clear = 12,
        Return = 13,
        Pause = 19,
        Escape = 27,
        Space = 32,
        Keypad0 = 256,
        Keypad1 = 257,
        Keypad2 = 258,
        Keypad3 = 259,
        Keypad4 = 260,
        Keypad5 = 261,
        Keypad6 = 262,
        Keypad7 = 263,
        Keypad8 = 264,
        Keypad9 = 265,
        KeypadPeriod = 266,
        KeypadDivide = 267,
        KeypadMultiply = 268,
        KeypadMinus = 269,
        KeypadPlus = 270,
        KeypadEnter = 271,
        KeypadEquals = 272,
        UpArrow = 273,
        DownArrow = 274,
        RightArrow = 275,
        LeftArrow = 276,
        Insert = 277,
        Home = 278,
        End = 279,
        PageUp = 280,
        PageDown = 281,
        F1 = 282,
        F2 = 283,
        F3 = 284,
        F4 = 285,
        F5 = 286,
        F6 = 287,
        F7 = 288,
        F8 = 289,
        F9 = 290,
        F10 = 291,
        F11 = 292,
        F12 = 293,
        F13 = 294,
        F14 = 295,
        F15 = 296,
        Alpha0 = 48,
        Alpha1 = 49,
        Alpha2 = 50,
        Alpha3 = 51,
        Alpha4 = 52,
        Alpha5 = 53,
        Alpha6 = 54,
        Alpha7 = 55,
        Alpha8 = 56,
        Alpha9 = 57,
        Exclaim = 33,
        DoubleQuote = 34,
        Hash = 35,
        Dollar = 36,
        Percent = 37,
        Ampersand = 38,
        Quote = 39,
        LeftParen = 40,
        RightParen = 41,
        Asterisk = 42,
        Plus = 43,
        Comma = 44,
        Minus = 45,
        Period = 46,
        Slash = 47,
        Colon = 58,
        Semicolon = 59,
        Less = 60,
        Equals = 61,
        Greater = 62,
        Question = 63,
        At = 64,
        LeftBracket = 91,
        Backslash = 92,
        RightBracket = 93,
        Caret = 94,
        Underscore = 95,
        BackQuote = 96,
        A = 97,
        B = 98,
        C = 99,
        D = 100,
        E = 101,
        F = 102,
        G = 103,
        H = 104,
        I = 105,
        J = 106,
        K = 107,
        L = 108,
        M = 109,
        N = 110,
        O = 111,
        P = 112,
        Q = 113,
        R = 114,
        S = 115,
        T = 116,
        U = 117,
        V = 118,
        W = 119,
        X = 120,
        Y = 121,
        Z = 122,
        LeftCurlyBracket = 123,
        Pipe = 124,
        RightCurlyBracket = 125,
        Tilde = 126,
        Numlock = 300,
        CapsLock = 301,
        ScrollLock = 302,
        RightShift = 303,
        LeftShift = 304,
        RightControl = 305,
        LeftControl = 306,
        RightAlt = 307,
        LeftAlt = 308,
        LeftMeta = 310,
        LeftCommand = 310,
        LeftApple = 310,
        LeftWindows = 311,
        RightMeta = 309,
        RightCommand = 309,
        RightApple = 309,
        RightWindows = 312,
        AltGr = 313,
        Help = 315,
        Print = 316,
        SysReq = 317,
        Break = 318,
        Menu = 319,
        Mouse0 = 323,
        Mouse1 = 324,
        Mouse2 = 325,
        Mouse3 = 326,
        Mouse4 = 327,
        Mouse5 = 328,
        Mouse6 = 329,
        JoystickButton0 = 330,
        JoystickButton1 = 331,
        JoystickButton2 = 332,
        JoystickButton3 = 333,
        JoystickButton4 = 334,
        JoystickButton5 = 335,
        JoystickButton6 = 336,
        JoystickButton7 = 337,
        JoystickButton8 = 338,
        JoystickButton9 = 339,
        JoystickButton10 = 340,
        JoystickButton11 = 341,
        JoystickButton12 = 342,
        JoystickButton13 = 343,
        JoystickButton14 = 344,
        JoystickButton15 = 345,
        JoystickButton16 = 346,
        JoystickButton17 = 347,
        JoystickButton18 = 348,
        JoystickButton19 = 349,
        Joystick1Button0 = 350,
        Joystick1Button1 = 351,
        Joystick1Button2 = 352,
        Joystick1Button3 = 353,
        Joystick1Button4 = 354,
        Joystick1Button5 = 355,
        Joystick1Button6 = 356,
        Joystick1Button7 = 357,
        Joystick1Button8 = 358,
        Joystick1Button9 = 359,
        Joystick1Button10 = 360,
        Joystick1Button11 = 361,
        Joystick1Button12 = 362,
        Joystick1Button13 = 363,
        Joystick1Button14 = 364,
        Joystick1Button15 = 365,
        Joystick1Button16 = 366,
        Joystick1Button17 = 367,
        Joystick1Button18 = 368,
        Joystick1Button19 = 369,
        Joystick2Button0 = 370,
        Joystick2Button1 = 371,
        Joystick2Button2 = 372,
        Joystick2Button3 = 373,
        Joystick2Button4 = 374,
        Joystick2Button5 = 375,
        Joystick2Button6 = 376,
        Joystick2Button7 = 377,
        Joystick2Button8 = 378,
        Joystick2Button9 = 379,
        Joystick2Button10 = 380,
        Joystick2Button11 = 381,
        Joystick2Button12 = 382,
        Joystick2Button13 = 383,
        Joystick2Button14 = 384,
        Joystick2Button15 = 385,
        Joystick2Button16 = 386,
        Joystick2Button17 = 387,
        Joystick2Button18 = 388,
        Joystick2Button19 = 389,
        Joystick3Button0 = 390,
        Joystick3Button1 = 391,
        Joystick3Button2 = 392,
        Joystick3Button3 = 393,
        Joystick3Button4 = 394,
        Joystick3Button5 = 395,
        Joystick3Button6 = 396,
        Joystick3Button7 = 397,
        Joystick3Button8 = 398,
        Joystick3Button9 = 399,
        Joystick3Button10 = 400,
        Joystick3Button11 = 401,
        Joystick3Button12 = 402,
        Joystick3Button13 = 403,
        Joystick3Button14 = 404,
        Joystick3Button15 = 405,
        Joystick3Button16 = 406,
        Joystick3Button17 = 407,
        Joystick3Button18 = 408,
        Joystick3Button19 = 409,
        Joystick4Button0 = 410,
        Joystick4Button1 = 411,
        Joystick4Button2 = 412,
        Joystick4Button3 = 413,
        Joystick4Button4 = 414,
        Joystick4Button5 = 415,
        Joystick4Button6 = 416,
        Joystick4Button7 = 417,
        Joystick4Button8 = 418,
        Joystick4Button9 = 419,
        Joystick4Button10 = 420,
        Joystick4Button11 = 421,
        Joystick4Button12 = 422,
        Joystick4Button13 = 423,
        Joystick4Button14 = 424,
        Joystick4Button15 = 425,
        Joystick4Button16 = 426,
        Joystick4Button17 = 427,
        Joystick4Button18 = 428,
        Joystick4Button19 = 429,
        Joystick5Button0 = 430,
        Joystick5Button1 = 431,
        Joystick5Button2 = 432,
        Joystick5Button3 = 433,
        Joystick5Button4 = 434,
        Joystick5Button5 = 435,
        Joystick5Button6 = 436,
        Joystick5Button7 = 437,
        Joystick5Button8 = 438,
        Joystick5Button9 = 439,
        Joystick5Button10 = 440,
        Joystick5Button11 = 441,
        Joystick5Button12 = 442,
        Joystick5Button13 = 443,
        Joystick5Button14 = 444,
        Joystick5Button15 = 445,
        Joystick5Button16 = 446,
        Joystick5Button17 = 447,
        Joystick5Button18 = 448,
        Joystick5Button19 = 449,
        Joystick6Button0 = 450,
        Joystick6Button1 = 451,
        Joystick6Button2 = 452,
        Joystick6Button3 = 453,
        Joystick6Button4 = 454,
        Joystick6Button5 = 455,
        Joystick6Button6 = 456,
        Joystick6Button7 = 457,
        Joystick6Button8 = 458,
        Joystick6Button9 = 459,
        Joystick6Button10 = 460,
        Joystick6Button11 = 461,
        Joystick6Button12 = 462,
        Joystick6Button13 = 463,
        Joystick6Button14 = 464,
        Joystick6Button15 = 465,
        Joystick6Button16 = 466,
        Joystick6Button17 = 467,
        Joystick6Button18 = 468,
        Joystick6Button19 = 469,
        Joystick7Button0 = 470,
        Joystick7Button1 = 471,
        Joystick7Button2 = 472,
        Joystick7Button3 = 473,
        Joystick7Button4 = 474,
        Joystick7Button5 = 475,
        Joystick7Button6 = 476,
        Joystick7Button7 = 477,
        Joystick7Button8 = 478,
        Joystick7Button9 = 479,
        Joystick7Button10 = 480,
        Joystick7Button11 = 481,
        Joystick7Button12 = 482,
        Joystick7Button13 = 483,
        Joystick7Button14 = 484,
        Joystick7Button15 = 485,
        Joystick7Button16 = 486,
        Joystick7Button17 = 487,
        Joystick7Button18 = 488,
        Joystick7Button19 = 489,
        Joystick8Button0 = 490,
        Joystick8Button1 = 491,
        Joystick8Button2 = 492,
        Joystick8Button3 = 493,
        Joystick8Button4 = 494,
        Joystick8Button5 = 495,
        Joystick8Button6 = 496,
        Joystick8Button7 = 497,
        Joystick8Button8 = 498,
        Joystick8Button9 = 499,
        Joystick8Button10 = 500,
        Joystick8Button11 = 501,
        Joystick8Button12 = 502,
        Joystick8Button13 = 503,
        Joystick8Button14 = 504,
        Joystick8Button15 = 505,
        Joystick8Button16 = 506,
        Joystick8Button17 = 507,
        Joystick8Button18 = 508,
        Joystick8Button19 = 509 
    }

    /**
    * Initializes a new instance of the Logger.
    */
    class Logger extends System.Object implements ILogger {

        /**
        * Set  Logger.ILogHandler.
        */
        public get logHandler(): ILogHandler;
        public set logHandler(value: ILogHandler);
        /**
        * To runtime toggle debug logging [ON/OFF].
        */
        public get logEnabled(): boolean;
        public set logEnabled(value: boolean);
        /**
        * To selective enable debug log message.
        */
        public get filterLogType(): LogType;
        public set filterLogType(value: LogType);

        /**
        * Create a custom Logger.
        * @param logHandler Pass in default log handler or custom log handler.
        */
        public constructor ($logHandler: ILogHandler)
        /**
        * Check logging is enabled based on the LogType.
        * @param logType The type of the log message.
        * @returns Retrun true in case logs of LogType will be logged otherwise returns false.
        */
        public IsLogTypeAllowed ($logType: LogType) : boolean
        /**
        * Logs message to the Unity Console using default logger.
        * @param logType The type of the log message.
        * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public Log ($logType: LogType, $message: any) : void
        /**
        * Logs message to the Unity Console using default logger.
        * @param logType The type of the log message.
        * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public Log ($logType: LogType, $message: any, $context: Object) : void
        /**
        * Logs message to the Unity Console using default logger.
        * @param logType The type of the log message.
        * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public Log ($logType: LogType, $tag: string, $message: any) : void
        /**
        * Logs message to the Unity Console using default logger.
        * @param logType The type of the log message.
        * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public Log ($logType: LogType, $tag: string, $message: any, $context: Object) : void
        /**
        * Logs message to the Unity Console using default logger.
        * @param logType The type of the log message.
        * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public Log ($message: any) : void
        /**
        * Logs message to the Unity Console using default logger.
        * @param logType The type of the log message.
        * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public Log ($tag: string, $message: any) : void
        /**
        * Logs message to the Unity Console using default logger.
        * @param logType The type of the log message.
        * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public Log ($tag: string, $message: any, $context: Object) : void
        /**
        * A variant of Logger.Log that logs an warning message.
        * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public LogWarning ($tag: string, $message: any) : void
        /**
        * A variant of Logger.Log that logs an warning message.
        * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public LogWarning ($tag: string, $message: any, $context: Object) : void
        /**
        * A variant of Logger.Log that logs an error message.
        * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public LogError ($tag: string, $message: any) : void
        /**
        * A variant of Logger.Log that logs an error message.
        * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
        * @param message String or object to be converted to string representation for display.
        * @param context Object to which the message applies.
        */
        public LogError ($tag: string, $message: any, $context: Object) : void
        /**
        * A variant of Logger.Log that logs an exception message.
        * @param exception Runtime Exception.
        * @param context Object to which the message applies.
        */
        public LogException ($exception: System.Exception) : void
        /**
        * A variant of Logger.Log that logs an exception message.
        * @param exception Runtime Exception.
        * @param context Object to which the message applies.
        */
        public LogException ($exception: System.Exception, $context: Object) : void
        /**
        * Logs a formatted message.
        * @param logType The type of the log message.
        * @param context Object to which the message applies.
        * @param format A composite format string.
        * @param args Format arguments.
        */
        public LogFormat ($logType: LogType, $format: string, ...args: any[]) : void
        /**
        * Logs a formatted message.
        * @param logType The type of the log message.
        * @param context Object to which the message applies.
        * @param format A composite format string.
        * @param args Format arguments.
        */
        public LogFormat ($logType: LogType, $context: Object, $format: string, ...args: any[]) : void
    }

    /**
    * A collection of common color functions.
    */
    class ColorUtility extends System.Object {

        public constructor ()
        /**
        * Attempts to convert a html color string.
        * @param htmlString Case insensitive html string to be converted into a color.
        * @param color The converted color.
        * @returns True if the string was successfully converted else false.
        */
        public static TryParseHtmlString ($htmlString: string, $color: $Ref<Color>) : boolean
        /**
        * Returns the color as a hexadecimal string in the format "RRGGBB".
        * @param color The color to be converted.
        * @returns Hexadecimal string representing the color.
        */
        public static ToHtmlStringRGB ($color: Color) : string
        /**
        * Returns the color as a hexadecimal string in the format "RRGGBBAA".
        * @param color The color to be converted.
        * @returns Hexadecimal string representing the color.
        */
        public static ToHtmlStringRGBA ($color: Color) : string
    }

    /**
    * A collection of common math functions.
    */
    class Mathf extends System.ValueType {

        /**
        * The well-known 3.14159265358979... value (Read Only).
        */
        public static PI : float
        /**
        * A representation of positive infinity (Read Only).
        */
        public static Infinity : float
        /**
        * A representation of negative infinity (Read Only).
        */
        public static NegativeInfinity : float
        /**
        * Degrees-to-radians conversion constant (Read Only).
        */
        public static Deg2Rad : float
        /**
        * Radians-to-degrees conversion constant (Read Only).
        */
        public static Rad2Deg : float
        /**
        * A tiny floating point value (Read Only).
        */
        public static Epsilon : float

        /**
        * Returns the closest power of two value.
        */
        public static ClosestPowerOfTwo ($value: int) : int
        /**
        * Returns true if the value is power of two.
        */
        public static IsPowerOfTwo ($value: int) : boolean
        /**
        * Returns the next power of two that is equal to, or greater than, the argument.
        */
        public static NextPowerOfTwo ($value: int) : int
        /**
        * Converts the given value from gamma (sRGB) to linear color space.
        */
        public static GammaToLinearSpace ($value: float) : float
        /**
        * Converts the given value from linear to gamma (sRGB) color space.
        */
        public static LinearToGammaSpace ($value: float) : float
        /**
        * Convert a color temperature in Kelvin to RGB color.
        * @param kelvin Temperature in Kelvin. Range 1000 to 40000 Kelvin.
        * @returns Correlated Color Temperature as floating point RGB color.
        */
        public static CorrelatedColorTemperatureToRGB ($kelvin: float) : Color
        /**
        * Encode a floating point value into a 16-bit representation.
        * @param val The floating point value to convert.
        * @returns The converted half-precision float, stored in a 16-bit unsigned integer.
        */
        public static FloatToHalf ($val: float) : ushort
        /**
        * Convert a half precision float to a 32-bit floating point value.
        * @param val The half precision value to convert.
        * @returns The decoded 32-bit float.
        */
        public static HalfToFloat ($val: ushort) : float
        /**
        * Generate 2D Perlin noise.
        * @param x X-coordinate of sample point.
        * @param y Y-coordinate of sample point.
        * @returns Value between 0.0 and 1.0. (Return value might be slightly below 0.0 or beyond 1.0.)
        */
        public static PerlinNoise ($x: float, $y: float) : float
        /**
        * Generates a 1D pseudo-random pattern of float values across a 2D plane.
        * @param x The X-coordinate of the given sample point.
        * @returns A value in the range of 0.0 and 1.0. The value might be slightly higher or lower than this range.
        */
        public static PerlinNoise1D ($x: float) : float
        /**
        * Returns the sine of angle f.
        * @param f The input angle, in radians.
        * @returns The return value between -1 and +1.
        */
        public static Sin ($f: float) : float
        /**
        * Returns the cosine of angle f.
        * @param f The input angle, in radians.
        * @returns The return value between -1 and 1.
        */
        public static Cos ($f: float) : float
        /**
        * Returns the tangent of angle f in radians.
        */
        public static Tan ($f: float) : float
        /**
        * Returns the arc-sine of f - the angle in radians whose sine is f.
        */
        public static Asin ($f: float) : float
        /**
        * Returns the arc-cosine of f - the angle in radians whose cosine is f.
        */
        public static Acos ($f: float) : float
        /**
        * Returns the arc-tangent of f - the angle in radians whose tangent is f.
        */
        public static Atan ($f: float) : float
        /**
        * Returns the angle in radians whose Tan is y/x.
        */
        public static Atan2 ($y: float, $x: float) : float
        /**
        * Returns square root of f.
        */
        public static Sqrt ($f: float) : float
        /**
        * Returns the absolute value of f.
        * @methodSwap Abs_EBB7509C_H82424F3E
        */
        public static Abs ($f: float) : float
        /**
        * Returns the absolute value of value.
        * @methodSwap Abs_EBB7509C_F92D023A
        */
        public static Abs ($value: int) : int
        /**
        * Returns the smallest of two or more values.
        * @methodSwap Min_EBB7509C_H1075CF37
        */
        public static Min ($a: float, $b: float) : float
        /**
        * Returns the smallest of two or more values.
        */
        public static Min (...values: float[]) : float
        /**
        * Returns the smallest of two or more values.
        * @methodSwap Min_EBB7509C_H2CFB2EE5
        */
        public static Min ($a: int, $b: int) : int
        /**
        * Returns the smallest of two or more values.
        */
        public static Min (...values: int[]) : int
        /**
        * Returns the largest of two or more values. When comparing negative values, values closer to zero are considered larger.
        * @methodSwap Max_EBB7509C_H1075CF37
        */
        public static Max ($a: float, $b: float) : float
        /**
        * Returns the largest of two or more values. When comparing negative values, values closer to zero are considered larger.
        */
        public static Max (...values: float[]) : float
        /**
        * Returns the largest value. When comparing negative values, values closer to zero are considered larger.
        * @methodSwap Max_EBB7509C_H2CFB2EE5
        */
        public static Max ($a: int, $b: int) : int
        /**
        * Returns the largest value. When comparing negative values, values closer to zero are considered larger.
        */
        public static Max (...values: int[]) : int
        /**
        * Returns f raised to power p.
        */
        public static Pow ($f: float, $p: float) : float
        /**
        * Returns e raised to the specified power.
        */
        public static Exp ($power: float) : float
        /**
        * Returns the logarithm of a specified number in a specified base.
        * @methodSwap Log_EBB7509C_H1075CF37
        */
        public static Log ($f: float, $p: float) : float
        /**
        * Returns the natural (base e) logarithm of a specified number.
        * @methodSwap Log_EBB7509C_H82424F3E
        */
        public static Log ($f: float) : float
        /**
        * Returns the base 10 logarithm of a specified number.
        */
        public static Log10 ($f: float) : float
        /**
        * Returns the smallest integer greater than or equal to f.
        */
        public static Ceil ($f: float) : float
        /**
        * Returns the largest integer smaller than or equal to f.
        */
        public static Floor ($f: float) : float
        /**
        * Returns f rounded to the nearest integer.
        */
        public static Round ($f: float) : float
        /**
        * Returns the smallest integer greater to or equal to f.
        */
        public static CeilToInt ($f: float) : int
        /**
        * Returns the largest integer smaller to or equal to f.
        */
        public static FloorToInt ($f: float) : int
        /**
        * Returns f rounded to the nearest integer.
        */
        public static RoundToInt ($f: float) : int
        /**
        * Returns the sign of f.
        */
        public static Sign ($f: float) : float
        /**
        * Clamps the given value between the given minimum float and maximum float values.  Returns the given value if it is within the minimum and maximum range.
        * @param value The floating point value to restrict inside the range defined by the minimum and maximum values.
        * @param min The minimum floating point value to compare against.
        * @param max The maximum floating point value to compare against.
        * @returns The float result between the minimum and maximum values.
        * @methodSwap Clamp_EBB7509C_E4172388
        */
        public static Clamp ($value: float, $min: float, $max: float) : float
        /**
        * Clamps the given value between a range defined by the given minimum integer and maximum integer values. Returns the given value if it is within min and max.
        * @param value The integer point value to restrict inside the min-to-max range.
        * @param min The minimum integer point value to compare against.
        * @param max The maximum  integer point value to compare against.
        * @returns The int result between min and max values.
        * @methodSwap Clamp_EBB7509C_H71E348A6
        */
        public static Clamp ($value: int, $min: int, $max: int) : int
        /**
        * Clamps value between 0 and 1 and returns value.
        */
        public static Clamp01 ($value: float) : float
        /**
        * Linearly interpolates between a and b by t.
        * @param a The start value.
        * @param b The end value.
        * @param t The interpolation value between the two floats.
        * @returns The interpolated float result between the two float values.
        */
        public static Lerp ($a: float, $b: float, $t: float) : float
        /**
        * Linearly interpolates between a and b by t with no limit to t.
        * @param a The start value.
        * @param b The end value.
        * @param t The interpolation between the two floats.
        * @returns The float value as a result from the linear interpolation.
        */
        public static LerpUnclamped ($a: float, $b: float, $t: float) : float
        /**
        * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
        * @param a The start angle. A float expressed in degrees.
        * @param b The end angle. A float expressed in degrees.
        * @param t The interpolation value between the start and end angles. This value is clamped to the range [0, 1].
        * @returns Returns the interpolated float result between angle a and angle b, based on the interpolation value t.
        */
        public static LerpAngle ($a: float, $b: float, $t: float) : float
        /**
        * Moves a value current towards target.
        * @param current The current value.
        * @param target The value to move towards.
        * @param maxDelta The maximum change applied to the current value.
        */
        public static MoveTowards ($current: float, $target: float, $maxDelta: float) : float
        /**
        * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
        */
        public static MoveTowardsAngle ($current: float, $target: float, $maxDelta: float) : float
        /**
        * Interpolates between min and max with smoothing at the limits.
        */
        public static SmoothStep ($from: float, $to: float, $t: float) : float
        public static Gamma ($value: float, $absmax: float, $gamma: float) : float
        /**
        * Compares two floating point values and returns true if they are similar.
        */
        public static Approximately ($a: float, $b: float) : boolean
        /**
        * Gradually moves the current value towards a target value, over a specified time and at a specified velocity.
        * @param current The current value.
        * @param target The target value.
        * @param currentVelocity Use this parameter to specify the initial velocity to move the current value towards the target value. This method updates the currentVelocity based on this movement and smooth-damping.
        * @param smoothTime The approximate time it takes for the current value to reach the target value. The lower the smoothTime, the faster the current value reaches the target value. The minimum smoothTime is 0.0001. If a lower value is specified, it is clamped to the minimum value.
        * @param maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
        * @param deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
        * @returns The current value after moving one step towards the target value.
        * @methodSwap SmoothDamp_EBB7509C_H48D33973
        */
        public static SmoothDamp ($current: float, $target: float, $currentVelocity: $Ref<float>, $smoothTime: float, $maxSpeed: float) : float
        /**
        * Gradually moves the current value towards a target value, over a specified time and at a specified velocity.
        * @param current The current value.
        * @param target The target value.
        * @param currentVelocity Use this parameter to specify the initial velocity to move the current value towards the target value. This method updates the currentVelocity based on this movement and smooth-damping.
        * @param smoothTime The approximate time it takes for the current value to reach the target value. The lower the smoothTime, the faster the current value reaches the target value. The minimum smoothTime is 0.0001. If a lower value is specified, it is clamped to the minimum value.
        * @param maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
        * @param deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
        * @returns The current value after moving one step towards the target value.
        * @methodSwap SmoothDamp_EBB7509C_AC05E17A
        */
        public static SmoothDamp ($current: float, $target: float, $currentVelocity: $Ref<float>, $smoothTime: float) : float
        /**
        * Gradually moves the current value towards a target value, over a specified time and at a specified velocity.
        * @param current The current value.
        * @param target The target value.
        * @param currentVelocity Use this parameter to specify the initial velocity to move the current value towards the target value. This method updates the currentVelocity based on this movement and smooth-damping.
        * @param smoothTime The approximate time it takes for the current value to reach the target value. The lower the smoothTime, the faster the current value reaches the target value. The minimum smoothTime is 0.0001. If a lower value is specified, it is clamped to the minimum value.
        * @param maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
        * @param deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
        * @returns The current value after moving one step towards the target value.
        * @methodSwap SmoothDamp_EBB7509C_H6D3F484
        */
        public static SmoothDamp ($current: float, $target: float, $currentVelocity: $Ref<float>, $smoothTime: float, $maxSpeed: float, $deltaTime: float) : float
        /**
        * Gradually changes an angle given in degrees towards a desired goal angle over time.
        * @param current The current position.
        * @param target The target position.
        * @param currentVelocity The current velocity. This method modifies the currentVelocity every time the method is called.
        * @param smoothTime The approximate time it takes to reach the target position. The lower the value the faster this method reaches the target. The minimum value is 0.0001. If a lower value is specified, it is automatically clamped to this minimum value.
        * @param maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
        * @param deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
        * @methodSwap SmoothDampAngle_EBB7509C_H48D33973
        */
        public static SmoothDampAngle ($current: float, $target: float, $currentVelocity: $Ref<float>, $smoothTime: float, $maxSpeed: float) : float
        /**
        * Gradually changes an angle given in degrees towards a desired goal angle over time.
        * @param current The current position.
        * @param target The target position.
        * @param currentVelocity The current velocity. This method modifies the currentVelocity every time the method is called.
        * @param smoothTime The approximate time it takes to reach the target position. The lower the value the faster this method reaches the target. The minimum value is 0.0001. If a lower value is specified, it is automatically clamped to this minimum value.
        * @param maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
        * @param deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
        * @methodSwap SmoothDampAngle_EBB7509C_AC05E17A
        */
        public static SmoothDampAngle ($current: float, $target: float, $currentVelocity: $Ref<float>, $smoothTime: float) : float
        /**
        * Gradually changes an angle given in degrees towards a desired goal angle over time.
        * @param current The current position.
        * @param target The target position.
        * @param currentVelocity The current velocity. This method modifies the currentVelocity every time the method is called.
        * @param smoothTime The approximate time it takes to reach the target position. The lower the value the faster this method reaches the target. The minimum value is 0.0001. If a lower value is specified, it is automatically clamped to this minimum value.
        * @param maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
        * @param deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
        * @methodSwap SmoothDampAngle_EBB7509C_H6D3F484
        */
        public static SmoothDampAngle ($current: float, $target: float, $currentVelocity: $Ref<float>, $smoothTime: float, $maxSpeed: float, $deltaTime: float) : float
        /**
        * Loops the value t, so that it is never larger than length and never smaller than 0.
        */
        public static Repeat ($t: float, $length: float) : float
        /**
        * PingPong returns a value that increments and decrements between zero and the length. It follows the triangle wave formula where the bottom is set to zero and the peak is set to length.
        */
        public static PingPong ($t: float, $length: float) : float
        /**
        * Determines where a value lies between two points.
        * @param a The start of the range.
        * @param b The end of the range.
        * @param value The point within the range you want to calculate.
        * @returns A value between zero and one, representing where the "value" parameter falls within the range defined by a and b.
        */
        public static InverseLerp ($a: float, $b: float, $value: float) : float
        /**
        * Calculates the shortest difference between two angles.
        * @param current The current angle in degrees.
        * @param target The target angle in degrees.
        * @returns A value between -179 and 180, in degrees.
        */
        public static DeltaAngle ($current: float, $target: float) : float
    }

    /**
    * Ping any given IP address (given in dot notation).
    */
    class Ping extends System.Object {

        /**
        * Has the ping function completed?
        */
        public get isDone(): boolean;
        /**
        * This property contains the ping time result in milliseconds after isDone returns true.
        */
        public get time(): int;
        /**
        * The IP target of the ping.
        */
        public get ip(): string;

        /**
        * Perform a ping to the supplied target IP address.
        */
        public constructor ($address: string)
        public DestroyPing () : void
    }

    /**
    * An exception thrown by the PlayerPrefs class in a  web player build.
    */
    class PlayerPrefsException extends System.Exception {

        public constructor ($error: string)
    }

    /**
    * PlayerPrefs is a class that stores Player preferences between game sessions. It can store string, float and integer values into the user’s platform registry.
    */
    class PlayerPrefs extends System.Object {

        public constructor ()
        /**
        * Sets a single integer value for the preference identified by the given key. You can use PlayerPrefs.GetInt to retrieve this value.
        */
        public static SetInt ($key: string, $value: int) : void
        /**
        * Returns the value corresponding to key in the preference file if it exists.
        * @methodSwap GetInt_EBB7509C_H72D17FE0
        */
        public static GetInt ($key: string, $defaultValue: int) : int
        /**
        * Returns the value corresponding to key in the preference file if it exists.
        */
        public static GetInt ($key: string) : int
        /**
        * Sets the float value of the preference identified by the given key. You can use PlayerPrefs.GetFloat to retrieve this value.
        */
        public static SetFloat ($key: string, $value: float) : void
        /**
        * Returns the value corresponding to key in the preference file if it exists.
        * @methodSwap GetFloat_EBB7509C_H45FF9778
        */
        public static GetFloat ($key: string, $defaultValue: float) : float
        /**
        * Returns the value corresponding to key in the preference file if it exists.
        */
        public static GetFloat ($key: string) : float
        /**
        * Sets a single string value for the preference identified by the given key. You can use PlayerPrefs.GetString to retrieve this value.
        */
        public static SetString ($key: string, $value: string) : void
        /**
        * Returns the value corresponding to key in the preference file if it exists.
        */
        public static GetString ($key: string, $defaultValue: string) : string
        /**
        * Returns the value corresponding to key in the preference file if it exists.
        */
        public static GetString ($key: string) : string
        /**
        * Returns true if the given key exists in PlayerPrefs, otherwise returns false.
        */
        public static HasKey ($key: string) : boolean
        /**
        * Removes the given key from the PlayerPrefs. If the key does not exist, DeleteKey has no impact.
        */
        public static DeleteKey ($key: string) : void
        /**
        * Removes all keys and values from the preferences. Use with caution.
        */
        public static DeleteAll () : void
        /**
        * Saves all modified preferences.
        */
        public static Save () : void
    }

    /**
    * Easily generate random data for games.
    */
    class Random {

        /**
        * Gets or sets the full internal state of the random number generator.
        */
        public static get state(): UnityEngine_Random.State;
        public static set state(value: UnityEngine_Random.State);
        /**
        * Returns a random float within [0.0..1.0] (range is inclusive) (Read Only).
        */
        public static get value(): float;
        /**
        * Returns a random point inside or on a sphere with radius 1.0 (Read Only).
        */
        public static get insideUnitSphere(): Vector3;
        /**
        * Returns a random point inside or on a circle with radius 1.0 (Read Only).
        */
        public static get insideUnitCircle(): Vector2;
        /**
        * Returns a random point on the surface of a sphere with radius 1.0 (Read Only).
        */
        public static get onUnitSphere(): Vector3;
        /**
        * Returns a random rotation (Read Only).
        */
        public static get rotation(): Quaternion;
        /**
        * Returns a random rotation with uniform distribution (Read Only).
        */
        public static get rotationUniform(): Quaternion;

        /**
        * Initializes the random number generator state with a seed.
        * @param seed Seed used to initialize the random number generator.
        */
        public static InitState ($seed: int) : void
        /**
        * Returns a random float within [minInclusive..maxInclusive] (range is inclusive).
        * @methodSwap Range_EBB7509C_H1075CF37
        */
        public static Range ($minInclusive: float, $maxInclusive: float) : float
        /**
        * Return a random int within [minInclusive..maxExclusive) (Read Only).
        * @methodSwap Range_EBB7509C_H2CFB2EE5
        */
        public static Range ($minInclusive: int, $maxExclusive: int) : int
        /**
        * Generates a random color from HSV and alpha ranges.
        * @param hueMin Minimum hue [0..1].
        * @param hueMax Maximum hue [0..1].
        * @param saturationMin Minimum saturation [0..1].
        * @param saturationMax Maximum saturation [0..1].
        * @param valueMin Minimum value [0..1].
        * @param valueMax Maximum value [0..1].
        * @param alphaMin Minimum alpha [0..1].
        * @param alphaMax Maximum alpha [0..1].
        * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value.
        */
        public static ColorHSV () : Color
        /**
        * Generates a random color from HSV and alpha ranges.
        * @param hueMin Minimum hue [0..1].
        * @param hueMax Maximum hue [0..1].
        * @param saturationMin Minimum saturation [0..1].
        * @param saturationMax Maximum saturation [0..1].
        * @param valueMin Minimum value [0..1].
        * @param valueMax Maximum value [0..1].
        * @param alphaMin Minimum alpha [0..1].
        * @param alphaMax Maximum alpha [0..1].
        * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value.
        * @methodSwap ColorHSV_EBB7509C_H1075CF37
        */
        public static ColorHSV ($hueMin: float, $hueMax: float) : Color
        /**
        * Generates a random color from HSV and alpha ranges.
        * @param hueMin Minimum hue [0..1].
        * @param hueMax Maximum hue [0..1].
        * @param saturationMin Minimum saturation [0..1].
        * @param saturationMax Maximum saturation [0..1].
        * @param valueMin Minimum value [0..1].
        * @param valueMax Maximum value [0..1].
        * @param alphaMin Minimum alpha [0..1].
        * @param alphaMax Maximum alpha [0..1].
        * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value.
        * @methodSwap ColorHSV_EBB7509C_H3F97763D
        */
        public static ColorHSV ($hueMin: float, $hueMax: float, $saturationMin: float, $saturationMax: float) : Color
        /**
        * Generates a random color from HSV and alpha ranges.
        * @param hueMin Minimum hue [0..1].
        * @param hueMax Maximum hue [0..1].
        * @param saturationMin Minimum saturation [0..1].
        * @param saturationMax Maximum saturation [0..1].
        * @param valueMin Minimum value [0..1].
        * @param valueMax Maximum value [0..1].
        * @param alphaMin Minimum alpha [0..1].
        * @param alphaMax Maximum alpha [0..1].
        * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value.
        * @methodSwap ColorHSV_EBB7509C_E1201BF3
        */
        public static ColorHSV ($hueMin: float, $hueMax: float, $saturationMin: float, $saturationMax: float, $valueMin: float, $valueMax: float) : Color
        /**
        * Generates a random color from HSV and alpha ranges.
        * @param hueMin Minimum hue [0..1].
        * @param hueMax Maximum hue [0..1].
        * @param saturationMin Minimum saturation [0..1].
        * @param saturationMax Maximum saturation [0..1].
        * @param valueMin Minimum value [0..1].
        * @param valueMax Maximum value [0..1].
        * @param alphaMin Minimum alpha [0..1].
        * @param alphaMax Maximum alpha [0..1].
        * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value.
        * @methodSwap ColorHSV_EBB7509C_H46D83E49
        */
        public static ColorHSV ($hueMin: float, $hueMax: float, $saturationMin: float, $saturationMax: float, $valueMin: float, $valueMax: float, $alphaMin: float, $alphaMax: float) : Color
    }

    /**
    * MonoBehaviour.StartCoroutine returns a Coroutine. Instances of this class are only used to reference these coroutines, and do not hold any exposed properties or functions.
    */
    class Coroutine extends YieldInstruction {

    }

    /**
    * Defines if enum should be shown sorted by name or by value.
    */
    enum InspectorSort {
        ByName = 0,
        ByValue = 1 
    }

    /**
    * Defines if enum should be shown in ascending or descending order.
    */
    enum InspectorSortDirection {
        Ascending = 0,
        Descending = 1 
    }

    /**
    * Specifies Layers to use in a Physics.Raycast.
    */
    class LayerMask extends System.ValueType {

        /**
        * Converts a layer mask value to an integer value.
        */
        public get value(): int;
        public set value(value: int);

        /**
        * Given a layer number, returns the name of the layer as defined in either a Builtin or a User Layer in the.
        */
        public static LayerToName ($layer: int) : string
        /**
        * Given a layer name, returns the layer index as defined by either a Builtin or a User Layer in the.
        */
        public static NameToLayer ($layerName: string) : int
        /**
        * Given a set of layer names as defined by either a Builtin or a User Layer in the, returns the equivalent layer mask for all of them.
        * @param layerNames List of layer names to convert to a layer mask.
        * @returns The layer mask created from the layerNames.
        */
        public static GetMask (...layerNames: string[]) : int
        public static op_Implicit ($mask: LayerMask) : int
        public static op_Implicit ($intVal: int) : LayerMask
    }

    /**
    * Serializable lazy reference to a UnityEngine.Object contained in an asset file.
    */
    class LazyLoadReference$1<T> extends System.ValueType {

        public get isSet(): boolean;
        public get isBroken(): boolean;
        public get asset(): T;
        public set asset(value: T);
        public get instanceID(): int;
        public set instanceID(value: int);

        public constructor ($asset: T)
        public constructor ($instanceID: int)
    }

    /**
    * MonoBehaviour is a base class that many Unity scripts derive from.
    */
    class MonoBehaviour extends Behaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;
        /**
        * Cancellation token raised when the MonoBehaviour is destroyed (Read Only).
        */
        public get destroyCancellationToken(): System_Threading.CancellationToken;
        /**
        * Disabling this lets you skip the GUI layout phase.
        */
        public get useGUILayout(): boolean;
        public set useGUILayout(value: boolean);

        protected constructor ()
        /**
        * Starts a coroutine named methodName.
        */
        public StartCoroutine ($methodName: string) : Coroutine
        /**
        * Starts a coroutine named methodName.
        */
        public StartCoroutine ($methodName: string, $value: any) : Coroutine
        /**
        * Starts a Coroutine.
        */
        public StartCoroutine ($routine: System_Collections.IEnumerator) : Coroutine
        /**
        * Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
        * @param methodName Name of coroutine.
        * @param routine Name of the function in code, including coroutines.
        */
        public StopCoroutine ($routine: System_Collections.IEnumerator) : void
        /**
        * Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
        * @param methodName Name of coroutine.
        * @param routine Name of the function in code, including coroutines.
        */
        public StopCoroutine ($routine: Coroutine) : void
        /**
        * Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
        * @param methodName Name of coroutine.
        * @param routine Name of the function in code, including coroutines.
        */
        public StopCoroutine ($methodName: string) : void
        /**
        * Stops all coroutines running on this behaviour.
        */
        public StopAllCoroutines () : void
        /**
        * Logs message to the Unity Console (identical to Debug.Log).
        */
        public static print ($message: any) : void
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * Describes an integer range.
    */
    class RangeInt extends System.ValueType {

        /**
        * The starting index of the range, where 0 is the first position, 1 is the second, 2 is the third, and so on.
        */
        public start : int
        /**
        * The length of the range.
        */
        public length : int
        /**
        * The end index of the range (not inclusive).
        */
        public get end(): int;

        /**
        * Constructs a new RangeInt with given start, length values.
        * @param start The starting index of the range.
        * @param length The length of the range.
        */
        public constructor ($start: int, $length: int)
    }

    /**
    * Specifies when to get a callback during the startup of the runtime or when entering play mode in the Editor. Used with RuntimeInitializeOnLoadMethodAttribute.
    */
    enum RuntimeInitializeLoadType {
        AfterSceneLoad = 0,
        BeforeSceneLoad = 1,
        AfterAssembliesLoaded = 2,
        BeforeSplashScreen = 3,
        SubsystemRegistration = 4 
    }

    /**
    * A class you can derive from if you want to create objects that live independently of GameObjects.
    */
    class ScriptableObject extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);

        protected constructor ()
        /**
        * Creates an instance of a scriptable object.
        * @param className The type of the ScriptableObject to create, as the name of the type.
        * @param type The type of the ScriptableObject to create, as a System.Type instance.
        * @returns The created ScriptableObject.
        */
        public static CreateInstance ($className: string) : ScriptableObject
        /**
        * Creates an instance of a scriptable object.
        * @param className The type of the ScriptableObject to create, as the name of the type.
        * @param type The type of the ScriptableObject to create, as a System.Type instance.
        * @returns The created ScriptableObject.
        */
        public static CreateInstance ($type: System.Type) : ScriptableObject
        /**
        * Creates an instance of a scriptable object.
        * @returns The created ScriptableObject.
        */
        public static CreateInstance<T extends ScriptableObject> () : T
    }

    class StackTraceUtility {

        public static ExtractStackTrace () : string
        public static ExtractStringFromException ($exception: any) : string
    }

    class UnityException extends System.SystemException {

        public constructor ()
        public constructor ($message: string)
        public constructor ($message: string, $innerException: System.Exception)
    }

    class MissingComponentException extends System.SystemException {

        public constructor ()
        public constructor ($message: string)
        public constructor ($message: string, $innerException: System.Exception)
    }

    class UnassignedReferenceException extends System.SystemException {

        public constructor ()
        public constructor ($message: string)
        public constructor ($message: string, $innerException: System.Exception)
    }

    class MissingReferenceException extends System.SystemException {

        public constructor ()
        public constructor ($message: string)
        public constructor ($message: string, $innerException: System.Exception)
    }

    /**
    * Represents a raw text or binary file asset.
    */
    class TextAsset extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The raw bytes of the text asset. (Read Only)
        */
        public get bytes(): byte[];
        /**
        * The text contents of the file as a string. (Read Only)
        */
        public get text(): string;
        /**
        * The size of the text asset data in bytes. (Read Only)
        */
        public get dataSize(): bigint;

        public constructor ()
        /**
        * Create a new TextAsset with the specified text contents.
        * This constructor creates a TextAsset, which is not the same as a plain text file. When saved to disk using the AssetDatabase class, the TextAsset should be saved with the .asset extension.
        * @param text The text contents for the TextAsset.
        */
        public constructor ($text: string)
        /**
        * Returns the contents of the TextAsset.
        */
        public ToString () : string
        /**
        * Gets raw text asset data.
        * @returns A reference to an array in native code that provides access to the raw asset data.
        */
        public GetData<T> () : Unity_Collections.NativeArray$1<T>
    }

    class TrackedReference extends System.Object {

        public Equals ($o: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($x: TrackedReference, $y: TrackedReference) : boolean
        public static op_Inequality ($x: TrackedReference, $y: TrackedReference) : boolean
        public static op_Implicit ($exists: TrackedReference) : boolean
    }

    /**
    * Waits until the end of the frame after Unity has rendered every Camera and GUI, just before displaying the frame on screen.
    */
    class WaitForEndOfFrame extends YieldInstruction {

        public constructor ()
    }

    /**
    * Waits until next fixed frame rate update function. Additional resources: MonoBehaviour.FixedUpdate.
    */
    class WaitForFixedUpdate extends YieldInstruction {

        public constructor ()
    }

    /**
    * Suspends the coroutine execution for the given amount of seconds using scaled time.
    */
    class WaitForSeconds extends YieldInstruction {

        /**
        * Suspends the coroutine execution for the given amount of seconds using scaled time.
        * @param seconds Delay execution by the amount of time in seconds.
        */
        public constructor ($seconds: float)
        public constructor ()
    }

    /**
    * Suspends the coroutine execution for the given amount of seconds using unscaled time.
    */
    class WaitForSecondsRealtime extends CustomYieldInstruction {

        /**
        * Indicates if coroutine should be kept suspended.
        */
        public get keepWaiting(): boolean;
        public get Current(): any;
        /**
        * The given amount of seconds that the yield instruction will wait for.
        */
        public get waitTime(): float;
        public set waitTime(value: float);

        /**
        * Creates a yield instruction to wait for a given number of seconds using unscaled time.
        */
        public constructor ($time: float)
        public Reset () : void
    }

    /**
    * Suspends the coroutine execution until the supplied delegate evaluates to true.
    */
    class WaitUntil extends CustomYieldInstruction {

        /**
        * Indicates if coroutine should be kept suspended.
        */
        public get keepWaiting(): boolean;
        public get Current(): any;

        public constructor ($predicate: System.Func$1<boolean>)
    }

    /**
    * Suspends the coroutine execution until the supplied delegate evaluates to false.
    */
    class WaitWhile extends CustomYieldInstruction {

        /**
        * Indicates if coroutine should be kept suspended.
        */
        public get keepWaiting(): boolean;
        public get Current(): any;

        public constructor ($predicate: System.Func$1<boolean>)
    }

    /**
    * Webplayer security related class. Not supported from 5.4.0 onwards.
    */
    class Security extends System.Object {

        public constructor ()
    }

    class Types {

    }

    /**
    * Interface to receive callbacks upon serialization and deserialization.
    */
    interface ISerializationCallbackReceiver {

        /**
        * Implement this method to receive a callback before Unity serializes your object.
        */
        OnBeforeSerialize? () : void
        /**
        * Implement this method to receive a callback after Unity deserializes your object.
        */
        OnAfterDeserialize? () : void
    }

    /**
    * ShaderVariantCollection records which shader variants are actually used in each shader.
    */
    class ShaderVariantCollection extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Number of shaders in this collection (Read Only).
        */
        public get shaderCount(): int;
        /**
        * Number of total variants in this collection (Read Only).
        */
        public get variantCount(): int;
        /**
        * Number of total variants in this collection that are already warmed up (Read Only).
        */
        public get warmedUpVariantCount(): int;
        /**
        * Is this ShaderVariantCollection already warmed up? (Read Only)
        */
        public get isWarmedUp(): boolean;

        /**
        * Create a new empty shader variant collection.
        */
        public constructor ()
        /**
        * Remove all shader variants from the collection.
        */
        public Clear () : void
        /**
        * Prewarms all shader variants in this shader variant collection.
        */
        public WarmUp () : void
        /**
        * Prewarms the given number of shader variants in this shader variant collection.
        * @param variantCount The maximum number of variants to warm up.
        * @returns True if all variants in this shader variant collection have been warmed up, false otherwise.
        */
        public WarmUpProgressively ($variantCount: int) : boolean
        /**
        * Adds a new shader variant to the collection.
        * @param variant Shader variant to add.
        * @returns False if already in the collection.
        */
        public Add ($variant: UnityEngine_ShaderVariantCollection.ShaderVariant) : boolean
        /**
        * Removes shader variant from the collection.
        * @param variant Shader variant to add.
        * @returns False if was not in the collection.
        */
        public Remove ($variant: UnityEngine_ShaderVariantCollection.ShaderVariant) : boolean
        /**
        * Checks if a shader variant is in the collection.
        * @param variant Shader variant to check.
        * @returns True if the variant is in the collection.
        */
        public Contains ($variant: UnityEngine_ShaderVariantCollection.ShaderVariant) : boolean
    }

    /**
    * Defines the axes that can be snapped.
    */
    enum SnapAxis {
        None = 0,
        X = 1,
        Y = 2,
        Z = 4,
        All = 7 
    }

    /**
    * Snap values to rounded increments.
    */
    class Snapping {

        /**
        * Rounds value to the closest multiple of snap.
        * @param val The value to round.
        * @param snap The increment to round to.
        * @returns The rounded value.
        * @methodSwap Snap_EBB7509C_H1075CF37
        */
        public static Snap ($val: float, $snap: float) : float
        /**
        * Rounds value to the closest multiple of snap.
        * @param val The value to round.
        * @param snap The increment to round to.
        * @returns The rounded value.
        */
        public static Snap ($val: Vector2, $snap: Vector2) : Vector2
        /**
        * Rounds value to the closest multiple of snap.
        * @param val The value to round.
        * @param snap The increment to round to.
        * @param axis Restrict snapping to the components on these axes.
        * @returns The rounded value.
        */
        public static Snap ($val: Vector3, $snap: Vector3, $axis?: SnapAxis) : Vector3
    }

    /**
    * StaticBatchingUtility can prepare your objects to take advantage of Unity's static batching.
    */
    class StaticBatchingUtility extends System.Object {

        public constructor ()
        /**
        * Combines all children GameObjects of the staticBatchRoot for static batching.
        * @param staticBatchRoot The GameObject that should become the root of the combined batch.
        */
        public static Combine ($staticBatchRoot: GameObject) : void
        /**
        * Combines all GameObjects in gos for static batching and treats staticBatchRoot as the root.
        * @param gos The GameObjects to prepare for static batching.
        * @param staticBatchRoot The GameObject that should become the root of the combined batch.
        */
        public static Combine ($gos: GameObject[], $staticBatchRoot: GameObject) : void
    }

    /**
    * Enumeration for SystemInfo.batteryStatus which represents the current status of the device's battery.
    */
    enum BatteryStatus {
        Unknown = 0,
        Charging = 1,
        Discharging = 2,
        NotCharging = 3,
        Full = 4 
    }

    /**
    * Enumeration for SystemInfo.operatingSystemFamily.
    */
    enum OperatingSystemFamily {
        Other = 0,
        MacOSX = 1,
        Windows = 2,
        Linux = 3 
    }

    /**
    * Enumeration for SystemInfo.deviceType, denotes a coarse grouping of kinds of devices.
    */
    enum DeviceType {
        Unknown = 0,
        Handheld = 1,
        Console = 2,
        Desktop = 3 
    }

    /**
    * Access system and hardware information.
    */
    class SystemInfo extends System.Object {

        /**
        * Value returned by SystemInfo string properties which are not supported on the current platform.
        */
        public static unsupportedIdentifier : string
        /**
        * The current battery level (Read Only).
        */
        public static get batteryLevel(): float;
        /**
        * Returns the current status of the device's battery (Read Only).
        */
        public static get batteryStatus(): BatteryStatus;
        /**
        * Operating system name with version (Read Only).
        */
        public static get operatingSystem(): string;
        /**
        * Returns the operating system family the game is running on (Read Only).
        */
        public static get operatingSystemFamily(): OperatingSystemFamily;
        /**
        * Processor name (Read Only).
        */
        public static get processorType(): string;
        /**
        * Processor frequency in MHz (Read Only).
        */
        public static get processorFrequency(): int;
        /**
        * Number of processors present (Read Only).
        */
        public static get processorCount(): int;
        /**
        * Amount of system memory present (Read Only).
        */
        public static get systemMemorySize(): int;
        /**
        * A unique device identifier. It's guaranteed to be unique for every device (Read Only).
        */
        public static get deviceUniqueIdentifier(): string;
        /**
        * The user defined name of the device (Read Only).
        */
        public static get deviceName(): string;
        /**
        * The model of the device (Read Only).
        */
        public static get deviceModel(): string;
        /**
        * Is an accelerometer available on the device?
        */
        public static get supportsAccelerometer(): boolean;
        /**
        * Is a gyroscope available on the device?
        */
        public static get supportsGyroscope(): boolean;
        /**
        * Is the device capable of reporting its location?
        */
        public static get supportsLocationService(): boolean;
        /**
        * Is the device capable of providing the user haptic feedback by vibration?
        */
        public static get supportsVibration(): boolean;
        /**
        * Is there an Audio device available for playback? (Read Only)
        */
        public static get supportsAudio(): boolean;
        /**
        * Returns the kind of device the application is running on (Read Only).
        */
        public static get deviceType(): DeviceType;
        /**
        * Amount of video memory present (Read Only).
        */
        public static get graphicsMemorySize(): int;
        /**
        * The name of the graphics device (Read Only).
        */
        public static get graphicsDeviceName(): string;
        /**
        * The vendor of the graphics device (Read Only).
        */
        public static get graphicsDeviceVendor(): string;
        /**
        * The identifier code of the graphics device (Read Only).
        */
        public static get graphicsDeviceID(): int;
        /**
        * The identifier code of the graphics device vendor (Read Only).
        */
        public static get graphicsDeviceVendorID(): int;
        /**
        * The graphics API type used by the graphics device (Read Only).
        */
        public static get graphicsDeviceType(): UnityEngine_Rendering.GraphicsDeviceType;
        /**
        * Returns true if the texture UV coordinate convention for this platform has Y starting at the top of the image.
        */
        public static get graphicsUVStartsAtTop(): boolean;
        /**
        * The graphics API type and driver version used by the graphics device (Read Only).
        */
        public static get graphicsDeviceVersion(): string;
        /**
        * Graphics device shader capability level (Read Only).
        */
        public static get graphicsShaderLevel(): int;
        /**
        * Is graphics device using multi-threaded rendering (Read Only)?
        */
        public static get graphicsMultiThreaded(): boolean;
        /**
        * Application's actual rendering threading mode (Read Only).
        */
        public static get renderingThreadingMode(): UnityEngine_Rendering.RenderingThreadingMode;
        /**
        * The foveated rendering technique supported on this platform.
        */
        public static get foveatedRenderingCaps(): UnityEngine_Rendering.FoveatedRenderingCaps;
        /**
        * True if the GPU supports hidden surface removal.
        */
        public static get hasHiddenSurfaceRemovalOnGPU(): boolean;
        /**
        * Returns true when the GPU has native support for indexing uniform arrays in fragment shaders without restrictions.
        */
        public static get hasDynamicUniformArrayIndexingInFragmentShaders(): boolean;
        /**
        * Are built-in shadows supported? (Read Only)
        */
        public static get supportsShadows(): boolean;
        /**
        * Is sampling raw depth from shadowmaps supported? (Read Only)
        */
        public static get supportsRawShadowDepthSampling(): boolean;
        /**
        * Whether motion vectors are supported on this platform.
        */
        public static get supportsMotionVectors(): boolean;
        /**
        * Are 3D (volume) textures supported? (Read Only)
        */
        public static get supports3DTextures(): boolean;
        /**
        * Are compressed formats for 3D (volume) textures supported? (Read Only).
        */
        public static get supportsCompressed3DTextures(): boolean;
        /**
        * Are 2D Array textures supported? (Read Only)
        */
        public static get supports2DArrayTextures(): boolean;
        /**
        * Are 3D (volume) RenderTextures supported? (Read Only)
        */
        public static get supports3DRenderTextures(): boolean;
        /**
        * Are Cubemap Array textures supported? (Read Only)
        */
        public static get supportsCubemapArrayTextures(): boolean;
        /**
        * Support for various Graphics.CopyTexture cases (Read Only).
        */
        public static get copyTextureSupport(): UnityEngine_Rendering.CopyTextureSupport;
        /**
        * Are compute shaders supported? (Read Only)
        */
        public static get supportsComputeShaders(): boolean;
        /**
        * Are geometry shaders supported? (Read Only)
        */
        public static get supportsGeometryShaders(): boolean;
        /**
        * Are tessellation shaders supported? (Read Only)
        */
        public static get supportsTessellationShaders(): boolean;
        /**
        * Boolean that indicates if SV_RenderTargetArrayIndex can be used in a vertex shader (true if it can be used, false if not).
        */
        public static get supportsRenderTargetArrayIndexFromVertexShader(): boolean;
        /**
        * Is GPU draw call instancing supported? (Read Only)
        */
        public static get supportsInstancing(): boolean;
        /**
        * Does the hardware support quad topology? (Read Only)
        */
        public static get supportsHardwareQuadTopology(): boolean;
        /**
        * Are 32-bit index buffers supported? (Read Only)
        */
        public static get supports32bitsIndexBuffer(): boolean;
        /**
        * Are sparse textures supported? (Read Only)
        */
        public static get supportsSparseTextures(): boolean;
        /**
        * How many simultaneous render targets (MRTs) are supported? (Read Only)
        */
        public static get supportedRenderTargetCount(): int;
        /**
        * Returns true when the platform supports different blend modes when rendering to multiple render targets, or false otherwise.
        */
        public static get supportsSeparatedRenderTargetsBlend(): boolean;
        /**
        * The maximum number of random write targets (UAV) that Unity supports simultaneously. (Read Only)
        */
        public static get supportedRandomWriteTargetCount(): int;
        /**
        * Are multisampled textures supported? (Read Only)
        */
        public static get supportsMultisampledTextures(): int;
        /**
        * Boolean that indicates whether multisampled texture arrays are supported (true if supported, false if not supported).
        */
        public static get supportsMultisampled2DArrayTextures(): boolean;
        /**
        * Returns true if multisampled textures are resolved automatically
        */
        public static get supportsMultisampleAutoResolve(): boolean;
        /**
        * Returns true if the 'Mirror Once' texture wrap mode is supported. (Read Only)
        */
        public static get supportsTextureWrapMirrorOnce(): int;
        /**
        * This property is true if the current platform uses a reversed depth buffer (where values range from 1 at the near plane and 0 at far plane), and false if the depth buffer is normal (0 is near, 1 is far). (Read Only)
        */
        public static get usesReversedZBuffer(): boolean;
        /**
        * What NPOT (non-power of two size) texture support does the GPU provide? (Read Only)
        */
        public static get npotSupport(): NPOTSupport;
        /**
        * Maximum texture size in pixels (Read Only).
        */
        public static get maxTextureSize(): int;
        /**
        * Maximum 3D texture size in pixels (Read Only).
        */
        public static get maxTexture3DSize(): int;
        /**
        * Maximum number of slices in a Texture array (Read Only).
        */
        public static get maxTextureArraySlices(): int;
        /**
        * Maximum cubemap texture size in pixels (Read Only).
        */
        public static get maxCubemapSize(): int;
        /**
        * Determines how many compute buffers Unity supports simultaneously in a vertex shader for reading. (Read Only)
        */
        public static get maxComputeBufferInputsVertex(): int;
        /**
        * Determines how many compute buffers Unity supports simultaneously in a fragment shader for reading. (Read Only)
        */
        public static get maxComputeBufferInputsFragment(): int;
        /**
        * Determines how many compute buffers Unity supports simultaneously in a geometry shader for reading. (Read Only)
        */
        public static get maxComputeBufferInputsGeometry(): int;
        /**
        * Determines how many compute buffers Unity supports simultaneously in a domain shader for reading. (Read Only)
        */
        public static get maxComputeBufferInputsDomain(): int;
        /**
        * Determines how many compute buffers Unity supports simultaneously in a hull shader for reading. (Read Only)
        */
        public static get maxComputeBufferInputsHull(): int;
        /**
        * Determines how many compute buffers Unity supports simultaneously in a compute shader for reading. (Read Only)
        */
        public static get maxComputeBufferInputsCompute(): int;
        /**
        * The largest total number of invocations in a single local work group that can be dispatched to a compute shader (Read Only).
        */
        public static get maxComputeWorkGroupSize(): int;
        /**
        * The maximum number of work groups that a compute shader can use in X dimension (Read Only).
        */
        public static get maxComputeWorkGroupSizeX(): int;
        /**
        * The maximum number of work groups that a compute shader can use in Y dimension (Read Only).
        */
        public static get maxComputeWorkGroupSizeY(): int;
        /**
        * The maximum number of work groups that a compute shader can use in Z dimension (Read Only).
        */
        public static get maxComputeWorkGroupSizeZ(): int;
        /**
        * Size of the compute thread group that supports efficient memory sharing on the GPU (Read Only).
        */
        public static get computeSubGroupSize(): int;
        /**
        * Returns true when the platform supports asynchronous compute queues and false if otherwise.
        */
        public static get supportsAsyncCompute(): boolean;
        /**
        * Specifies whether the current platform supports the GPU Recorder or not. (Read Only).
        */
        public static get supportsGpuRecorder(): boolean;
        /**
        * true if the platform supports GraphicsFences, otherwise false.
        */
        public static get supportsGraphicsFence(): boolean;
        /**
        * Returns true if asynchronous readback of GPU data is available for this device and false otherwise.
        */
        public static get supportsAsyncGPUReadback(): boolean;
        /**
        * Checks if ray tracing is supported by the current configuration.
        */
        public static get supportsRayTracing(): boolean;
        /**
        * Does the current renderer support binding constant buffers directly? (Read Only)
        */
        public static get supportsSetConstantBuffer(): boolean;
        /**
        * Minimum buffer offset (in bytes) when binding a constant buffer using Shader.SetConstantBuffer or Material.SetConstantBuffer.
        */
        public static get constantBufferOffsetAlignment(): int;
        /**
        * The maximum size of a constant buffer binding (Read Only).
        */
        public static get maxConstantBufferSize(): int;
        /**
        * The maximum size of a graphics buffer (GraphicsBuffer, ComputeBuffer, vertex/index buffer, etc.) in bytes (Read Only).
        */
        public static get maxGraphicsBufferSize(): bigint;
        /**
        * Returns true if the GPU supports partial mipmap chains (Read Only).
        */
        public static get hasMipMaxLevel(): boolean;
        /**
        * Is streaming of texture mip maps supported? (Read Only)
        */
        public static get supportsMipStreaming(): boolean;
        /**
        * True if the Graphics API takes RenderBufferLoadAction and RenderBufferStoreAction into account, false if otherwise.
        */
        public static get usesLoadStoreActions(): boolean;
        /**
        * Returns a bitwise combination of HDRDisplaySupportFlags describing the support for HDR displays on the system.
        */
        public static get hdrDisplaySupportFlags(): HDRDisplaySupportFlags;
        /**
        * Is conservative rasterization supported? (Read Only)
        */
        public static get supportsConservativeRaster(): boolean;
        /**
        * Boolean that indicates whether Multiview is supported (true if supported, false if not supported). (Read Only)
        */
        public static get supportsMultiview(): boolean;
        /**
        * This property is true if the graphics API of the target build platform takes RenderBufferStoreAction.StoreAndResolve into account, false if otherwise.
        */
        public static get supportsStoreAndResolveAction(): boolean;
        /**
        * Returns true if the platform supports multisample resolve of depth textures.
        */
        public static get supportsMultisampleResolveDepth(): boolean;
        /**
        * Returns true if the platform supports multisample resolve of stencil textures. Otherwise, returns false.
        */
        public static get supportsMultisampleResolveStencil(): boolean;
        /**
        * Returns true if the graphics system supports GPU draw calls with indirect argument buffers. (Read Only)
        */
        public static get supportsIndirectArgumentsBuffer(): boolean;

        public constructor ()
        /**
        * Is render texture format supported?
        * @param format The format to look up.
        * @returns True if the format is supported.
        */
        public static SupportsRenderTextureFormat ($format: RenderTextureFormat) : boolean
        /**
        * Is blending supported on render texture format?
        * @param format The format to look up.
        * @returns True if blending is supported on the given format.
        */
        public static SupportsBlendingOnRenderTextureFormat ($format: RenderTextureFormat) : boolean
        /**
        * Tests if a RenderTextureFormat can be used with RenderTexture.enableRandomWrite.
        * @param format The format to look up.
        * @returns True if the format can be used for random access writes.
        */
        public static SupportsRandomWriteOnRenderTextureFormat ($format: RenderTextureFormat) : boolean
        /**
        * Is texture format supported on this device?
        * @param format The TextureFormat format to look up.
        * @returns True if the format is supported.
        */
        public static SupportsTextureFormat ($format: TextureFormat) : boolean
        /**
        * Indicates whether the given combination of a vertex attribute format and dimension is supported on this device.
        * @param format The VertexAttributeFormat format to look up.
        * @param dimension The dimension of vertex data to check for.
        * @returns True if the format with the given dimension is supported.
        */
        public static SupportsVertexAttributeFormat ($format: UnityEngine_Rendering.VertexAttributeFormat, $dimension: int) : boolean
        public static IsFormatSupported ($format: UnityEngine_Experimental_Rendering.GraphicsFormat, $usage: UnityEngine_Experimental_Rendering.FormatUsage) : boolean
        public static GetCompatibleFormat ($format: UnityEngine_Experimental_Rendering.GraphicsFormat, $usage: UnityEngine_Experimental_Rendering.FormatUsage) : UnityEngine_Experimental_Rendering.GraphicsFormat
        /**
        * Returns the platform-specific GraphicsFormat that is associated with the DefaultFormat.
        * @param format The DefaultFormat format to look up.
        */
        public static GetGraphicsFormat ($format: UnityEngine_Experimental_Rendering.DefaultFormat) : UnityEngine_Experimental_Rendering.GraphicsFormat
        /**
        * Checks if the target platform supports the MSAA samples count in the RenderTextureDescriptor argument.
        * @param desc The RenderTextureDescriptor to check.
        * @returns If the target platform supports the given MSAA samples count of RenderTextureDescriptor, returns the given MSAA samples count. Otherwise returns a lower fallback MSAA samples count value that the target platform supports.
        */
        public static GetRenderTextureSupportedMSAASampleCount ($desc: RenderTextureDescriptor) : int
    }

    /**
    * Provides an interface to get time information from Unity.
    */
    class Time extends System.Object {

        /**
        * The time at the beginning of the current frame in seconds since the start of the application (Read Only).
        */
        public static get time(): float;
        /**
        * The double precision time at the beginning of this frame (Read Only). This is the time in seconds since the start of the game.
        */
        public static get timeAsDouble(): double;
        /**
        * The time in seconds since the last non-additive scene finished loading (Read Only).
        */
        public static get timeSinceLevelLoad(): float;
        /**
        * The double precision time in seconds since the last non-additive scene finished loading (Read Only).
        */
        public static get timeSinceLevelLoadAsDouble(): double;
        /**
        * The interval in seconds from the last frame to the current one (Read Only).
        */
        public static get deltaTime(): float;
        /**
        * The time at which the current MonoBehaviour.FixedUpdate started in seconds since the start of the game (Read Only).
        */
        public static get fixedTime(): float;
        /**
        * The double precision time since the last MonoBehaviour.FixedUpdate started (Read Only). This is the time in seconds since the start of the game.
        */
        public static get fixedTimeAsDouble(): double;
        /**
        * The timeScale-independent time for this frame (Read Only). This is the time in seconds since the start of the game.
        */
        public static get unscaledTime(): float;
        /**
        * The double precision timeScale-independent time for this frame (Read Only). This is the time in seconds since the start of the game.
        */
        public static get unscaledTimeAsDouble(): double;
        /**
        * The timeScale-independent time at the beginning of the last MonoBehaviour.FixedUpdate phase (Read Only). This is the time in seconds since the start of the game.
        */
        public static get fixedUnscaledTime(): float;
        /**
        * The double precision timeScale-independent time at the beginning of the last MonoBehaviour.FixedUpdate (Read Only). This is the time in seconds since the start of the game.
        */
        public static get fixedUnscaledTimeAsDouble(): double;
        /**
        * The timeScale-independent interval in seconds from the last frame to the current one (Read Only).
        */
        public static get unscaledDeltaTime(): float;
        /**
        * The interval in seconds of timeScale-independent ("real") time at which physics and other fixed frame rate updates (like MonoBehaviour's MonoBehaviour.FixedUpdate) are performed.(Read Only).
        */
        public static get fixedUnscaledDeltaTime(): float;
        /**
        * The interval in seconds of in-game time at which physics and other fixed frame rate updates (like MonoBehaviour's MonoBehaviour.FixedUpdate) are performed.
        */
        public static get fixedDeltaTime(): float;
        public static set fixedDeltaTime(value: float);
        /**
        * The maximum value of Time.deltaTime in any given frame. This is a time in seconds that limits the increase of Time.time between two frames.
        */
        public static get maximumDeltaTime(): float;
        public static set maximumDeltaTime(value: float);
        /**
        * A smoothed out Time.deltaTime (Read Only).
        */
        public static get smoothDeltaTime(): float;
        /**
        * The maximum time a frame can spend on particle updates. If the frame takes longer than this, then updates are split into multiple smaller updates.
        */
        public static get maximumParticleDeltaTime(): float;
        public static set maximumParticleDeltaTime(value: float);
        /**
        * The scale at which time passes.
        */
        public static get timeScale(): float;
        public static set timeScale(value: float);
        /**
        * The total number of frames since the start of the game (Read Only).
        */
        public static get frameCount(): int;
        public static get renderedFrameCount(): int;
        /**
        * The real time in seconds since the game started (Read Only).
        */
        public static get realtimeSinceStartup(): float;
        /**
        * The real time in seconds since the game started (Read Only). Double precision version of Time.realtimeSinceStartup.
        */
        public static get realtimeSinceStartupAsDouble(): double;
        /**
        * Slows your application’s playback time to allow Unity to save screenshots in between frames.
        */
        public static get captureDeltaTime(): float;
        public static set captureDeltaTime(value: float);
        /**
        * The reciprocal of Time.captureDeltaTime.
        */
        public static get captureFramerate(): int;
        public static set captureFramerate(value: int);
        /**
        * Returns true if called inside a fixed time step callback (like MonoBehaviour's MonoBehaviour.FixedUpdate), otherwise returns false (Read Only).
        */
        public static get inFixedTimeStep(): boolean;

        public constructor ()
    }

    /**
    * Interface for on-screen keyboards. Only native iPhone, Android, and Windows Store Apps are supported.
    */
    class TouchScreenKeyboard extends System.Object {

        /**
        * Is touch screen keyboard supported.
        */
        public static get isSupported(): boolean;
        /**
        * Checks if the text within an input field can be selected and modified while TouchScreenKeyboard is open.
        * @returns Returns true when you are able to select and modify the input field, returns false otherwise.
        */
        public static get isInPlaceEditingAllowed(): boolean;
        /**
        * Returns the text displayed by the input field of the keyboard.
        */
        public get text(): string;
        public set text(value: string);
        /**
        * Will text input field above the keyboard be hidden when the keyboard is on screen?
        */
        public static get hideInput(): boolean;
        public static set hideInput(value: boolean);
        /**
        * Is the keyboard visible or sliding into the position on the screen?
        */
        public get active(): boolean;
        public set active(value: boolean);
        /**
        * Returns the status of the on-screen keyboard. (Read Only)
        */
        public get status(): UnityEngine_TouchScreenKeyboard.Status;
        /**
        * How many characters the keyboard input field is limited to. 0 = infinite.
        */
        public get characterLimit(): int;
        public set characterLimit(value: int);
        /**
        * Specifies whether the TouchScreenKeyboard supports the selection property. (Read Only)
        */
        public get canGetSelection(): boolean;
        /**
        * Specifies whether the TouchScreenKeyboard supports the selection property. (Read Only)
        */
        public get canSetSelection(): boolean;
        /**
        * Gets or sets the character range of the selected text within the string currently being edited.
        */
        public get selection(): RangeInt;
        public set selection(value: RangeInt);
        /**
        * Returns the TouchScreenKeyboardType of the keyboard.
        */
        public get type(): TouchScreenKeyboardType;
        /**
        * Specified on which display the on-screen keyboard will appear.
        */
        public get targetDisplay(): int;
        public set targetDisplay(value: int);
        /**
        * Returns portion of the screen which is covered by the keyboard.
        */
        public static get area(): Rect;
        /**
        * Returns true whenever any keyboard is visible on the screen.
        */
        public static get visible(): boolean;

        public constructor ($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: int)
        /**
        * Opens the native keyboard provided by OS on the screen.
        * @param text Text to edit.
        * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
        * @param autocorrection Is autocorrection applied?
        * @param multiline Can more than one line of text be entered?
        * @param secure Is the text masked (for passwords, etc)?
        * @param alert Is the keyboard opened in alert mode?
        * @param textPlaceholder Text to be used if no other text is present.
        * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
        * @methodSwap Open_EBB7509C_H80603B75
        */
        public static Open ($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: int) : TouchScreenKeyboard
        /**
        * Opens the native keyboard provided by OS on the screen.
        * @param text Text to edit.
        * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
        * @param autocorrection Is autocorrection applied?
        * @param multiline Can more than one line of text be entered?
        * @param secure Is the text masked (for passwords, etc)?
        * @param alert Is the keyboard opened in alert mode?
        * @param textPlaceholder Text to be used if no other text is present.
        * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
        */
        public static Open ($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string) : TouchScreenKeyboard
        /**
        * Opens the native keyboard provided by OS on the screen.
        * @param text Text to edit.
        * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
        * @param autocorrection Is autocorrection applied?
        * @param multiline Can more than one line of text be entered?
        * @param secure Is the text masked (for passwords, etc)?
        * @param alert Is the keyboard opened in alert mode?
        * @param textPlaceholder Text to be used if no other text is present.
        * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
        */
        public static Open ($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean) : TouchScreenKeyboard
        /**
        * Opens the native keyboard provided by OS on the screen.
        * @param text Text to edit.
        * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
        * @param autocorrection Is autocorrection applied?
        * @param multiline Can more than one line of text be entered?
        * @param secure Is the text masked (for passwords, etc)?
        * @param alert Is the keyboard opened in alert mode?
        * @param textPlaceholder Text to be used if no other text is present.
        * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
        */
        public static Open ($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean) : TouchScreenKeyboard
        /**
        * Opens the native keyboard provided by OS on the screen.
        * @param text Text to edit.
        * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
        * @param autocorrection Is autocorrection applied?
        * @param multiline Can more than one line of text be entered?
        * @param secure Is the text masked (for passwords, etc)?
        * @param alert Is the keyboard opened in alert mode?
        * @param textPlaceholder Text to be used if no other text is present.
        * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
        */
        public static Open ($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean) : TouchScreenKeyboard
        /**
        * Opens the native keyboard provided by OS on the screen.
        * @param text Text to edit.
        * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
        * @param autocorrection Is autocorrection applied?
        * @param multiline Can more than one line of text be entered?
        * @param secure Is the text masked (for passwords, etc)?
        * @param alert Is the keyboard opened in alert mode?
        * @param textPlaceholder Text to be used if no other text is present.
        * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
        */
        public static Open ($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean) : TouchScreenKeyboard
        /**
        * Opens the native keyboard provided by OS on the screen.
        * @param text Text to edit.
        * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
        * @param autocorrection Is autocorrection applied?
        * @param multiline Can more than one line of text be entered?
        * @param secure Is the text masked (for passwords, etc)?
        * @param alert Is the keyboard opened in alert mode?
        * @param textPlaceholder Text to be used if no other text is present.
        * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
        */
        public static Open ($text: string, $keyboardType: TouchScreenKeyboardType) : TouchScreenKeyboard
        /**
        * Opens the native keyboard provided by OS on the screen.
        * @param text Text to edit.
        * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
        * @param autocorrection Is autocorrection applied?
        * @param multiline Can more than one line of text be entered?
        * @param secure Is the text masked (for passwords, etc)?
        * @param alert Is the keyboard opened in alert mode?
        * @param textPlaceholder Text to be used if no other text is present.
        * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
        */
        public static Open ($text: string) : TouchScreenKeyboard
    }

    /**
    * Enumeration of the different types of supported touchscreen keyboards.
    */
    enum TouchScreenKeyboardType {
        Default = 0,
        ASCIICapable = 1,
        NumbersAndPunctuation = 2,
        URL = 3,
        NumberPad = 4,
        PhonePad = 5,
        NamePhonePad = 6,
        EmailAddress = 7,
        NintendoNetworkAccount = 8,
        Social = 9,
        Search = 10,
        DecimalPad = 11,
        OneTimeCode = 12 
    }

    class UnityEventQueueSystem extends System.Object {

        public constructor ()
        public static GenerateEventIdForPayload ($eventPayloadName: string) : string
        public static GetGlobalEventQueue () : System.IntPtr
    }

    /**
    * Representation of a Position, and a Rotation in 3D Space
    */
    class Pose extends System.ValueType implements System.IEquatable$1<Pose> {

        /**
        * The position component of the pose.
        */
        public position : Vector3
        /**
        * The rotation component of the pose.
        */
        public rotation : Quaternion
        /**
        * Returns the forward vector of the pose.
        */
        public get forward(): Vector3;
        /**
        * Returns the right vector of the pose.
        */
        public get right(): Vector3;
        /**
        * Returns the up vector of the pose.
        */
        public get up(): Vector3;
        /**
        * Shorthand for pose which represents zero position, and an identity rotation.
        */
        public static get identity(): Pose;

        /**
        * Creates a new pose with the given vector, and quaternion values.
        */
        public constructor ($position: Vector3, $rotation: Quaternion)
        public ToString () : string
        public ToString ($format: string) : string
        /**
        * Transforms the current pose into the local space of the provided pose.
        */
        public GetTransformedBy ($lhs: Pose) : Pose
        /**
        * Transforms the current pose into the local space of the provided pose.
        */
        public GetTransformedBy ($lhs: Transform) : Pose
        public Equals ($obj: any) : boolean
        public Equals ($other: Pose) : boolean
        public GetHashCode () : int
        public static op_Equality ($a: Pose, $b: Pose) : boolean
        public static op_Inequality ($a: Pose, $b: Pose) : boolean
    }

    /**
    * Controls the from a script.
    */
    class FrameDebugger {

        /**
        * Queries whether the is enabled.
        */
        public static get enabled(): boolean;

    }

    /**
    * An enumeration of transform properties that can be driven on a RectTransform by an object.
    */
    enum DrivenTransformProperties {
        None = 0,
        All = -1,
        AnchoredPositionX = 2,
        AnchoredPositionY = 4,
        AnchoredPositionZ = 8,
        Rotation = 16,
        ScaleX = 32,
        ScaleY = 64,
        ScaleZ = 128,
        AnchorMinX = 256,
        AnchorMinY = 512,
        AnchorMaxX = 1024,
        AnchorMaxY = 2048,
        SizeDeltaX = 4096,
        SizeDeltaY = 8192,
        PivotX = 16384,
        PivotY = 32768,
        AnchoredPosition = 6,
        AnchoredPosition3D = 14,
        Scale = 224,
        AnchorMin = 768,
        AnchorMax = 3072,
        Anchors = 3840,
        SizeDelta = 12288,
        Pivot = 49152 
    }

    /**
    * A component can be designed to drive a RectTransform. The DrivenRectTransformTracker struct is used to specify which RectTransforms it is driving.
    */
    class DrivenRectTransformTracker extends System.ValueType {

        /**
        * Add a RectTransform to be driven.
        * @param driver The object to drive properties.
        * @param rectTransform The RectTransform to be driven.
        * @param drivenProperties The properties to be driven.
        */
        public Add ($driver: Object, $rectTransform: RectTransform, $drivenProperties: DrivenTransformProperties) : void
        /**
        * Clear the list of RectTransforms being driven.
        */
        public Clear () : void
    }

    /**
    * Position, size, anchor and pivot information for a rectangle.
    */
    class RectTransform extends Transform {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * The world space position of the Transform.
        */
        public get position(): Vector3;
        public set position(value: Vector3);
        /**
        * Position of the transform relative to the parent transform.
        */
        public get localPosition(): Vector3;
        public set localPosition(value: Vector3);
        /**
        * The rotation as Euler angles in degrees.
        */
        public get eulerAngles(): Vector3;
        public set eulerAngles(value: Vector3);
        /**
        * The rotation as Euler angles in degrees relative to the parent transform's rotation.
        */
        public get localEulerAngles(): Vector3;
        public set localEulerAngles(value: Vector3);
        /**
        * The red axis of the transform in world space.
        */
        public get right(): Vector3;
        public set right(value: Vector3);
        /**
        * The green axis of the transform in world space.
        */
        public get up(): Vector3;
        public set up(value: Vector3);
        /**
        * Returns a normalized vector representing the blue axis of the transform in world space.
        */
        public get forward(): Vector3;
        public set forward(value: Vector3);
        /**
        * A Quaternion that stores the rotation of the Transform in world space.
        */
        public get rotation(): Quaternion;
        public set rotation(value: Quaternion);
        /**
        * The rotation of the transform relative to the transform rotation of the parent.
        */
        public get localRotation(): Quaternion;
        public set localRotation(value: Quaternion);
        /**
        * The scale of the transform relative to the GameObjects parent.
        */
        public get localScale(): Vector3;
        public set localScale(value: Vector3);
        /**
        * The parent of the transform.
        */
        public get parent(): Transform;
        public set parent(value: Transform);
        /**
        * Matrix that transforms a point from world space into local space (Read Only).
        */
        public get worldToLocalMatrix(): Matrix4x4;
        /**
        * Matrix that transforms a point from local space into world space (Read Only).
        */
        public get localToWorldMatrix(): Matrix4x4;
        /**
        * Returns the topmost transform in the hierarchy.
        */
        public get root(): Transform;
        /**
        * The number of children the parent Transform has.
        */
        public get childCount(): int;
        /**
        * The global scale of the object (Read Only).
        */
        public get lossyScale(): Vector3;
        /**
        * Has the transform changed since the last time the flag was set to 'false'?
        */
        public get hasChanged(): boolean;
        public set hasChanged(value: boolean);
        /**
        * The transform capacity of the transform's hierarchy data structure.
        */
        public get hierarchyCapacity(): int;
        public set hierarchyCapacity(value: int);
        /**
        * The number of transforms in the transform's hierarchy data structure.
        */
        public get hierarchyCount(): int;
        /**
        * The calculated rectangle in the local space of the Transform.
        */
        public get rect(): Rect;
        /**
        * The normalized position in the parent RectTransform that the lower left corner is anchored to.
        */
        public get anchorMin(): Vector2;
        public set anchorMin(value: Vector2);
        /**
        * The normalized position in the parent RectTransform that the upper right corner is anchored to.
        */
        public get anchorMax(): Vector2;
        public set anchorMax(value: Vector2);
        /**
        * The position of the pivot of this RectTransform relative to the anchor reference point.
        */
        public get anchoredPosition(): Vector2;
        public set anchoredPosition(value: Vector2);
        /**
        * The size of this RectTransform relative to the distances between the anchors.
        */
        public get sizeDelta(): Vector2;
        public set sizeDelta(value: Vector2);
        /**
        * The normalized position in this RectTransform that it rotates around.
        */
        public get pivot(): Vector2;
        public set pivot(value: Vector2);
        /**
        * The 3D position of the pivot of this RectTransform relative to the anchor reference point.
        */
        public get anchoredPosition3D(): Vector3;
        public set anchoredPosition3D(value: Vector3);
        /**
        * The offset of the lower left corner of the rectangle relative to the lower left anchor.
        */
        public get offsetMin(): Vector2;
        public set offsetMin(value: Vector2);
        /**
        * The offset of the upper right corner of the rectangle relative to the upper right anchor.
        */
        public get offsetMax(): Vector2;
        public set offsetMax(value: Vector2);
        /**
        * The object that is driving the values of this RectTransform. Value is null if not driven.
        */
        public get drivenByObject(): Object;

        private constructor ()
        /**
        * Force the recalculation of RectTransforms internal data.
        */
        public ForceUpdateRectTransforms () : void
        /**
        * Get the corners of the calculated rectangle in the local space of its Transform.
        * @param fourCornersArray The array that corners are filled into.
        */
        public GetLocalCorners ($fourCornersArray: Vector3[]) : void
        /**
        * Get the corners of the calculated rectangle in world space.
        * @param fourCornersArray The array that corners are filled into.
        */
        public GetWorldCorners ($fourCornersArray: Vector3[]) : void
        /**
        * Set the distance of this rectangle relative to a specified edge of the parent rectangle, while also setting its size.
        * @param edge The edge of the parent rectangle to inset from.
        * @param inset The inset distance.
        * @param size The size of the rectangle along the same direction of the inset.
        */
        public SetInsetAndSizeFromParentEdge ($edge: UnityEngine_RectTransform.Edge, $inset: float, $size: float) : void
        /**
        * Makes the RectTransform calculated rect be a given size on the specified axis.
        * @param axis The axis to specify the size along.
        * @param size The desired size along the specified axis.
        */
        public SetSizeWithCurrentAnchors ($axis: UnityEngine_RectTransform.Axis, $size: float) : void
        public static add_reapplyDrivenProperties ($value: UnityEngine_RectTransform.ReapplyDrivenProperties) : void
        public static remove_reapplyDrivenProperties ($value: UnityEngine_RectTransform.ReapplyDrivenProperties) : void
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * SpriteRenderer draw mode.
    */
    enum SpriteDrawMode {
        Simple = 0,
        Sliced = 1,
        Tiled = 2 
    }

    /**
    * Tiling mode for SpriteRenderer.tileMode.
    */
    enum SpriteTileMode {
        Continuous = 0,
        Adaptive = 1 
    }

    /**
    * Renders a Sprite for 2D graphics.
    */
    class SpriteRenderer extends Renderer {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * The bounding box of the renderer in world space.
        */
        public get bounds(): Bounds;
        public set bounds(value: Bounds);
        /**
        * The bounding box of the renderer in local space.
        */
        public get localBounds(): Bounds;
        public set localBounds(value: Bounds);
        /**
        * Makes the rendered 3D object visible if enabled.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Is this renderer visible in any camera? (Read Only)
        */
        public get isVisible(): boolean;
        /**
        * Does this object cast shadows?
        */
        public get shadowCastingMode(): UnityEngine_Rendering.ShadowCastingMode;
        public set shadowCastingMode(value: UnityEngine_Rendering.ShadowCastingMode);
        /**
        * Does this object receive shadows?
        */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
        * Allows turning off rendering for a specific component.
        */
        public get forceRenderingOff(): boolean;
        public set forceRenderingOff(value: boolean);
        /**
        * Is this renderer a static shadow caster?
        */
        public get staticShadowCaster(): boolean;
        public set staticShadowCaster(value: boolean);
        /**
        * Specifies the mode for motion vector rendering.
        */
        public get motionVectorGenerationMode(): MotionVectorGenerationMode;
        public set motionVectorGenerationMode(value: MotionVectorGenerationMode);
        /**
        * The light probe interpolation type.
        */
        public get lightProbeUsage(): UnityEngine_Rendering.LightProbeUsage;
        public set lightProbeUsage(value: UnityEngine_Rendering.LightProbeUsage);
        /**
        * Should reflection probes be used for this Renderer?
        */
        public get reflectionProbeUsage(): UnityEngine_Rendering.ReflectionProbeUsage;
        public set reflectionProbeUsage(value: UnityEngine_Rendering.ReflectionProbeUsage);
        /**
        * Determines which rendering layer this renderer lives on, if you use a.
        */
        public get renderingLayerMask(): uint;
        public set renderingLayerMask(value: uint);
        /**
        * This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
        */
        public get rendererPriority(): int;
        public set rendererPriority(value: int);
        /**
        * Describes how this renderer is updated for ray tracing.
        */
        public get rayTracingMode(): UnityEngine_Experimental_Rendering.RayTracingMode;
        public set rayTracingMode(value: UnityEngine_Experimental_Rendering.RayTracingMode);
        /**
        * Name of the Renderer's sorting layer.
        */
        public get sortingLayerName(): string;
        public set sortingLayerName(value: string);
        /**
        * Unique ID of the Renderer's sorting layer.
        */
        public get sortingLayerID(): int;
        public set sortingLayerID(value: int);
        /**
        * Renderer's order within a sorting layer.
        */
        public get sortingOrder(): int;
        public set sortingOrder(value: int);
        /**
        * Controls if dynamic occlusion culling should be performed for this renderer.
        */
        public get allowOcclusionWhenDynamic(): boolean;
        public set allowOcclusionWhenDynamic(value: boolean);
        /**
        * Indicates whether the renderer is part of a with other renderers.
        */
        public get isPartOfStaticBatch(): boolean;
        /**
        * Matrix that transforms a point from world space into local space (Read Only).
        */
        public get worldToLocalMatrix(): Matrix4x4;
        /**
        * Matrix that transforms a point from local space into world space (Read Only).
        */
        public get localToWorldMatrix(): Matrix4x4;
        /**
        * If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
        */
        public get lightProbeProxyVolumeOverride(): GameObject;
        public set lightProbeProxyVolumeOverride(value: GameObject);
        /**
        * If set, Renderer will use this Transform's position to find the light or reflection probe.
        */
        public get probeAnchor(): Transform;
        public set probeAnchor(value: Transform);
        /**
        * The index of the baked lightmap applied to this renderer.
        */
        public get lightmapIndex(): int;
        public set lightmapIndex(value: int);
        /**
        * The index of the real-time lightmap applied to this renderer.
        */
        public get realtimeLightmapIndex(): int;
        public set realtimeLightmapIndex(value: int);
        /**
        * The UV scale & offset used for a lightmap.
        */
        public get lightmapScaleOffset(): Vector4;
        public set lightmapScaleOffset(value: Vector4);
        /**
        * The UV scale & offset used for a real-time lightmap.
        */
        public get realtimeLightmapScaleOffset(): Vector4;
        public set realtimeLightmapScaleOffset(value: Vector4);
        /**
        * Returns all the instantiated materials of this object.
        */
        public get materials(): Material[];
        public set materials(value: Material[]);
        /**
        * Returns the first instantiated Material assigned to the renderer.
        */
        public get material(): Material;
        public set material(value: Material);
        /**
        * The shared material of this object.
        */
        public get sharedMaterial(): Material;
        public set sharedMaterial(value: Material);
        /**
        * All the shared materials of this object.
        */
        public get sharedMaterials(): Material[];
        public set sharedMaterials(value: Material[]);
        /**
        * The Sprite to render.
        */
        public get sprite(): Sprite;
        public set sprite(value: Sprite);
        /**
        * The current draw mode of the Sprite Renderer.
        */
        public get drawMode(): SpriteDrawMode;
        public set drawMode(value: SpriteDrawMode);
        /**
        * Property to set or get the size to render when the SpriteRenderer.drawMode is set to SpriteDrawMode.Sliced or SpriteDrawMode.Tiled.
        */
        public get size(): Vector2;
        public set size(value: Vector2);
        /**
        * The current threshold for Sprite Renderer tiling.
        */
        public get adaptiveModeThreshold(): float;
        public set adaptiveModeThreshold(value: float);
        /**
        * The current tile mode of the Sprite Renderer.
        */
        public get tileMode(): SpriteTileMode;
        public set tileMode(value: SpriteTileMode);
        /**
        * Rendering color for the Sprite graphic.
        */
        public get color(): Color;
        public set color(value: Color);
        /**
        * Specifies how the sprite interacts with the masks.
        */
        public get maskInteraction(): SpriteMaskInteraction;
        public set maskInteraction(value: SpriteMaskInteraction);
        /**
        * Flips the sprite on the X axis.
        */
        public get flipX(): boolean;
        public set flipX(value: boolean);
        /**
        * Flips the sprite on the Y axis.
        */
        public get flipY(): boolean;
        public set flipY(value: boolean);
        /**
        * Determines the position of the Sprite used for sorting the SpriteRenderer.
        */
        public get spriteSortPoint(): SpriteSortPoint;
        public set spriteSortPoint(value: SpriteSortPoint);

        private constructor ()
        public RegisterSpriteChangeCallback ($callback: UnityEngine_Events.UnityAction$1<SpriteRenderer>) : void
        public UnregisterSpriteChangeCallback ($callback: UnityEngine_Events.UnityAction$1<SpriteRenderer>) : void
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInChildren ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : Component[]
        public GetComponentsInParent ($t: System.Type) : Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    /**
    * Represents a Sprite object for use in 2D gameplay.
    */
    class Sprite extends Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Bounds of the Sprite, specified by its center and extents in world space units.
        */
        public get bounds(): Bounds;
        /**
        * Location of the Sprite on the original Texture, specified in pixels.
        */
        public get rect(): Rect;
        /**
        * Returns the border sizes of the Sprite.
        */
        public get border(): Vector4;
        /**
        * Get the reference to the used Texture. If packed this will point to the atlas, if not packed will point to the source Sprite.
        */
        public get texture(): Texture2D;
        /**
        * The number of pixels in the Sprite that correspond to one unit in world space. (Read Only)
        */
        public get pixelsPerUnit(): float;
        /**
        * The Variant scale of Texture used by the Sprite. This is useful to check when a Variant SpriteAtlas is being used by Sprites.
        */
        public get spriteAtlasTextureScale(): float;
        /**
        * Returns the Texture that contains the alpha channel from the source Texture. Unity generates this Texture under the hood for Sprites that have alpha in the source, and need to be compressed using techniques like ETC1.
        * Returns NULL if there is no associated alpha Texture for the source Sprite. This is the case if the Sprite has not been setup to use ETC1 compression.
        */
        public get associatedAlphaSplitTexture(): Texture2D;
        /**
        * Location of the Sprite's pivot point in the Rect on the original Texture, specified in pixels.
        */
        public get pivot(): Vector2;
        /**
        * Returns true if this Sprite is packed in an atlas.
        */
        public get packed(): boolean;
        /**
        * If Sprite is packed (see Sprite.packed), returns its SpritePackingMode.
        */
        public get packingMode(): SpritePackingMode;
        /**
        * If Sprite is packed (see Sprite.packed), returns its SpritePackingRotation.
        */
        public get packingRotation(): SpritePackingRotation;
        /**
        * Get the rectangle this Sprite uses on its Texture. Raises an exception if this Sprite is tightly packed in an atlas.
        */
        public get textureRect(): Rect;
        /**
        * Gets the offset of the rectangle this Sprite uses on its Texture to the original Sprite bounds. If Sprite mesh type is FullRect, offset is zero.
        */
        public get textureRectOffset(): Vector2;
        /**
        * Returns a copy of the array containing Sprite mesh vertex positions.
        */
        public get vertices(): Vector2[];
        /**
        * Returns a copy of the array containing Sprite mesh triangles.
        */
        public get triangles(): ushort[];
        /**
        * The base Texture coordinates of the Sprite mesh.
        */
        public get uv(): Vector2[];

        /**
        * Gets the number of Secondary Textures that the Sprite is using.
        * @returns Returns the number of Secondary Textures that the Sprite is using.
        */
        public GetSecondaryTextureCount () : int
        /**
        * Retrieves an array of SecondarySpriteTexture used by the Sprite.
        * @param secondaryTexture The array of SecondarySpriteTexture to contain the Secondary Textures properties used by the Sprite.
        * @returns Returns the number of Secondary Textures properties retrieved.
        */
        public GetSecondaryTextures ($secondaryTexture: SecondarySpriteTexture[]) : int
        /**
        * The number of physics shapes for the Sprite.
        * @returns The number of physics shapes for the Sprite.
        */
        public GetPhysicsShapeCount () : int
        /**
        * The number of points in the selected physics shape for the Sprite.
        * @param shapeIdx The index of the physics shape to retrieve the number of points from.
        * @returns The number of points in the selected physics shape for the Sprite.
        */
        public GetPhysicsShapePointCount ($shapeIdx: int) : int
        public GetPhysicsShape ($shapeIdx: int, $physicsShape: System_Collections_Generic.List$1<Vector2>) : int
        public OverridePhysicsShape ($physicsShapes: System_Collections_Generic.IList$1<Vector2[]>) : void
        /**
        * Sets up new Sprite geometry.
        * @param vertices Array of vertex positions in Sprite Rect space.
        * @param triangles Array of sprite mesh triangle indices.
        */
        public OverrideGeometry ($vertices: Vector2[], $triangles: ushort[]) : void
        /**
        * Create a new Sprite object.
        * @param texture The Texture to obtain the Sprite graphic from.

        * @param rect The rectangular section of the Texture to use for the Sprite.

        * @param pivot The Sprite's pivot point relative to its graphic rectangle.

        * @param pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.

        * @param extrude The amount by which the Sprite mesh should be expanded outwards.

        * @param meshType The type of mesh that is generated for the Sprite.

        * @param border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).

        * @param generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
        * @param secondaryTextures The Secondary Texture properties to be used by the created Sprite.

        * @methodSwap Create_EBB7509C_H423FBE6B
        */
        public static Create ($texture: Texture2D, $rect: Rect, $pivot: Vector2, $pixelsPerUnit: float, $extrude: uint, $meshType: SpriteMeshType, $border: Vector4, $generateFallbackPhysicsShape: boolean) : Sprite
        /**
        * Create a new Sprite object.
        * @param texture The Texture to obtain the Sprite graphic from.

        * @param rect The rectangular section of the Texture to use for the Sprite.

        * @param pivot The Sprite's pivot point relative to its graphic rectangle.

        * @param pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.

        * @param extrude The amount by which the Sprite mesh should be expanded outwards.

        * @param meshType The type of mesh that is generated for the Sprite.

        * @param border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).

        * @param generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
        * @param secondaryTextures The Secondary Texture properties to be used by the created Sprite.

        * @methodSwap Create_EBB7509C_H23EAC57A
        */
        public static Create ($texture: Texture2D, $rect: Rect, $pivot: Vector2, $pixelsPerUnit: float, $extrude: uint, $meshType: SpriteMeshType, $border: Vector4, $generateFallbackPhysicsShape: boolean, $secondaryTextures: SecondarySpriteTexture[]) : Sprite
        /**
        * Create a new Sprite object.
        * @param texture The Texture to obtain the Sprite graphic from.

        * @param rect The rectangular section of the Texture to use for the Sprite.

        * @param pivot The Sprite's pivot point relative to its graphic rectangle.

        * @param pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.

        * @param extrude The amount by which the Sprite mesh should be expanded outwards.

        * @param meshType The type of mesh that is generated for the Sprite.

        * @param border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).

        * @param generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
        * @param secondaryTextures The Secondary Texture properties to be used by the created Sprite.

        * @methodSwap Create_EBB7509C_CFBB8980
        */
        public static Create ($texture: Texture2D, $rect: Rect, $pivot: Vector2, $pixelsPerUnit: float, $extrude: uint, $meshType: SpriteMeshType, $border: Vector4) : Sprite
        /**
        * Create a new Sprite object.
        * @param texture The Texture to obtain the Sprite graphic from.

        * @param rect The rectangular section of the Texture to use for the Sprite.

        * @param pivot The Sprite's pivot point relative to its graphic rectangle.

        * @param pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.

        * @param extrude The amount by which the Sprite mesh should be expanded outwards.

        * @param meshType The type of mesh that is generated for the Sprite.

        * @param border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).

        * @param generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
        * @param secondaryTextures The Secondary Texture properties to be used by the created Sprite.

        * @methodSwap Create_EBB7509C_H73C78D74
        */
        public static Create ($texture: Texture2D, $rect: Rect, $pivot: Vector2, $pixelsPerUnit: float, $extrude: uint, $meshType: SpriteMeshType) : Sprite
        /**
        * Create a new Sprite object.
        * @param texture The Texture to obtain the Sprite graphic from.

        * @param rect The rectangular section of the Texture to use for the Sprite.

        * @param pivot The Sprite's pivot point relative to its graphic rectangle.

        * @param pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.

        * @param extrude The amount by which the Sprite mesh should be expanded outwards.

        * @param meshType The type of mesh that is generated for the Sprite.

        * @param border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).

        * @param generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
        * @param secondaryTextures The Secondary Texture properties to be used by the created Sprite.

        * @methodSwap Create_EBB7509C_H4A6C528F
        */
        public static Create ($texture: Texture2D, $rect: Rect, $pivot: Vector2, $pixelsPerUnit: float, $extrude: uint) : Sprite
        /**
        * Create a new Sprite object.
        * @param texture The Texture to obtain the Sprite graphic from.

        * @param rect The rectangular section of the Texture to use for the Sprite.

        * @param pivot The Sprite's pivot point relative to its graphic rectangle.

        * @param pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.

        * @param extrude The amount by which the Sprite mesh should be expanded outwards.

        * @param meshType The type of mesh that is generated for the Sprite.

        * @param border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).

        * @param generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
        * @param secondaryTextures The Secondary Texture properties to be used by the created Sprite.

        * @methodSwap Create_EBB7509C_C474F6FD
        */
        public static Create ($texture: Texture2D, $rect: Rect, $pivot: Vector2, $pixelsPerUnit: float) : Sprite
        /**
        * Create a new Sprite object.
        * @param texture The Texture to obtain the Sprite graphic from.

        * @param rect The rectangular section of the Texture to use for the Sprite.

        * @param pivot The Sprite's pivot point relative to its graphic rectangle.

        * @param pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.

        * @param extrude The amount by which the Sprite mesh should be expanded outwards.

        * @param meshType The type of mesh that is generated for the Sprite.

        * @param border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).

        * @param generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
        * @param secondaryTextures The Secondary Texture properties to be used by the created Sprite.

        */
        public static Create ($texture: Texture2D, $rect: Rect, $pivot: Vector2) : Sprite
    }

    /**
    * Encapsulates a Texture2D and its shader property name to give Sprite-based renderers access to a secondary texture, in addition to the main Sprite texture.
    */
    class SecondarySpriteTexture extends System.ValueType {

        /**
        * The shader property name of the secondary Sprite texture. Use this name to identify and sample the texture in the shader.
        */
        public name : string
        /**
        * The texture to be used as a secondary Sprite texture.
        */
        public texture : Texture2D

    }

    /**
    * Defines the type of mesh generated for a sprite.
    */
    enum SpriteMeshType {
        FullRect = 0,
        Tight = 1 
    }

    /**
    * Sprite packing modes for the Sprite Packer.
    */
    enum SpritePackingMode {
        Tight = 0,
        Rectangle = 1 
    }

    /**
    * Sprite rotation modes for the Sprite Packer.
    */
    enum SpritePackingRotation {
        None = 0,
        FlipHorizontal = 1,
        FlipVertical = 2,
        Rotate180 = 3,
        Any = 15 
    }

    /**
    * Determines the position of the Sprite used for sorting the Renderer.
    */
    enum SpriteSortPoint {
        Center = 0,
        Pivot = 1 
    }

    /**
    * How a Sprite's graphic rectangle is aligned with its pivot point.
    */
    enum SpriteAlignment {
        Center = 0,
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 3,
        LeftCenter = 4,
        RightCenter = 5,
        BottomLeft = 6,
        BottomCenter = 7,
        BottomRight = 8,
        Custom = 9 
    }

    interface Renderer {

        /**
        * Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
        * @extension UnityEngine.RendererExtensions.UpdateGIMaterials
        */
        UpdateGIMaterials () : void
    }

    interface BillboardRenderer {

        /**
        * Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
        * @extension UnityEngine.RendererExtensions.UpdateGIMaterials
        */
        UpdateGIMaterials () : void
    }

    interface TrailRenderer {

        /**
        * Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
        * @extension UnityEngine.RendererExtensions.UpdateGIMaterials
        */
        UpdateGIMaterials () : void
    }

    interface LineRenderer {

        /**
        * Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
        * @extension UnityEngine.RendererExtensions.UpdateGIMaterials
        */
        UpdateGIMaterials () : void
    }

    interface SkinnedMeshRenderer {

        /**
        * Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
        * @extension UnityEngine.RendererExtensions.UpdateGIMaterials
        */
        UpdateGIMaterials () : void
    }

    interface MeshRenderer {

        /**
        * Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
        * @extension UnityEngine.RendererExtensions.UpdateGIMaterials
        */
        UpdateGIMaterials () : void
    }

    interface SpriteRenderer {

        /**
        * Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
        * @extension UnityEngine.RendererExtensions.UpdateGIMaterials
        */
        UpdateGIMaterials () : void
        /**
        * Stop using the deformable buffer to render the Sprite and use the original mesh instead.
        * @extension UnityEngine.U2D.SpriteRendererDataAccessExtensions.DeactivateDeformableBuffer
        */
        DeactivateDeformableBuffer () : void
    }

    interface Sprite {

        /**
        * Retrieves a strided accessor to the internal vertex attributes.
        * @returns A read-only list of.
        * @extension UnityEngine.U2D.SpriteDataAccessExtensions.GetVertexAttribute<T>
        */
        GetVertexAttribute<T> ($channel: UnityEngine_Rendering.VertexAttribute) : Unity_Collections.NativeSlice$1<T>
        /**
        * @extension UnityEngine.U2D.SpriteDataAccessExtensions.SetVertexAttribute<T>
        */
        SetVertexAttribute<T> ($channel: UnityEngine_Rendering.VertexAttribute, $src: Unity_Collections.NativeArray$1<T>) : void
        /**
        * Returns an array of BindPoses.
        * @param sprite The sprite to retrieve the bind pose from.
        * @returns A list of bind poses for this sprite. There is no need to dispose the returned NativeArray.
        * @extension UnityEngine.U2D.SpriteDataAccessExtensions.GetBindPoses
        */
        GetBindPoses () : Unity_Collections.NativeArray$1<Matrix4x4>
        /**
        * @extension UnityEngine.U2D.SpriteDataAccessExtensions.SetBindPoses
        */
        SetBindPoses ($src: Unity_Collections.NativeArray$1<Matrix4x4>) : void
        /**
        * Returns a list of indices. This is the same as Sprite.triangle.
        * @returns A read-only list of indices indicating how the triangles are formed between the vertices. The array is marked as undisposable.
        * @extension UnityEngine.U2D.SpriteDataAccessExtensions.GetIndices
        */
        GetIndices () : Unity_Collections.NativeArray$1<ushort>
        /**
        * @extension UnityEngine.U2D.SpriteDataAccessExtensions.SetIndices
        */
        SetIndices ($src: Unity_Collections.NativeArray$1<ushort>) : void
        /**
        * Returns a list of SpriteBone in this Sprite.
        * @param sprite The sprite to get the list of SpriteBone from.
        * @returns An array of SpriteBone that belongs to this Sprite.
        * @extension UnityEngine.U2D.SpriteDataAccessExtensions.GetBones
        */
        GetBones () : UnityEngine_U2D.SpriteBone[]
        /**
        * Sets the SpriteBones for this Sprite.
        * @extension UnityEngine.U2D.SpriteDataAccessExtensions.SetBones
        */
        SetBones ($src: UnityEngine_U2D.SpriteBone[]) : void
        /**
        * Checks if a specific channel exists for this Sprite.
        * @returns True if the channel exists.
        * @extension UnityEngine.U2D.SpriteDataAccessExtensions.HasVertexAttribute
        */
        HasVertexAttribute ($channel: UnityEngine_Rendering.VertexAttribute) : boolean
        /**
        * Sets the vertex count. This resizes the internal buffer. It also preserves any configurations of VertexAttributes.
        * @extension UnityEngine.U2D.SpriteDataAccessExtensions.SetVertexCount
        */
        SetVertexCount ($count: int) : void
        /**
        * Returns the number of vertices in this Sprite.
        * @extension UnityEngine.U2D.SpriteDataAccessExtensions.GetVertexCount
        */
        GetVertexCount () : int
    }

}

declare module 'Unity.Content' {
    import * as System from 'System'

    /**
    * Provides methods for categorizing content with labels.
    */
    class ContentNamespace extends System.ValueType {

        /**
        * Indicates whether the ContentNamespace still exists.
        */
        public get IsValid(): boolean;
        /**
        * Default ContentNamespace object.
        */
        public static get Default(): ContentNamespace;

        /**
        * Retrieves the name of the ContentNamespace.
        * @returns Returns the name of the ContentNamespace.
        */
        public GetName () : string
        /**
        * Destroys the specified ContentNamespace object.
        */
        public Delete () : void
        /**
        * Retrieves or creates the ContentNamespace if it doesn't exist.
        * @param name Name of the ContentNamespace. It must contain only alphanumeric characters and have a maximum length of 16 characters.
        * @returns Returns the specified ContentNamespace object.
        */
        public static GetOrCreateNamespace ($name: string) : ContentNamespace
        /**
        * Retrieves all existing ContentNamespace objects.
        * @returns Returns all existing ContentNamespace objects.
        */
        public static GetAll () : ContentNamespace[]
    }

}

declare module 'UnityEngine.SortingLayer' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'

    /**
    * Calls the methods in its invocation list when a sorting layer is added or removed.
    */
    interface LayerCallback {
        (layer: UnityEngine.SortingLayer) : void; 
        Invoke?: (layer: UnityEngine.SortingLayer) => void;
    }
    var LayerCallback: { new (func: (layer: UnityEngine.SortingLayer) => void): LayerCallback; }

}

declare module 'System.Runtime.Serialization' {

    interface ISerializable {

    }

    interface IDeserializationCallback {

    }

}

declare module 'System.Threading' {
    import * as System from 'System'

    interface CancellationToken {

    }

}

declare module 'UnityEngine.Application' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'

    /**
    * This is the delegate function when a mobile device notifies of low memory.
    */
    interface LowMemoryCallback {
        () : void; 
        Invoke?: () => void;
    }
    var LowMemoryCallback: { new (func: () => void): LowMemoryCallback; }

    /**
    * A delegate for the Application.memoryUsageChanged vent.
    */
    interface MemoryUsageChangedCallback {
        (usage: $Ref<UnityEngine.ApplicationMemoryUsageChange>) : void; 
        Invoke?: (usage: $Ref<UnityEngine.ApplicationMemoryUsageChange>) => void;
    }
    var MemoryUsageChangedCallback: { new (func: (usage: $Ref<UnityEngine.ApplicationMemoryUsageChange>) => void): MemoryUsageChangedCallback; }

    /**
    * Use this delegate type with Application.logMessageReceived or Application.logMessageReceivedThreaded to monitor what gets logged.
    */
    interface LogCallback {
        (condition: string, stackTrace: string, type: UnityEngine.LogType) : void; 
        Invoke?: (condition: string, stackTrace: string, type: UnityEngine.LogType) => void;
    }
    var LogCallback: { new (func: (condition: string, stackTrace: string, type: UnityEngine.LogType) => void): LogCallback; }

}

declare module 'UnityEngine.Events' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'
    import * as System_Reflection from 'System.Reflection'

    /**
    * Zero argument delegate used by UnityEvents.
    */
    interface UnityAction {
        () : void; 
        Invoke?: () => void;
    }
    var UnityAction: { new (func: () => void): UnityAction; }

    interface UnityAction$1<T0> {
        (arg0: T0) : void; 
        Invoke?: (arg0: T0) => void;
    }

    /**
    * The mode that a listener is operating in.
    */
    enum PersistentListenerMode {
        EventDefined = 0,
        Void = 1,
        Object = 2,
        Int = 3,
        Float = 4,
        String = 5,
        Bool = 6 
    }

    /**
    * Controls the scope of UnityEvent callbacks.
    */
    enum UnityEventCallState {
        Off = 0,
        EditorAndRuntime = 1,
        RuntimeOnly = 2 
    }

    /**
    * Abstract base class for UnityEvents.
    */
    class UnityEventBase extends System.Object implements UnityEngine.ISerializationCallbackReceiver {

        /**
        * Get the number of registered persistent listeners.
        */
        public GetPersistentEventCount () : int
        /**
        * Get the target component of the listener at index index.
        * @param index Index of the listener to query.
        */
        public GetPersistentTarget ($index: int) : UnityEngine.Object
        /**
        * Get the target method name of the listener at index index.
        * @param index Index of the listener to query.
        */
        public GetPersistentMethodName ($index: int) : string
        /**
        * Modify the execution state of a persistent listener.
        * @param index Index of the listener to query.
        * @param state State to set.
        */
        public SetPersistentListenerState ($index: int, $state: UnityEventCallState) : void
        /**
        * Returns the execution state of a persistent listener.
        * @param index Index of the listener to query.
        * @returns Execution state of the persistent listener.
        */
        public GetPersistentListenerState ($index: int) : UnityEventCallState
        /**
        * Remove all non-persistent (ie created from script) listeners  from the event.
        */
        public RemoveAllListeners () : void
        public ToString () : string
        /**
        * Given an object, function name, and a list of argument types; find the method that matches.
        * @param obj Object to search for the method.
        * @param functionName Function name to search for.
        * @param argumentTypes Argument types for the function.
        */
        public static GetValidMethodInfo ($obj: any, $functionName: string, $argumentTypes: System.Type[]) : System_Reflection.MethodInfo
        /**
        * Given an object type, function name, and a list of argument types; find the method that matches.
        * @param objectType Object type to search for the method.
        * @param functionName Function name to search for.
        * @param argumentTypes Argument types for the function.
        */
        public static GetValidMethodInfo ($objectType: System.Type, $functionName: string, $argumentTypes: System.Type[]) : System_Reflection.MethodInfo
    }

    /**
    * A zero argument persistent callback that can be saved with the Scene.
    */
    class UnityEvent extends UnityEventBase {

        /**
        * Constructor.
        */
        public constructor ()
        /**
        * Add a non persistent listener to the UnityEvent.
        * @param call Callback function.
        */
        public AddListener ($call: UnityAction) : void
        /**
        * Remove a non persistent listener from the UnityEvent. If you have added the same listener multiple times, this method will remove all occurrences of it.
        * @param call Callback function.
        */
        public RemoveListener ($call: UnityAction) : void
        /**
        * Invoke all registered callbacks (runtime and persistent).
        */
        public Invoke () : void
    }

    /**
    * One argument version of UnityEvent.
    */
    class UnityEvent$1<T0> extends UnityEventBase {

        public constructor ()
        public AddListener ($call: UnityAction$1<T0>) : void
        public RemoveListener ($call: UnityAction$1<T0>) : void
        public Invoke ($arg0: T0) : void
    }

    interface UnityAction$2<T0,T1> {
        (arg0: T0, arg1: T1) : void; 
        Invoke?: (arg0: T0, arg1: T1) => void;
    }

    /**
    * Two argument version of UnityEvent.
    */
    class UnityEvent$2<T0,T1> extends UnityEventBase {

        public constructor ()
        public AddListener ($call: UnityAction$2<T0, T1>) : void
        public RemoveListener ($call: UnityAction$2<T0, T1>) : void
        public Invoke ($arg0: T0, $arg1: T1) : void
    }

    interface UnityAction$3<T0,T1,T2> {
        (arg0: T0, arg1: T1, arg2: T2) : void; 
        Invoke?: (arg0: T0, arg1: T1, arg2: T2) => void;
    }

    /**
    * Three argument version of UnityEvent.
    */
    class UnityEvent$3<T0,T1,T2> extends UnityEventBase {

        public constructor ()
        public AddListener ($call: UnityAction$3<T0, T1, T2>) : void
        public RemoveListener ($call: UnityAction$3<T0, T1, T2>) : void
        public Invoke ($arg0: T0, $arg1: T1, $arg2: T2) : void
    }

    interface UnityAction$4<T0,T1,T2,T3> {
        (arg0: T0, arg1: T1, arg2: T2, arg3: T3) : void; 
        Invoke?: (arg0: T0, arg1: T1, arg2: T2, arg3: T3) => void;
    }

    /**
    * Four argument version of UnityEvent.
    */
    class UnityEvent$4<T0,T1,T2,T3> extends UnityEventBase {

        public constructor ()
        public AddListener ($call: UnityAction$4<T0, T1, T2, T3>) : void
        public RemoveListener ($call: UnityAction$4<T0, T1, T2, T3>) : void
        public Invoke ($arg0: T0, $arg1: T1, $arg2: T2, $arg3: T3) : void
    }

}

declare module 'System.Collections' {

    interface IEnumerator {

    }

    interface IEnumerable {

    }

    interface IList extends ICollection {

    }

    interface ICollection extends IEnumerable {

    }

    interface IDictionary extends ICollection {

    }

}

declare module 'UnityEngine.SceneManagement' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'
    import * as System_Collections_Generic from 'System.Collections.Generic'
    import * as Unity_Collections from 'Unity.Collections'
    import * as UnityEngine_Events from 'UnityEngine.Events'

    /**
    * Run-time data structure for *.unity file.
    */
    class Scene extends System.ValueType {

        public get handle(): int;
        /**
        * Returns the relative path of the Scene. For example: "AssetsMyScenesMyScene.unity".
        */
        public get path(): string;
        /**
        * Returns the name of the Scene that is currently active in the game or app.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * IsLoaded is set to true after loading has completed and objects have been enabled.
        */
        public get isLoaded(): boolean;
        /**
        * Return the index of the Scene in the Build Settings.
        */
        public get buildIndex(): int;
        /**
        * Returns true if the Scene is modified.
        */
        public get isDirty(): boolean;
        /**
        * The number of root transforms of this Scene.
        */
        public get rootCount(): int;
        public get isSubScene(): boolean;
        public set isSubScene(value: boolean);

        /**
        * Whether this is a valid Scene.
        * A Scene may be invalid if, for example, you tried to open a Scene that does not exist. In this case, the Scene returned from EditorSceneManager.OpenScene would return False for IsValid.
        * @returns Whether this is a valid Scene.
        */
        public IsValid () : boolean
        /**
        * Returns all the root game objects in the Scene.
        * @returns An array of game objects.
        */
        public GetRootGameObjects () : UnityEngine.GameObject[]
        public GetRootGameObjects ($rootGameObjects: System_Collections_Generic.List$1<UnityEngine.GameObject>) : void
        public GetHashCode () : int
        public Equals ($other: any) : boolean
        public static op_Equality ($lhs: Scene, $rhs: Scene) : boolean
        public static op_Inequality ($lhs: Scene, $rhs: Scene) : boolean
    }

    /**
    * Scene management at run-time.
    */
    class SceneManager extends System.Object {

        /**
        * The current number of Scenes.
        */
        public static get sceneCount(): int;
        /**
        * The number of loaded Scenes.
        */
        public static get loadedSceneCount(): int;
        /**
        * Number of Scenes in Build Settings.
        */
        public static get sceneCountInBuildSettings(): int;

        public constructor ()
        /**
        * Gets the currently active Scene.
        * @returns The active Scene.
        */
        public static GetActiveScene () : Scene
        /**
        * Set the Scene to be active.
        * @param scene The Scene to be set.
        * @returns Returns false if the Scene is not loaded yet.
        */
        public static SetActiveScene ($scene: Scene) : boolean
        /**
        * Searches all Scenes loaded for a Scene that has the given asset path.
        * @param scenePath Path of the Scene. Should be relative to the project folder. Like: "AssetsMyScenesMyScene.unity".
        * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned.
        */
        public static GetSceneByPath ($scenePath: string) : Scene
        /**
        * Searches through the Scenes loaded for a Scene with the given name.
        * @param name Name of Scene to find.
        * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned.
        */
        public static GetSceneByName ($name: string) : Scene
        /**
        * Get a Scene struct from a build index.
        * @param buildIndex Build index as shown in the Build Settings window.
        * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned.
        */
        public static GetSceneByBuildIndex ($buildIndex: int) : Scene
        /**
        * Get the Scene at index in the SceneManager's list of loaded Scenes.
        * @param index Index of the Scene to get. Index must be greater than or equal to 0 and less than SceneManager.sceneCount.
        * @returns A reference to the Scene at the index specified.
        */
        public static GetSceneAt ($index: int) : Scene
        /**
        * Create an empty new Scene at runtime with the given name.
        * @param sceneName The name of the new Scene. It cannot be empty or null, or same as the name of the existing Scenes.
        * @param parameters Various parameters used to create the Scene.
        * @returns A reference to the new Scene that was created, or an invalid Scene if creation failed.
        */
        public static CreateScene ($sceneName: string, $parameters: CreateSceneParameters) : Scene
        /**
        * This will merge the source Scene into the destinationScene.
        * @param sourceScene The Scene that will be merged into the destination Scene.
        * @param destinationScene Existing Scene to merge the source Scene into.
        */
        public static MergeScenes ($sourceScene: Scene, $destinationScene: Scene) : void
        /**
        * Move a GameObject from its current Scene to a new Scene.
        * @param go GameObject to move.
        * @param scene Scene to move into.
        */
        public static MoveGameObjectToScene ($go: UnityEngine.GameObject, $scene: Scene) : void
        public static MoveGameObjectsToScene ($instanceIDs: Unity_Collections.NativeArray$1<int>, $scene: Scene) : void
        /**
        * Create an empty new Scene at runtime with the given name.
        * @param sceneName The name of the new Scene. It cannot be empty or null, or same as the name of the existing Scenes.
        * @param parameters Various parameters used to create the Scene.
        * @returns A reference to the new Scene that was created, or an invalid Scene if creation failed.
        */
        public static CreateScene ($sceneName: string) : Scene
        /**
        * Loads the Scene by its name or index in Build Settings.
        * @param sceneName Name or path of the Scene to load.
        * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
        * @param mode Allows you to specify whether or not to load the Scene additively. See SceneManagement.LoadSceneMode for more information about the options.
        */
        public static LoadScene ($sceneName: string, $mode: LoadSceneMode) : void
        public static LoadScene ($sceneName: string) : void
        /**
        * Loads the Scene by its name or index in Build Settings.
        * @param sceneName Name or path of the Scene to load.
        * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
        * @param parameters Various parameters used to load the Scene.
        * @returns A handle to the Scene being loaded.
        */
        public static LoadScene ($sceneName: string, $parameters: LoadSceneParameters) : Scene
        /**
        * Loads the Scene by its name or index in Build Settings.
        * @param sceneName Name or path of the Scene to load.
        * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
        * @param mode Allows you to specify whether or not to load the Scene additively. See SceneManagement.LoadSceneMode for more information about the options.
        * @methodSwap LoadScene_EBB7509C_BD68C065
        */
        public static LoadScene ($sceneBuildIndex: int, $mode: LoadSceneMode) : void
        /**
        * @methodSwap LoadScene_EBB7509C_F92D023A
        */
        public static LoadScene ($sceneBuildIndex: int) : void
        /**
        * Loads the Scene by its name or index in Build Settings.
        * @param sceneName Name or path of the Scene to load.
        * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
        * @param parameters Various parameters used to load the Scene.
        * @returns A handle to the Scene being loaded.
        * @methodSwap LoadScene_EBB7509C_H631D9DFE
        */
        public static LoadScene ($sceneBuildIndex: int, $parameters: LoadSceneParameters) : Scene
        /**
        * Loads the Scene asynchronously in the background.
        * @param sceneName Name or path of the Scene to load.
        * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
        * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
        * @param parameters Struct that collects the various parameters into a single place except for the name and index.
        * @returns Use the AsyncOperation to determine if the operation has completed.
        * @methodSwap LoadSceneAsync_EBB7509C_BD68C065
        */
        public static LoadSceneAsync ($sceneBuildIndex: int, $mode: LoadSceneMode) : UnityEngine.AsyncOperation
        /**
        * @methodSwap LoadSceneAsync_EBB7509C_F92D023A
        */
        public static LoadSceneAsync ($sceneBuildIndex: int) : UnityEngine.AsyncOperation
        /**
        * Loads the Scene asynchronously in the background.
        * @param sceneName Name or path of the Scene to load.
        * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
        * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
        * @param parameters Struct that collects the various parameters into a single place except for the name and index.
        * @returns Use the AsyncOperation to determine if the operation has completed.
        * @methodSwap LoadSceneAsync_EBB7509C_H631D9DFE
        */
        public static LoadSceneAsync ($sceneBuildIndex: int, $parameters: LoadSceneParameters) : UnityEngine.AsyncOperation
        /**
        * Loads the Scene asynchronously in the background.
        * @param sceneName Name or path of the Scene to load.
        * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
        * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
        * @param parameters Struct that collects the various parameters into a single place except for the name and index.
        * @returns Use the AsyncOperation to determine if the operation has completed.
        */
        public static LoadSceneAsync ($sceneName: string, $mode: LoadSceneMode) : UnityEngine.AsyncOperation
        public static LoadSceneAsync ($sceneName: string) : UnityEngine.AsyncOperation
        /**
        * Loads the Scene asynchronously in the background.
        * @param sceneName Name or path of the Scene to load.
        * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
        * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
        * @param parameters Struct that collects the various parameters into a single place except for the name and index.
        * @returns Use the AsyncOperation to determine if the operation has completed.
        */
        public static LoadSceneAsync ($sceneName: string, $parameters: LoadSceneParameters) : UnityEngine.AsyncOperation
        /**
        * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
        * @param sceneBuildIndex Index of the Scene in BuildSettings.
        * @param sceneName Name or path of the Scene to unload.
        * @param scene Scene to unload.
        * @param options Scene unloading options.
        * @returns Use the AsyncOperation to determine if the operation has completed.
        * @methodSwap UnloadSceneAsync_EBB7509C_F92D023A
        */
        public static UnloadSceneAsync ($sceneBuildIndex: int) : UnityEngine.AsyncOperation
        /**
        * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
        * @param sceneBuildIndex Index of the Scene in BuildSettings.
        * @param sceneName Name or path of the Scene to unload.
        * @param scene Scene to unload.
        * @param options Scene unloading options.
        * @returns Use the AsyncOperation to determine if the operation has completed.
        */
        public static UnloadSceneAsync ($sceneName: string) : UnityEngine.AsyncOperation
        /**
        * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
        * @param sceneBuildIndex Index of the Scene in BuildSettings.
        * @param sceneName Name or path of the Scene to unload.
        * @param scene Scene to unload.
        * @param options Scene unloading options.
        * @returns Use the AsyncOperation to determine if the operation has completed.
        */
        public static UnloadSceneAsync ($scene: Scene) : UnityEngine.AsyncOperation
        /**
        * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
        * @param sceneBuildIndex Index of the Scene in BuildSettings.
        * @param sceneName Name or path of the Scene to unload.
        * @param scene Scene to unload.
        * @param options Scene unloading options.
        * @returns Use the AsyncOperation to determine if the operation has completed.
        * @methodSwap UnloadSceneAsync_EBB7509C_H13E0B5B
        */
        public static UnloadSceneAsync ($sceneBuildIndex: int, $options: UnloadSceneOptions) : UnityEngine.AsyncOperation
        /**
        * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
        * @param sceneBuildIndex Index of the Scene in BuildSettings.
        * @param sceneName Name or path of the Scene to unload.
        * @param scene Scene to unload.
        * @param options Scene unloading options.
        * @returns Use the AsyncOperation to determine if the operation has completed.
        */
        public static UnloadSceneAsync ($sceneName: string, $options: UnloadSceneOptions) : UnityEngine.AsyncOperation
        /**
        * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
        * @param sceneBuildIndex Index of the Scene in BuildSettings.
        * @param sceneName Name or path of the Scene to unload.
        * @param scene Scene to unload.
        * @param options Scene unloading options.
        * @returns Use the AsyncOperation to determine if the operation has completed.
        */
        public static UnloadSceneAsync ($scene: Scene, $options: UnloadSceneOptions) : UnityEngine.AsyncOperation
        public static add_sceneLoaded ($value: UnityEngine_Events.UnityAction$2<Scene, LoadSceneMode>) : void
        public static add_sceneUnloaded ($value: UnityEngine_Events.UnityAction$1<Scene>) : void
        public static add_activeSceneChanged ($value: UnityEngine_Events.UnityAction$2<Scene, Scene>) : void
        public static remove_sceneLoaded ($value: UnityEngine_Events.UnityAction$2<Scene, LoadSceneMode>) : void
        public static remove_sceneUnloaded ($value: UnityEngine_Events.UnityAction$1<Scene>) : void
        public static remove_activeSceneChanged ($value: UnityEngine_Events.UnityAction$2<Scene, Scene>) : void
    }

    /**
    * This struct collects all the CreateScene parameters in to a single place.
    */
    class CreateSceneParameters extends System.ValueType {

        /**
        * See SceneManagement.LocalPhysicsMode.
        */
        public get localPhysicsMode(): LocalPhysicsMode;
        public set localPhysicsMode(value: LocalPhysicsMode);

        public constructor ($physicsMode: LocalPhysicsMode)
    }

    /**
    * Provides options for 2D and 3D local physics.
    */
    enum LocalPhysicsMode {
        None = 0,
        Physics2D = 1,
        Physics3D = 2 
    }

    /**
    * Used when loading a Scene in a player.
    */
    enum LoadSceneMode {
        Single = 0,
        Additive = 1 
    }

    /**
    * This struct collects all the LoadScene parameters in to a single place.
    */
    class LoadSceneParameters extends System.ValueType {

        /**
        * See LoadSceneMode.
        */
        public get loadSceneMode(): LoadSceneMode;
        public set loadSceneMode(value: LoadSceneMode);
        /**
        * See SceneManagement.LocalPhysicsMode.
        */
        public get localPhysicsMode(): LocalPhysicsMode;
        public set localPhysicsMode(value: LocalPhysicsMode);

        /**
        * Constructor for LoadSceneParameters. See SceneManager.LoadScene.
        * @param mode See LoadSceneParameters.loadSceneMode.
        */
        public constructor ($mode: LoadSceneMode)
        public constructor ($mode: LoadSceneMode, $physicsMode: LocalPhysicsMode)
    }

    /**
    * Scene unloading options passed to SceneManager.UnloadScene.
    */
    enum UnloadSceneOptions {
        None = 0,
        UnloadAllEmbeddedSceneObjects = 1 
    }

}

declare module 'System.Reflection' {
    import * as System from 'System'
    import * as System_Runtime_InteropServices from 'System.Runtime.InteropServices'

    interface IReflect {

    }

    interface MemberInfo extends ICustomAttributeProvider, System_Runtime_InteropServices._MemberInfo {

    }

    interface ICustomAttributeProvider {

    }

    interface MethodInfo extends System_Runtime_InteropServices._MethodInfo {

    }

    interface MethodBase extends System_Runtime_InteropServices._MethodBase {

    }

}

declare module 'System.Runtime.InteropServices' {

    interface _Type {

    }

    interface _MemberInfo {

    }

    interface _Exception {

    }

    interface _MethodInfo {

    }

    interface _MethodBase {

    }

}

declare module 'System.Collections.Generic' {
    import * as System from 'System'
    import * as System_Collections from 'System.Collections'
    import * as System_Runtime_Serialization from 'System.Runtime.Serialization'

    interface List$1<T> extends IList$1<T>, System_Collections.IList, IReadOnlyList$1<T> {

    }

    interface IList$1<T> extends ICollection$1<T> {

    }

    interface ICollection$1<T> extends IEnumerable$1<T> {

    }

    interface IEnumerable$1<T> extends System_Collections.IEnumerable {

        GetEnumerator? () : IEnumerator$1<T>
    }

    interface IEnumerator$1<T> extends System_Collections.IEnumerator, System.IDisposable {

        readonly Current? : T

    }

    interface IReadOnlyList$1<T> extends IReadOnlyCollection$1<T> {

    }

    interface IReadOnlyCollection$1<T> extends IEnumerable$1<T> {

    }

    interface HashSet$1<T> extends ISet$1<T>, System_Runtime_Serialization.IDeserializationCallback, System_Runtime_Serialization.ISerializable, IReadOnlyCollection$1<T> {

    }

    interface ISet$1<T> extends ICollection$1<T> {

    }

    interface Dictionary$2<TKey,TValue> extends IDictionary$2<TKey,TValue>, System_Collections.IDictionary, System_Runtime_Serialization.IDeserializationCallback, System_Runtime_Serialization.ISerializable, IReadOnlyDictionary$2<TKey,TValue> {

    }

    interface IDictionary$2<TKey,TValue> extends ICollection$1<KeyValuePair$2<TKey, TValue>> {

    }

    interface KeyValuePair$2<TKey,TValue> {

    }

    interface IReadOnlyDictionary$2<TKey,TValue> extends IReadOnlyCollection$1<KeyValuePair$2<TKey, TValue>> {

    }

    interface IEqualityComparer$1<T> {

        Equals? ($x: T, $y: T) : boolean
        GetHashCode? ($obj: T) : int
    }

}

declare module 'Unity.Collections' {
    import * as System from 'System'
    import * as System_Collections_Generic from 'System.Collections.Generic'

    /**
    * A NativeArray exposes a buffer of native memory to managed code, making it possible to share data between managed and native without marshalling costs.
    */
    interface NativeArray$1<T> extends System_Collections_Generic.IEnumerable$1<T>, System.IDisposable, System.IEquatable$1<NativeArray$1<T>> {

    }

    /**
    * Native Slice.
    */
    interface NativeSlice$1<T> extends System_Collections_Generic.IEnumerable$1<T>, System.IEquatable$1<NativeSlice$1<T>> {

    }

    /**
    * Used to specify allocation type for NativeArray.
    */
    enum Allocator {
        Invalid = 0,
        None = 1,
        Temp = 2,
        TempJob = 3,
        Persistent = 4,
        AudioKernel = 5,
        FirstUserIndex = 64 
    }

}

declare module 'UnityEngine.Rendering' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'
    import * as UnityEngine_Experimental_Rendering from 'UnityEngine.Experimental.Rendering'
    import * as Unity_Collections from 'Unity.Collections'
    import * as UnityEngine_Profiling from 'UnityEngine.Profiling'
    import * as Unity_Profiling from 'Unity.Profiling'
    import * as System_Collections_Generic from 'System.Collections.Generic'
    import * as UnityEngine_Rendering_SplashScreen from 'UnityEngine.Rendering.SplashScreen'
    import * as UnityEngine_Rendering_RendererUtils from 'UnityEngine.Rendering.RendererUtils'
    import * as UnityEngine_Rendering_SupportedRenderingFeatures from 'UnityEngine.Rendering.SupportedRenderingFeatures'
    import * as UnityEngine_Rendering_BatchRendererGroup from 'UnityEngine.Rendering.BatchRendererGroup'

    /**
    * Represents a global shader keyword.
    */
    class GlobalKeyword extends System.ValueType {

        /**
        * The name of the shader keyword. (Read Only)
        */
        public get name(): string;

        /**
        * Creates and returns a GlobalKeyword struct that represents an existing global shader keyword.
        * @param name The name of the global shader keyword.
        */
        public constructor ($name: string)
        /**
        * Creates and returns a Rendering.GlobalKeyword that represents a new or existing global shader keyword.
        * @param name The name of the global shader keyword.
        * @returns Returns a new instance of the GlobalKeyword class.
        */
        public static Create ($name: string) : GlobalKeyword
        public ToString () : string
    }

    /**
    * Shader tag ids are used to refer to various names in shaders.
    */
    class ShaderTagId extends System.ValueType implements System.IEquatable$1<ShaderTagId> {

        /**
        * Describes a shader tag id not referring to any name.
        */
        public static none : ShaderTagId
        /**
        * Gets the name of the tag referred to by the shader tag id.
        */
        public get name(): string;

        /**
        * Gets or creates a shader tag id representing the given name.
        * @param name The name to represent with the shader tag id.
        */
        public constructor ($name: string)
        public Equals ($obj: any) : boolean
        public Equals ($other: ShaderTagId) : boolean
        public GetHashCode () : int
        public static op_Equality ($tag1: ShaderTagId, $tag2: ShaderTagId) : boolean
        public static op_Inequality ($tag1: ShaderTagId, $tag2: ShaderTagId) : boolean
        public static op_Explicit ($name: string) : ShaderTagId
        public static op_Explicit ($tagId: ShaderTagId) : string
    }

    /**
    * Texture "dimension" (type).
    */
    enum TextureDimension {
        Unknown = -1,
        None = 0,
        Any = 1,
        Tex2D = 2,
        Tex3D = 3,
        Cube = 4,
        Tex2DArray = 5,
        CubeArray = 6 
    }

    /**
    * Used by CommandBuffer.SetShadowSamplingMode.
    */
    enum ShadowSamplingMode {
        CompareDepths = 0,
        RawDepth = 1,
        None = 2 
    }

    /**
    * Types of data that you can encapsulate within a render texture.
    */
    enum RenderTextureSubElement {
        Color = 0,
        Depth = 1,
        Stencil = 2,
        Default = 3 
    }

    /**
    * Type of a given shader property.
    */
    enum ShaderPropertyType {
        Color = 0,
        Vector = 1,
        Float = 2,
        Range = 3,
        Texture = 4,
        Int = 5 
    }

    /**
    * Flags that control how a shader property behaves.
    */
    enum ShaderPropertyFlags {
        None = 0,
        HideInInspector = 1,
        PerRendererData = 2,
        NoScaleOffset = 4,
        Normal = 8,
        HDR = 16,
        Gamma = 32,
        NonModifiableTextureData = 64,
        MainTexture = 128,
        MainColor = 256 
    }

    /**
    * Represents the local keyword space of a Shader or ComputeShader.
    */
    class LocalKeywordSpace extends System.ValueType implements System.IEquatable$1<LocalKeywordSpace> {

        /**
        * An array containing all Rendering.LocalKeyword structs in this local keyword space. (Read Only)
        */
        public get keywords(): LocalKeyword[];
        /**
        * An array containing the names of all local shader keywords in this local keyword space. (Read Only)
        */
        public get keywordNames(): string[];
        /**
        * The number of local shader keywords in this local keyword space. (Read Only)
        */
        public get keywordCount(): uint;

        /**
        * Searches for a local shader keyword with a given name in the keyword space.
        * @param name The name of the shader keyword to search for.
        * @returns Returns a valid Rendering.LocalKeyword if it's present in the keyword space. Otherwise, returns an invalid Rendering.LocalKeyword.
        */
        public FindKeyword ($name: string) : LocalKeyword
        public Equals ($o: any) : boolean
        public Equals ($rhs: LocalKeywordSpace) : boolean
        public GetHashCode () : int
        public static op_Equality ($lhs: LocalKeywordSpace, $rhs: LocalKeywordSpace) : boolean
        public static op_Inequality ($lhs: LocalKeywordSpace, $rhs: LocalKeywordSpace) : boolean
    }

    /**
    * Represents a shader keyword declared in a shader source file.
    */
    class LocalKeyword extends System.ValueType implements System.IEquatable$1<LocalKeyword> {

        /**
        * The name of the shader keyword (Read Only).
        */
        public get name(): string;
        /**
        * Specifies whether this local shader keyword is used for dynamic branching (Read Only).
        */
        public get isDynamic(): boolean;
        /**
        * Whether this local shader keyword can be overridden by a global shader keyword. (Read Only).
        */
        public get isOverridable(): boolean;
        /**
        * Specifies whether this local shader keyword is valid (Read Only).
        */
        public get isValid(): boolean;
        /**
        * The type of the shader keyword (Read Only).
        */
        public get type(): ShaderKeywordType;

        /**
        * Initializes and returns a LocalKeyword struct that represents an existing local shader keyword for a given Shader.
        * @param shader The Shader to use.
        * @param name The name of the local shader keyword.
        */
        public constructor ($shader: UnityEngine.Shader, $name: string)
        /**
        * Initializes and returns a LocalKeyword struct that represents an existing local shader keyword for a given ComputeShader.
        * @param shader The ComputeShader to use.
        * @param name The name of the local shader keyword.
        */
        public constructor ($shader: UnityEngine.ComputeShader, $name: string)
        public ToString () : string
        public Equals ($o: any) : boolean
        public Equals ($rhs: LocalKeyword) : boolean
        public GetHashCode () : int
        public static op_Equality ($lhs: LocalKeyword, $rhs: LocalKeyword) : boolean
        public static op_Inequality ($lhs: LocalKeyword, $rhs: LocalKeyword) : boolean
    }

    /**
    * Type of a shader keyword, eg: built-in or user defined.
    */
    enum ShaderKeywordType {
        None = 0,
        BuiltinDefault = 2,
        BuiltinExtra = 6,
        BuiltinAutoStripped = 10,
        UserDefined = 16,
        Plugin = 32 
    }

    /**
    * Defines a place in camera's rendering to attach Rendering.CommandBuffer objects to.
    */
    enum CameraEvent {
        BeforeDepthTexture = 0,
        AfterDepthTexture = 1,
        BeforeDepthNormalsTexture = 2,
        AfterDepthNormalsTexture = 3,
        BeforeGBuffer = 4,
        AfterGBuffer = 5,
        BeforeLighting = 6,
        AfterLighting = 7,
        BeforeFinalPass = 8,
        AfterFinalPass = 9,
        BeforeForwardOpaque = 10,
        AfterForwardOpaque = 11,
        BeforeImageEffectsOpaque = 12,
        AfterImageEffectsOpaque = 13,
        BeforeSkybox = 14,
        AfterSkybox = 15,
        BeforeForwardAlpha = 16,
        AfterForwardAlpha = 17,
        BeforeImageEffects = 18,
        AfterImageEffects = 19,
        AfterEverything = 20,
        BeforeReflections = 21,
        AfterReflections = 22,
        BeforeHaloAndLensFlares = 23,
        AfterHaloAndLensFlares = 24 
    }

    /**
    * List of graphics commands to execute.
    */
    class CommandBuffer extends System.Object implements System.IDisposable {

        /**
        * Name of this command buffer.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Size of this command buffer in bytes (Read Only).
        */
        public get sizeInBytes(): int;

        /**
        * Create a new empty command buffer.
        */
        public constructor ()
        /**
        * Adds a command to copy the pixel data from one texture, convert the data into a different format, and copy it into another texture.
        * @param src The source texture. The texture must be a Texture2D or Cubemap.
        * @param dst The destination texture. The texture must be a Texture2D, Texture2DArray, Cubemap, or CubemapArray. The texture must also be uncompressed and correspond to a supported RenderTextureFormat.
        * @param srcElement The element in the source texture to copy from. Use CubemapFace if src is a Cubemap. Set the value to 0 if src is a 2D texture.
        * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
        */
        public ConvertTexture ($src: RenderTargetIdentifier, $dst: RenderTargetIdentifier) : void
        /**
        * Adds a command to copy the pixel data from one texture, convert the data into a different format, and copy it into another texture.
        * @param src The source texture. The texture must be a Texture2D or Cubemap.
        * @param dst The destination texture. The texture must be a Texture2D, Texture2DArray, Cubemap, or CubemapArray. The texture must also be uncompressed and correspond to a supported RenderTextureFormat.
        * @param srcElement The element in the source texture to copy from. Use CubemapFace if src is a Cubemap. Set the value to 0 if src is a 2D texture.
        * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
        * @methodSwap ConvertTexture_EBB7509C_H669624B1
        */
        public ConvertTexture ($src: RenderTargetIdentifier, $srcElement: int, $dst: RenderTargetIdentifier, $dstElement: int) : void
        /**
        * Adds an "AsyncGPUReadback.WaitAllRequests" command to the CommandBuffer.
        */
        public WaitAllAsyncReadbackRequests () : void
        public RequestAsyncReadback ($src: UnityEngine.ComputeBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        public RequestAsyncReadback ($src: UnityEngine.GraphicsBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadback_EBB7509C_H4A868EE8
        */
        public RequestAsyncReadback ($src: UnityEngine.ComputeBuffer, $size: int, $offset: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadback_EBB7509C_CE3A6FB8
        */
        public RequestAsyncReadback ($src: UnityEngine.GraphicsBuffer, $size: int, $offset: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        public RequestAsyncReadback ($src: UnityEngine.Texture, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadback_EBB7509C_C82D0C57
        */
        public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadback_EBB7509C_CE39E4C6
        */
        public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadback_EBB7509C_H3E2402CA
        */
        public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadback_EBB7509C_H2F409B83
        */
        public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadback_EBB7509C_H8D139492
        */
        public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadback_EBB7509C_H1F0FE80E
        */
        public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        public RequestAsyncReadbackIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeArray_EBB7509C_E4BD98D6
        */
        public RequestAsyncReadbackIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $size: int, $offset: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        public RequestAsyncReadbackIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeArray_EBB7509C_H8229894A
        */
        public RequestAsyncReadbackIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: int, $offset: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        public RequestAsyncReadbackIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeArray_EBB7509C_BA105A91
        */
        public RequestAsyncReadbackIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeArray_EBB7509C_D36A53F0
        */
        public RequestAsyncReadbackIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeArray_EBB7509C_B801095C
        */
        public RequestAsyncReadbackIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeArray_EBB7509C_H5A840655
        */
        public RequestAsyncReadbackIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeArray_EBB7509C_H464F73E4
        */
        public RequestAsyncReadbackIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeArray_EBB7509C_F8D9598
        */
        public RequestAsyncReadbackIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        public RequestAsyncReadbackIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeSlice_EBB7509C_B02C9F97
        */
        public RequestAsyncReadbackIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $size: int, $offset: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        public RequestAsyncReadbackIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeSlice_EBB7509C_H8CC87C79
        */
        public RequestAsyncReadbackIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: int, $offset: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        public RequestAsyncReadbackIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeSlice_EBB7509C_BF4CE790
        */
        public RequestAsyncReadbackIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeSlice_EBB7509C_H29B0E39B
        */
        public RequestAsyncReadbackIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeSlice_EBB7509C_H11CE4207
        */
        public RequestAsyncReadbackIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeSlice_EBB7509C_H50DB90E4
        */
        public RequestAsyncReadbackIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeSlice_EBB7509C_H123FE0F
        */
        public RequestAsyncReadbackIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * @methodSwap RequestAsyncReadbackIntoNativeSlice_EBB7509C_H4D718EA3
        */
        public RequestAsyncReadbackIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>) : void
        /**
        * Add a "set invert culling" command to the buffer.
        * @param invertCulling A boolean indicating whether to invert the backface culling (true) or not (false).
        */
        public SetInvertCulling ($invertCulling: boolean) : void
        /**
        * Adds a command to set a float parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetComputeFloatParam_EBB7509C_EC1DC6F2
        */
        public SetComputeFloatParam ($computeShader: UnityEngine.ComputeShader, $nameID: int, $val: float) : void
        /**
        * Adds a command to set an integer parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetComputeIntParam_EBB7509C_H56DF7F6
        */
        public SetComputeIntParam ($computeShader: UnityEngine.ComputeShader, $nameID: int, $val: int) : void
        /**
        * Adds a command to set a vector parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetComputeVectorParam_EBB7509C_H63B040A3
        */
        public SetComputeVectorParam ($computeShader: UnityEngine.ComputeShader, $nameID: int, $val: UnityEngine.Vector4) : void
        /**
        * Adds a command to set a vector array parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Property name.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Value to set.
        * @methodSwap SetComputeVectorArrayParam_EBB7509C_H130856F
        */
        public SetComputeVectorArrayParam ($computeShader: UnityEngine.ComputeShader, $nameID: int, $values: UnityEngine.Vector4[]) : void
        /**
        * Adds a command to set a matrix parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetComputeMatrixParam_EBB7509C_H266A5651
        */
        public SetComputeMatrixParam ($computeShader: UnityEngine.ComputeShader, $nameID: int, $val: UnityEngine.Matrix4x4) : void
        /**
        * Adds a command to set a matrix array parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Value to set.
        * @methodSwap SetComputeMatrixArrayParam_EBB7509C_BBB24859
        */
        public SetComputeMatrixArrayParam ($computeShader: UnityEngine.ComputeShader, $nameID: int, $values: UnityEngine.Matrix4x4[]) : void
        /**
        * Adds a command to select which Shader Pass to use when executing ray/geometry intersection shaders.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param passName The Shader Pass to use when executing ray tracing shaders.
        */
        public SetRayTracingShaderPass ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $passName: string) : void
        /**
        * Clear all commands in the buffer.
        */
        public Clear () : void
        /**
        * Clear random write targets for level pixel shaders.
        */
        public ClearRandomWriteTargets () : void
        /**
        * Add a command to set the rendering viewport.
        * @param pixelRect Viewport rectangle in pixel coordinates.
        */
        public SetViewport ($pixelRect: UnityEngine.Rect) : void
        /**
        * Add a command to enable the hardware scissor rectangle.
        * @param scissor Viewport rectangle in pixel coordinates.
        */
        public EnableScissorRect ($scissor: UnityEngine.Rect) : void
        /**
        * Add a command to disable the hardware scissor rectangle.
        */
        public DisableScissorRect () : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_DB90D7C7
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: int, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless, $useDynamicScale: boolean) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_H8972FAEC
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: int, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_EF3CDA38
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: int, $enableRandomWrite: boolean) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_H92F6E67
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: int) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_H68A44F0C
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_C561AA74
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: int, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless, $useDynamicScale: boolean) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_E6CBC793
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: int, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless) : void
        /**
        * Add a "get a temporary render texture" command.
        * @param nameID Shader property name for this texture.
        * @param width Width in pixels, or -1 for "camera pixel width".
        * @param height Height in pixels, or -1 for "camera pixel height".
        * @param depthBuffer Depth buffer bits (0, 16 or 24).
        * @param filter Texture filtering mode (default is Point).
        * @param format Format of the render texture (default is ARGB32).
        * @param readWrite Color space conversion mode.
        * @param antiAliasing Anti-aliasing (default is no anti-aliasing).
        * @param enableRandomWrite Should random-write access into the texture be enabled (default is false).
        * @param desc Use this RenderTextureDescriptor for the settings when creating the temporary RenderTexture.
        * @param memorylessMode Render texture memoryless mode.
        * @methodSwap GetTemporaryRT_EBB7509C_H6AC19C61
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: int, $enableRandomWrite: boolean) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_BD7142E2
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: int) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_H9AF96179
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_H51E68190
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_H9967EB8F
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int, $filter: UnityEngine.FilterMode) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_H7CC42739
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int, $depthBuffer: int) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_H71E348A6
        */
        public GetTemporaryRT ($nameID: int, $width: int, $height: int) : void
        /**
        * Add a "get a temporary render texture" command.
        * @param nameID Shader property name for this texture.
        * @param width Width in pixels, or -1 for "camera pixel width".
        * @param height Height in pixels, or -1 for "camera pixel height".
        * @param depthBuffer Depth buffer bits (0, 16 or 24).
        * @param filter Texture filtering mode (default is Point).
        * @param format Format of the render texture (default is ARGB32).
        * @param readWrite Color space conversion mode.
        * @param antiAliasing Anti-aliasing (default is no anti-aliasing).
        * @param enableRandomWrite Should random-write access into the texture be enabled (default is false).
        * @param desc Use this RenderTextureDescriptor for the settings when creating the temporary RenderTexture.
        * @param memorylessMode Render texture memoryless mode.
        * @methodSwap GetTemporaryRT_EBB7509C_EE05DF
        */
        public GetTemporaryRT ($nameID: int, $desc: UnityEngine.RenderTextureDescriptor, $filter: UnityEngine.FilterMode) : void
        /**
        * @methodSwap GetTemporaryRT_EBB7509C_D549CFA9
        */
        public GetTemporaryRT ($nameID: int, $desc: UnityEngine.RenderTextureDescriptor) : void
        /**
        * @methodSwap GetTemporaryRTArray_EBB7509C_F0C36B46
        */
        public GetTemporaryRTArray ($nameID: int, $width: int, $height: int, $slices: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: int, $enableRandomWrite: boolean, $useDynamicScale: boolean) : void
        /**
        * @methodSwap GetTemporaryRTArray_EBB7509C_H8FE2B1D9
        */
        public GetTemporaryRTArray ($nameID: int, $width: int, $height: int, $slices: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: int, $enableRandomWrite: boolean) : void
        /**
        * @methodSwap GetTemporaryRTArray_EBB7509C_H24054F7A
        */
        public GetTemporaryRTArray ($nameID: int, $width: int, $height: int, $slices: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: int) : void
        /**
        * @methodSwap GetTemporaryRTArray_EBB7509C_H2D48B631
        */
        public GetTemporaryRTArray ($nameID: int, $width: int, $height: int, $slices: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat) : void
        /**
        * Add a "get a temporary render texture array" command.
        * @param nameID Shader property name for this texture.
        * @param width Width in pixels, or -1 for "camera pixel width".
        * @param height Height in pixels, or -1 for "camera pixel height".
        * @param slices Number of slices in texture array.
        * @param depthBuffer Depth buffer bits (0, 16 or 24).
        * @param filter Texture filtering mode (default is Point).
        * @param format Format of the render texture (default is ARGB32).
        * @param readWrite Color space conversion mode.
        * @param antiAliasing Anti-aliasing (default is no anti-aliasing).
        * @param enableRandomWrite Should random-write access into the texture be enabled (default is false).
        * @methodSwap GetTemporaryRTArray_EBB7509C_F6E26E24
        */
        public GetTemporaryRTArray ($nameID: int, $width: int, $height: int, $slices: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: int, $enableRandomWrite: boolean) : void
        /**
        * @methodSwap GetTemporaryRTArray_EBB7509C_F7026B43
        */
        public GetTemporaryRTArray ($nameID: int, $width: int, $height: int, $slices: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: int) : void
        /**
        * @methodSwap GetTemporaryRTArray_EBB7509C_H786C7270
        */
        public GetTemporaryRTArray ($nameID: int, $width: int, $height: int, $slices: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite) : void
        /**
        * @methodSwap GetTemporaryRTArray_EBB7509C_H480B5569
        */
        public GetTemporaryRTArray ($nameID: int, $width: int, $height: int, $slices: int, $depthBuffer: int, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat) : void
        /**
        * @methodSwap GetTemporaryRTArray_EBB7509C_H8900D0C4
        */
        public GetTemporaryRTArray ($nameID: int, $width: int, $height: int, $slices: int, $depthBuffer: int, $filter: UnityEngine.FilterMode) : void
        /**
        * @methodSwap GetTemporaryRTArray_EBB7509C_EE96822
        */
        public GetTemporaryRTArray ($nameID: int, $width: int, $height: int, $slices: int, $depthBuffer: int) : void
        /**
        * @methodSwap GetTemporaryRTArray_EBB7509C_H7CC42739
        */
        public GetTemporaryRTArray ($nameID: int, $width: int, $height: int, $slices: int) : void
        /**
        * Add a "release a temporary render texture" command.
        * @param nameID Shader property name for this texture.
        */
        public ReleaseTemporaryRT ($nameID: int) : void
        /**
        * Adds a "clear render target" command.
        * @param clearDepth Whether to clear both the depth buffer and the stencil buffer.
        * @param clearColor Whether to clear the color buffer.
        * @param clearFlags Which render targets to clear, defined using a bitwise OR combination of RTClearFlags values.
        * @param backgroundColor Color to clear with.
        * @param depth Depth to clear with (default is 1.0).
        * @param stencil Stencil to clear with (default is 0).
        * @methodSwap ClearRenderTarget_EBB7509C_C6C7305B
        */
        public ClearRenderTarget ($clearFlags: RTClearFlags, $backgroundColor: UnityEngine.Color, $depth: float, $stencil: uint) : void
        public ClearRenderTarget ($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color) : void
        /**
        * Adds a "clear render target" command.
        * @param clearDepth Whether to clear both the depth buffer and the stencil buffer.
        * @param clearColor Whether to clear the color buffer.
        * @param clearFlags Which render targets to clear, defined using a bitwise OR combination of RTClearFlags values.
        * @param backgroundColor Color to clear with.
        * @param depth Depth to clear with (default is 1.0).
        * @param stencil Stencil to clear with (default is 0).
        * @methodSwap ClearRenderTarget_EBB7509C_C93D2606
        */
        public ClearRenderTarget ($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color, $depth: float) : void
        /**
        * Add a "set global shader float property" command.
        * @methodSwap SetGlobalFloat_EBB7509C_A137D5B3
        */
        public SetGlobalFloat ($nameID: int, $value: float) : void
        /**
        * Adds a command to set the value of a given property for all Shaders, where the property has a type of Int in ShaderLab code.
        * @methodSwap SetGlobalInt_EBB7509C_H2CFB2EE5
        */
        public SetGlobalInt ($nameID: int, $value: int) : void
        /**
        * Adds a command to set the value of a given property for all Shaders, where the property is an integer.
        * @methodSwap SetGlobalInteger_EBB7509C_H2CFB2EE5
        */
        public SetGlobalInteger ($nameID: int, $value: int) : void
        /**
        * Add a "set global shader vector property" command.
        * @methodSwap SetGlobalVector_EBB7509C_H9F0E6FE
        */
        public SetGlobalVector ($nameID: int, $value: UnityEngine.Vector4) : void
        /**
        * Add a "set global shader color property" command.
        * @methodSwap SetGlobalColor_EBB7509C_H9F453824
        */
        public SetGlobalColor ($nameID: int, $value: UnityEngine.Color) : void
        /**
        * Add a "set global shader matrix property" command.
        * @methodSwap SetGlobalMatrix_EBB7509C_A704EAE0
        */
        public SetGlobalMatrix ($nameID: int, $value: UnityEngine.Matrix4x4) : void
        /**
        * Adds a command to enable a global keyword with a given name.
        * @param keyword Name of a global shader keyword to enable.
        */
        public EnableShaderKeyword ($keyword: string) : void
        /**
        * Adds a command to enable a global or local shader keyword.
        * @param keyword The global or local shader keyword to enable.
        * @param material The material on which to enable the local shader keyword.
        * @param computeShader The compute shader for which to enable the local shader keyword.
        */
        public EnableKeyword ($keyword: $Ref<GlobalKeyword>) : void
        /**
        * Adds a command to enable a global or local shader keyword.
        * @param keyword The global or local shader keyword to enable.
        * @param material The material on which to enable the local shader keyword.
        * @param computeShader The compute shader for which to enable the local shader keyword.
        */
        public EnableKeyword ($material: UnityEngine.Material, $keyword: $Ref<LocalKeyword>) : void
        /**
        * Adds a command to enable a global or local shader keyword.
        * @param keyword The global or local shader keyword to enable.
        * @param material The material on which to enable the local shader keyword.
        * @param computeShader The compute shader for which to enable the local shader keyword.
        */
        public EnableKeyword ($computeShader: UnityEngine.ComputeShader, $keyword: $Ref<LocalKeyword>) : void
        /**
        * Adds a command to disable a global shader keyword with a given name.
        * @param keyword Name of a global keyword to disable.
        */
        public DisableShaderKeyword ($keyword: string) : void
        /**
        * Adds a command to disable a global or local shader keyword.
        * @param keyword The global or local shader keyword to disable.
        * @param material The material on which to disable the local shader keyword.
        * @param computeShader The compute shader for which to disable the local shader keyword.
        */
        public DisableKeyword ($keyword: $Ref<GlobalKeyword>) : void
        /**
        * Adds a command to disable a global or local shader keyword.
        * @param keyword The global or local shader keyword to disable.
        * @param material The material on which to disable the local shader keyword.
        * @param computeShader The compute shader for which to disable the local shader keyword.
        */
        public DisableKeyword ($material: UnityEngine.Material, $keyword: $Ref<LocalKeyword>) : void
        /**
        * Adds a command to disable a global or local shader keyword.
        * @param keyword The global or local shader keyword to disable.
        * @param material The material on which to disable the local shader keyword.
        * @param computeShader The compute shader for which to disable the local shader keyword.
        */
        public DisableKeyword ($computeShader: UnityEngine.ComputeShader, $keyword: $Ref<LocalKeyword>) : void
        /**
        * Adds a command to set the state of a global or local shader keyword.
        * @param keyword The local or global shader keyword to set the state for.
        * @param material The material for which to set the state of the local shader keyword.
        * @param computeShader The compute shader for which to set the state of the local shader keyword.
        * @param value The state to set the shader keyword state to.
        */
        public SetKeyword ($keyword: $Ref<GlobalKeyword>, $value: boolean) : void
        /**
        * Adds a command to set the state of a global or local shader keyword.
        * @param keyword The local or global shader keyword to set the state for.
        * @param material The material for which to set the state of the local shader keyword.
        * @param computeShader The compute shader for which to set the state of the local shader keyword.
        * @param value The state to set the shader keyword state to.
        */
        public SetKeyword ($material: UnityEngine.Material, $keyword: $Ref<LocalKeyword>, $value: boolean) : void
        /**
        * Adds a command to set the state of a global or local shader keyword.
        * @param keyword The local or global shader keyword to set the state for.
        * @param material The material for which to set the state of the local shader keyword.
        * @param computeShader The compute shader for which to set the state of the local shader keyword.
        * @param value The state to set the shader keyword state to.
        */
        public SetKeyword ($computeShader: UnityEngine.ComputeShader, $keyword: $Ref<LocalKeyword>, $value: boolean) : void
        /**
        * Add a command to set the view matrix.
        * @param view View (world to camera space) matrix.
        */
        public SetViewMatrix ($view: UnityEngine.Matrix4x4) : void
        /**
        * Add a command to set the projection matrix.
        * @param proj Projection (camera to clip space) matrix.
        */
        public SetProjectionMatrix ($proj: UnityEngine.Matrix4x4) : void
        /**
        * Add a command to set the view and projection matrices.
        * @param view View (world to camera space) matrix.
        * @param proj Projection (camera to clip space) matrix.
        */
        public SetViewProjectionMatrices ($view: UnityEngine.Matrix4x4, $proj: UnityEngine.Matrix4x4) : void
        /**
        * Adds a command to set the global depth bias.
        * @param bias Scales the GPU's minimum resolvable depth buffer value to produce a constant depth offset. The minimum resolvable depth buffer value varies by device.

        Set to a negative value to draw geometry closer to the camera, or a positive value to draw geometry further away from the camera.
        * @param slopeBias Scales the maximum Z slope, also called the depth slope, to produce a variable depth offset for each polygon.

        Polygons that are not parallel to the near and far clip planes have Z slope. Adjust this value to avoid visual artifacts on such polygons.
        */
        public SetGlobalDepthBias ($bias: float, $slopeBias: float) : void
        /**
        * Set flags describing the intention for how the command buffer will be executed.
        * @param flags The flags to set.
        */
        public SetExecutionFlags ($flags: CommandBufferExecutionFlags) : void
        /**
        * Add a "set global shader float array property" command.
        * @methodSwap SetGlobalFloatArray_EBB7509C_H4A792FF
        */
        public SetGlobalFloatArray ($nameID: int, $values: float[]) : void
        /**
        * Add a "set global shader vector array property" command.
        * @methodSwap SetGlobalVectorArray_EBB7509C_H500372C6
        */
        public SetGlobalVectorArray ($nameID: int, $values: UnityEngine.Vector4[]) : void
        /**
        * Add a "set global shader matrix array property" command.
        * @methodSwap SetGlobalMatrixArray_EBB7509C_H4B572A74
        */
        public SetGlobalMatrixArray ($nameID: int, $values: UnityEngine.Matrix4x4[]) : void
        /**
        * Set the current stereo projection matrices for late latching. Stereo matrices is passed in as an array of two matrices.
        * @param projectionMat Stereo projection matrices.
        */
        public SetLateLatchProjectionMatrices ($projectionMat: UnityEngine.Matrix4x4[]) : void
        /**
        * Mark a global shader property id to be late latched.  Possible shader properties include view, inverseView, viewProjection, and inverseViewProjection matrices. The Universal Render Pipeline (URP) uses this function to support late latching of shader properties. If you call this function when using built-in Unity rendering or the High-Definition Rendering Pipeline (HDRP), the results are ignored.
        * @param matrixPropertyType Camera matrix property type to be late latched.
        * @param shaderPropertyID Shader property name id.
        */
        public MarkLateLatchMatrixShaderPropertyID ($matrixPropertyType: CameraLateLatchMatrixType, $shaderPropertyID: int) : void
        /**
        * Unmark a global shader property for late latching. After unmarking, the shader property will no longer be late latched.  This function is intended for the Universal Render Pipeline (URP) to specify late latched shader properties.
        * @param matrixPropertyType Camera matrix property type to be unmarked for late latching.
        */
        public UnmarkLateLatchMatrix ($matrixPropertyType: CameraLateLatchMatrixType) : void
        /**
        * Adds a command to begin profile sampling.
        * @param name Name of the profile information used for sampling.
        * @param sampler The CustomSampler that the CommandBuffer uses for sampling.
        * @param marker The ProfilerMarker that the CommandBuffer uses for sampling.
        */
        public BeginSample ($name: string) : void
        /**
        * Adds a command to end profile sampling.
        * @param name Name of the profile information used for sampling.
        * @param sampler The CustomSampler that the CommandBuffer uses for sampling.
        * @param marker The ProfilerMarker that the CommandBuffer uses for sampling.
        */
        public EndSample ($name: string) : void
        /**
        * Adds a command to begin profile sampling.
        * @param name Name of the profile information used for sampling.
        * @param sampler The CustomSampler that the CommandBuffer uses for sampling.
        * @param marker The ProfilerMarker that the CommandBuffer uses for sampling.
        */
        public BeginSample ($sampler: UnityEngine_Profiling.CustomSampler) : void
        /**
        * Adds a command to end profile sampling.
        * @param name Name of the profile information used for sampling.
        * @param sampler The CustomSampler that the CommandBuffer uses for sampling.
        * @param marker The ProfilerMarker that the CommandBuffer uses for sampling.
        */
        public EndSample ($sampler: UnityEngine_Profiling.CustomSampler) : void
        public BeginSample ($marker: Unity_Profiling.ProfilerMarker) : void
        public EndSample ($marker: Unity_Profiling.ProfilerMarker) : void
        /**
        * Increments the updateCount property of a Texture.
        * @param dest Increments the updateCount for this Texture.
        */
        public IncrementUpdateCount ($dest: RenderTargetIdentifier) : void
        /**
        * Adds a command to multiply the instance count of every draw call by a specific multiplier.
        */
        public SetInstanceMultiplier ($multiplier: uint) : void
        /**
        * Adds a command to set the mode to use for foveated rendering.
        * @param foveatedRenderingMode The mode to set.
        */
        public SetFoveatedRenderingMode ($foveatedRenderingMode: FoveatedRenderingMode) : void
        /**
        * Adds a command to configure foveated rendering.
        * @param platformData The native pointer from XR.XRDisplaySubsystem.XRRenderPass.foveatedRenderingInfo.
        */
        public ConfigureFoveatedRendering ($platformData: System.IntPtr) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        */
        public SetRenderTarget ($rt: RenderTargetIdentifier) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        */
        public SetRenderTarget ($rt: RenderTargetIdentifier, $loadAction: RenderBufferLoadAction, $storeAction: RenderBufferStoreAction) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        */
        public SetRenderTarget ($rt: RenderTargetIdentifier, $colorLoadAction: RenderBufferLoadAction, $colorStoreAction: RenderBufferStoreAction, $depthLoadAction: RenderBufferLoadAction, $depthStoreAction: RenderBufferStoreAction) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        * @methodSwap SetRenderTarget_EBB7509C_H45F85749
        */
        public SetRenderTarget ($rt: RenderTargetIdentifier, $mipLevel: int) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        * @methodSwap SetRenderTarget_EBB7509C_H735A446
        */
        public SetRenderTarget ($rt: RenderTargetIdentifier, $mipLevel: int, $cubemapFace: UnityEngine.CubemapFace) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        * @methodSwap SetRenderTarget_EBB7509C_H7DDA9DD9
        */
        public SetRenderTarget ($rt: RenderTargetIdentifier, $mipLevel: int, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: int) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        */
        public SetRenderTarget ($color: RenderTargetIdentifier, $depth: RenderTargetIdentifier) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        * @methodSwap SetRenderTarget_EBB7509C_E163F436
        */
        public SetRenderTarget ($color: RenderTargetIdentifier, $depth: RenderTargetIdentifier, $mipLevel: int) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        * @methodSwap SetRenderTarget_EBB7509C_H274030E7
        */
        public SetRenderTarget ($color: RenderTargetIdentifier, $depth: RenderTargetIdentifier, $mipLevel: int, $cubemapFace: UnityEngine.CubemapFace) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        * @methodSwap SetRenderTarget_EBB7509C_DFC847A0
        */
        public SetRenderTarget ($color: RenderTargetIdentifier, $depth: RenderTargetIdentifier, $mipLevel: int, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: int) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        */
        public SetRenderTarget ($color: RenderTargetIdentifier, $colorLoadAction: RenderBufferLoadAction, $colorStoreAction: RenderBufferStoreAction, $depth: RenderTargetIdentifier, $depthLoadAction: RenderBufferLoadAction, $depthStoreAction: RenderBufferStoreAction) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        */
        public SetRenderTarget ($colors: RenderTargetIdentifier[], $depth: RenderTargetIdentifier) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        * @methodSwap SetRenderTarget_EBB7509C_H381FB4B8
        */
        public SetRenderTarget ($colors: RenderTargetIdentifier[], $depth: RenderTargetIdentifier, $mipLevel: int, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: int) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        * @methodSwap SetRenderTarget_EBB7509C_H31A5A9D
        */
        public SetRenderTarget ($binding: RenderTargetBinding, $mipLevel: int, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: int) : void
        /**
        * Add a "set active render target" command.
        * @param rt Render target to set for both color & depth buffers.
        * @param color Render target to set as a color buffer.
        * @param colors Render targets to set as color buffers (MRT).
        * @param depth Render target to set as a depth buffer.
        * @param mipLevel The mip level of the render target to render into.
        * @param cubemapFace The cubemap face of a cubemap render target to render into.
        * @param depthSlice Slice of a 3D or array render target to set.
        * @param loadAction Load action that is used for color and depth/stencil buffers.
        * @param storeAction Store action that is used for color and depth/stencil buffers.
        * @param colorLoadAction Load action that is used for the color buffer.
        * @param colorStoreAction Store action that is used for the color buffer.
        * @param depthLoadAction Load action that is used for the depth/stencil buffer.
        * @param depthStoreAction Store action that is used for the depth/stencil buffer.
        */
        public SetRenderTarget ($binding: RenderTargetBinding) : void
        /**
        * Adds a command to set the buffer with values from an array.
        * @param buffer The destination buffer.
        * @param data Array of values to fill the buffer.
        */
        public SetBufferData ($buffer: UnityEngine.ComputeBuffer, $data: System.Array) : void
        public SetBufferData<T> ($buffer: UnityEngine.ComputeBuffer, $data: System_Collections_Generic.List$1<T>) : void
        public SetBufferData<T> ($buffer: UnityEngine.ComputeBuffer, $data: Unity_Collections.NativeArray$1<T>) : void
        /**
        * Adds a command to process a partial copy of data values from an array into the buffer.
        * @param buffer The destination buffer.
        * @param data Array of values to fill the buffer.
        * @param managedBufferStartIndex The first element index in data to copy to the compute buffer.
        * @param graphicsBufferStartIndex The first element index in compute buffer to receive the data.
        * @param count The number of elements to copy.
        * @param nativeBufferStartIndex The first element index in data to copy to the compute buffer.
        * @methodSwap SetBufferData_EBB7509C_H8189DF0
        */
        public SetBufferData ($buffer: UnityEngine.ComputeBuffer, $data: System.Array, $managedBufferStartIndex: int, $graphicsBufferStartIndex: int, $count: int) : void
        /**
        * @methodSwap SetBufferData_EBB7509C_B1CCB978
        */
        public SetBufferData<T> ($buffer: UnityEngine.ComputeBuffer, $data: System_Collections_Generic.List$1<T>, $managedBufferStartIndex: int, $graphicsBufferStartIndex: int, $count: int) : void
        /**
        * @methodSwap SetBufferData_EBB7509C_E8A6741
        */
        public SetBufferData<T> ($buffer: UnityEngine.ComputeBuffer, $data: Unity_Collections.NativeArray$1<T>, $nativeBufferStartIndex: int, $graphicsBufferStartIndex: int, $count: int) : void
        /**
        * Adds a command to set the counter value of append/consume buffer.
        * @param buffer The destination buffer.
        * @param counterValue Value of the append/consume counter.
        * @methodSwap SetBufferCounterValue_EBB7509C_H48C62327
        */
        public SetBufferCounterValue ($buffer: UnityEngine.ComputeBuffer, $counterValue: uint) : void
        /**
        * Adds a command to set the buffer with values from an array.
        * @param buffer The destination buffer.
        * @param data Array of values to fill the buffer.
        */
        public SetBufferData ($buffer: UnityEngine.GraphicsBuffer, $data: System.Array) : void
        public SetBufferData<T> ($buffer: UnityEngine.GraphicsBuffer, $data: System_Collections_Generic.List$1<T>) : void
        public SetBufferData<T> ($buffer: UnityEngine.GraphicsBuffer, $data: Unity_Collections.NativeArray$1<T>) : void
        /**
        * Adds a command to process a partial copy of data values from an array into the buffer.
        * @param buffer The destination buffer.
        * @param data Array of values to fill the buffer.
        * @param managedBufferStartIndex The first element index in data to copy to the compute buffer.
        * @param graphicsBufferStartIndex The first element index in compute buffer to receive the data.
        * @param count The number of elements to copy.
        * @param nativeBufferStartIndex The first element index in data to copy to the compute buffer.
        * @methodSwap SetBufferData_EBB7509C_FD39FE0
        */
        public SetBufferData ($buffer: UnityEngine.GraphicsBuffer, $data: System.Array, $managedBufferStartIndex: int, $graphicsBufferStartIndex: int, $count: int) : void
        /**
        * @methodSwap SetBufferData_EBB7509C_AD1A21E8
        */
        public SetBufferData<T> ($buffer: UnityEngine.GraphicsBuffer, $data: System_Collections_Generic.List$1<T>, $managedBufferStartIndex: int, $graphicsBufferStartIndex: int, $count: int) : void
        /**
        * @methodSwap SetBufferData_EBB7509C_H86486191
        */
        public SetBufferData<T> ($buffer: UnityEngine.GraphicsBuffer, $data: Unity_Collections.NativeArray$1<T>, $nativeBufferStartIndex: int, $graphicsBufferStartIndex: int, $count: int) : void
        /**
        * Adds a command to set the counter value of append/consume buffer.
        * @param buffer The destination buffer.
        * @param counterValue Value of the append/consume counter.
        * @methodSwap SetBufferCounterValue_EBB7509C_D8FD67F7
        */
        public SetBufferCounterValue ($buffer: UnityEngine.GraphicsBuffer, $counterValue: uint) : void
        public Dispose () : void
        public Release () : void
        /**
        * Shortcut for calling CommandBuffer.CreateGraphicsFence with Rendering.GraphicsFenceType.AsyncQueueSynchronisation as the first parameter.
        * @param stage Which SynchronisationStage to insert the fence after.
        * @returns Returns a new GraphicsFence.
        */
        public CreateAsyncGraphicsFence () : GraphicsFence
        /**
        * Shortcut for calling CommandBuffer.CreateGraphicsFence with Rendering.GraphicsFenceType.AsyncQueueSynchronisation as the first parameter.
        * @param stage Which SynchronisationStage to insert the fence after.
        * @returns Returns a new GraphicsFence.
        */
        public CreateAsyncGraphicsFence ($stage: SynchronisationStage) : GraphicsFence
        /**
        * Creates a GraphicsFence.
        * @param fenceType The Rendering.GraphicsFenceType to create. Currently the only supported value is Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
        * @param stage Which SynchronisationStage to insert the fence after.
        * @returns Returns a new GraphicsFence.
        */
        public CreateGraphicsFence ($fenceType: GraphicsFenceType, $stage: SynchronisationStageFlags) : GraphicsFence
        /**
        * Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence.
        * @param fence The GraphicsFence the GPU waits for. The fenceType of the graphics fence must be Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
        * @param stage Which SynchronisationStage to wait for.
        */
        public WaitOnAsyncGraphicsFence ($fence: GraphicsFence) : void
        /**
        * Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence.
        * @param fence The GraphicsFence the GPU waits for. The fenceType of the graphics fence must be Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
        * @param stage Which SynchronisationStage to wait for.
        */
        public WaitOnAsyncGraphicsFence ($fence: GraphicsFence, $stage: SynchronisationStage) : void
        public WaitOnAsyncGraphicsFence ($fence: GraphicsFence, $stage: SynchronisationStageFlags) : void
        /**
        * Adds a command to set a float parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetComputeFloatParam_EBB7509C_H160F45B7
        */
        public SetComputeFloatParam ($computeShader: UnityEngine.ComputeShader, $name: string, $val: float) : void
        /**
        * Adds a command to set an integer parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetComputeIntParam_EBB7509C_F356A3F1
        */
        public SetComputeIntParam ($computeShader: UnityEngine.ComputeShader, $name: string, $val: int) : void
        /**
        * Adds a command to set a vector parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        */
        public SetComputeVectorParam ($computeShader: UnityEngine.ComputeShader, $name: string, $val: UnityEngine.Vector4) : void
        /**
        * Adds a command to set a vector array parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Property name.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Value to set.
        */
        public SetComputeVectorArrayParam ($computeShader: UnityEngine.ComputeShader, $name: string, $values: UnityEngine.Vector4[]) : void
        /**
        * Adds a command to set a matrix parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        */
        public SetComputeMatrixParam ($computeShader: UnityEngine.ComputeShader, $name: string, $val: UnityEngine.Matrix4x4) : void
        /**
        * Adds a command to set a matrix array parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Value to set.
        */
        public SetComputeMatrixArrayParam ($computeShader: UnityEngine.ComputeShader, $name: string, $values: UnityEngine.Matrix4x4[]) : void
        /**
        * Adds a command to set multiple consecutive float parameters on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Values to set.
        */
        public SetComputeFloatParams ($computeShader: UnityEngine.ComputeShader, $name: string, ...values: float[]) : void
        /**
        * Adds a command to set multiple consecutive float parameters on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Values to set.
        * @methodSwap SetComputeFloatParams_EBB7509C_D49C4836
        */
        public SetComputeFloatParams ($computeShader: UnityEngine.ComputeShader, $nameID: int, ...values: float[]) : void
        /**
        * Adds a command to set multiple consecutive integer parameters on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Values to set.
        */
        public SetComputeIntParams ($computeShader: UnityEngine.ComputeShader, $name: string, ...values: int[]) : void
        /**
        * Adds a command to set multiple consecutive integer parameters on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Values to set.
        * @methodSwap SetComputeIntParams_EBB7509C_F945263A
        */
        public SetComputeIntParams ($computeShader: UnityEngine.ComputeShader, $nameID: int, ...values: int[]) : void
        /**
        * Adds a command to set a texture parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
        * @param name Name of the texture variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetComputeTextureParam_EBB7509C_H4ADDE10C
        */
        public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $name: string, $rt: RenderTargetIdentifier) : void
        /**
        * Adds a command to set a texture parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
        * @param name Name of the texture variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetComputeTextureParam_EBB7509C_A38442B5
        */
        public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $nameID: int, $rt: RenderTargetIdentifier) : void
        /**
        * Adds a command to set a texture parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
        * @param name Name of the texture variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetComputeTextureParam_EBB7509C_DA6AB067
        */
        public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $name: string, $rt: RenderTargetIdentifier, $mipLevel: int) : void
        /**
        * Adds a command to set a texture parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
        * @param name Name of the texture variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetComputeTextureParam_EBB7509C_H5B5DD996
        */
        public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $nameID: int, $rt: RenderTargetIdentifier, $mipLevel: int) : void
        /**
        * Adds a command to set a texture parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
        * @param name Name of the texture variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetComputeTextureParam_EBB7509C_H276B9467
        */
        public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $name: string, $rt: RenderTargetIdentifier, $mipLevel: int, $element: RenderTextureSubElement) : void
        /**
        * Adds a command to set a texture parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
        * @param name Name of the texture variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
        * @param mipLevel Optional mipmap level of the read-write texture.
        * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
        * @methodSwap SetComputeTextureParam_EBB7509C_B977ADF8
        */
        public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $nameID: int, $rt: RenderTargetIdentifier, $mipLevel: int, $element: RenderTextureSubElement) : void
        /**
        * Adds a command to set an input or output buffer parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
        * @param name Name of the buffer variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param buffer Buffer to set.
        * @param bufferHandle The handle of the buffer to set.
        * @methodSwap SetComputeBufferParam_EBB7509C_H4B2C483C
        */
        public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $nameID: int, $buffer: UnityEngine.ComputeBuffer) : void
        /**
        * Adds a command to set an input or output buffer parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
        * @param name Name of the buffer variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param buffer Buffer to set.
        * @param bufferHandle The handle of the buffer to set.
        * @methodSwap SetComputeBufferParam_EBB7509C_H7F6FA5EF
        */
        public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $name: string, $buffer: UnityEngine.ComputeBuffer) : void
        /**
        * Adds a command to set an input or output buffer parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
        * @param name Name of the buffer variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param buffer Buffer to set.
        * @param bufferHandle The handle of the buffer to set.
        * @methodSwap SetComputeBufferParam_EBB7509C_H886BB974
        */
        public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $nameID: int, $bufferHandle: UnityEngine.GraphicsBufferHandle) : void
        /**
        * Adds a command to set an input or output buffer parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
        * @param name Name of the buffer variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param buffer Buffer to set.
        * @param bufferHandle The handle of the buffer to set.
        * @methodSwap SetComputeBufferParam_EBB7509C_E4AAC305
        */
        public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $name: string, $bufferHandle: UnityEngine.GraphicsBufferHandle) : void
        /**
        * Adds a command to set an input or output buffer parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
        * @param name Name of the buffer variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param buffer Buffer to set.
        * @param bufferHandle The handle of the buffer to set.
        * @methodSwap SetComputeBufferParam_EBB7509C_H92AE2E0A
        */
        public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $nameID: int, $buffer: UnityEngine.GraphicsBuffer) : void
        /**
        * Adds a command to set an input or output buffer parameter on a ComputeShader.
        * @param computeShader ComputeShader to set parameter for.
        * @param kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
        * @param name Name of the buffer variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param buffer Buffer to set.
        * @param bufferHandle The handle of the buffer to set.
        * @methodSwap SetComputeBufferParam_EBB7509C_E37D58A3
        */
        public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $name: string, $buffer: UnityEngine.GraphicsBuffer) : void
        /**
        * Adds a command to set a constant buffer on a ComputeShader.
        * @param computeShader The ComputeShader to set parameter for.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the constant buffer in shaders code.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetComputeConstantBufferParam_EBB7509C_H1AFD3A7D
        */
        public SetComputeConstantBufferParam ($computeShader: UnityEngine.ComputeShader, $nameID: int, $buffer: UnityEngine.ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Adds a command to set a constant buffer on a ComputeShader.
        * @param computeShader The ComputeShader to set parameter for.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the constant buffer in shaders code.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetComputeConstantBufferParam_EBB7509C_H5D928B08
        */
        public SetComputeConstantBufferParam ($computeShader: UnityEngine.ComputeShader, $name: string, $buffer: UnityEngine.ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Adds a command to set a constant buffer on a ComputeShader.
        * @param computeShader The ComputeShader to set parameter for.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the constant buffer in shaders code.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetComputeConstantBufferParam_EBB7509C_H310AA445
        */
        public SetComputeConstantBufferParam ($computeShader: UnityEngine.ComputeShader, $nameID: int, $buffer: UnityEngine.GraphicsBuffer, $offset: int, $size: int) : void
        /**
        * Adds a command to set a constant buffer on a ComputeShader.
        * @param computeShader The ComputeShader to set parameter for.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the constant buffer in shaders code.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetComputeConstantBufferParam_EBB7509C_H5FD5D91E
        */
        public SetComputeConstantBufferParam ($computeShader: UnityEngine.ComputeShader, $name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: int, $size: int) : void
        /**
        * Sets the parameters for a compute shader kernel from a Material.
        * @param computeShader The ComputeShader to set parameters for.
        * @param kernelIndex The index of the kernel to set the material parameters. See ComputeShader.FindKernel.
        * @param material The material to set the compute parameters.
        */
        public SetComputeParamsFromMaterial ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $material: UnityEngine.Material) : void
        /**
        * Add a command to execute a ComputeShader.
        * @param computeShader ComputeShader to execute.
        * @param kernelIndex Kernel index to execute, see ComputeShader.FindKernel.
        * @param threadGroupsX Number of work groups in the X dimension.
        * @param threadGroupsY Number of work groups in the Y dimension.
        * @param threadGroupsZ Number of work groups in the Z dimension.
        * @param indirectBuffer ComputeBuffer with dispatch arguments.
        * @param argsOffset Byte offset indicating the location of the dispatch arguments in the buffer.
        * @methodSwap DispatchCompute_EBB7509C_E518D3F2
        */
        public DispatchCompute ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $threadGroupsX: int, $threadGroupsY: int, $threadGroupsZ: int) : void
        /**
        * Add a command to execute a ComputeShader.
        * @param computeShader ComputeShader to execute.
        * @param kernelIndex Kernel index to execute, see ComputeShader.FindKernel.
        * @param threadGroupsX Number of work groups in the X dimension.
        * @param threadGroupsY Number of work groups in the Y dimension.
        * @param threadGroupsZ Number of work groups in the Z dimension.
        * @param indirectBuffer ComputeBuffer with dispatch arguments.
        * @param argsOffset Byte offset indicating the location of the dispatch arguments in the buffer.
        * @methodSwap DispatchCompute_EBB7509C_H4C876913
        */
        public DispatchCompute ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $indirectBuffer: UnityEngine.ComputeBuffer, $argsOffset: uint) : void
        /**
        * Add a command to execute a ComputeShader.
        * @param computeShader ComputeShader to execute.
        * @param kernelIndex Kernel index to execute, see ComputeShader.FindKernel.
        * @param threadGroupsX Number of work groups in the X dimension.
        * @param threadGroupsY Number of work groups in the Y dimension.
        * @param threadGroupsZ Number of work groups in the Z dimension.
        * @param indirectBuffer ComputeBuffer with dispatch arguments.
        * @param argsOffset Byte offset indicating the location of the dispatch arguments in the buffer.
        * @methodSwap DispatchCompute_EBB7509C_H6055CEEB
        */
        public DispatchCompute ($computeShader: UnityEngine.ComputeShader, $kernelIndex: int, $indirectBuffer: UnityEngine.GraphicsBuffer, $argsOffset: uint) : void
        /**
        * Adds a command to build the RayTracingAccelerationStructure to be used in a ray tracing dispatch.
        * @param accelerationStructure The RayTracingAccelerationStructure to be generated.
        */
        public BuildRayTracingAccelerationStructure ($accelerationStructure: UnityEngine_Experimental_Rendering.RayTracingAccelerationStructure) : void
        /**
        * Adds a command to build the RayTracingAccelerationStructure to be used in a ray tracing dispatch.
        * @param accelerationStructure The RayTracingAccelerationStructure to be generated.
        */
        public BuildRayTracingAccelerationStructure ($accelerationStructure: UnityEngine_Experimental_Rendering.RayTracingAccelerationStructure, $relativeOrigin: UnityEngine.Vector3) : void
        /**
        * Adds a command to set the RayTracingAccelerationStructure to be used with the RayTracingShader.
        * @param rayTracingShader The RayTracingShader to set parameter for.
        * @param name Name of the RayTracingAccelerationStructure in shader coder.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param rayTracingAccelerationStructure The RayTracingAccelerationStructure to be used.
        */
        public SetRayTracingAccelerationStructure ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $rayTracingAccelerationStructure: UnityEngine_Experimental_Rendering.RayTracingAccelerationStructure) : void
        /**
        * Adds a command to set the RayTracingAccelerationStructure to be used with the RayTracingShader.
        * @param rayTracingShader The RayTracingShader to set parameter for.
        * @param name Name of the RayTracingAccelerationStructure in shader coder.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param rayTracingAccelerationStructure The RayTracingAccelerationStructure to be used.
        * @methodSwap SetRayTracingAccelerationStructure_EBB7509C_H637017AE
        */
        public SetRayTracingAccelerationStructure ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, $rayTracingAccelerationStructure: UnityEngine_Experimental_Rendering.RayTracingAccelerationStructure) : void
        /**
        * Adds a command to set an input or output buffer parameter on a RayTracingShader.
        * @param rayTracingShader The RayTracingShader to set parameter for.
        * @param name The name of the constant buffer in shader code.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param buffer Buffer to set.
        */
        public SetRayTracingBufferParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.ComputeBuffer) : void
        /**
        * Adds a command to set an input or output buffer parameter on a RayTracingShader.
        * @param rayTracingShader The RayTracingShader to set parameter for.
        * @param name The name of the constant buffer in shader code.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param buffer Buffer to set.
        * @methodSwap SetRayTracingBufferParam_EBB7509C_F7CDD702
        */
        public SetRayTracingBufferParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, $buffer: UnityEngine.ComputeBuffer) : void
        /**
        * Adds a command to set a constant buffer on a RayTracingShader.
        * @param rayTracingShader The RayTracingShader to set parameter for.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the constant buffer in shader code.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetRayTracingConstantBufferParam_EBB7509C_A29E7EE
        */
        public SetRayTracingConstantBufferParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, $buffer: UnityEngine.ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Adds a command to set a constant buffer on a RayTracingShader.
        * @param rayTracingShader The RayTracingShader to set parameter for.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the constant buffer in shader code.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetRayTracingConstantBufferParam_EBB7509C_H4459F401
        */
        public SetRayTracingConstantBufferParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.ComputeBuffer, $offset: int, $size: int) : void
        /**
        * Adds a command to set a constant buffer on a RayTracingShader.
        * @param rayTracingShader The RayTracingShader to set parameter for.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the constant buffer in shader code.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetRayTracingConstantBufferParam_EBB7509C_A7684118
        */
        public SetRayTracingConstantBufferParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, $buffer: UnityEngine.GraphicsBuffer, $offset: int, $size: int) : void
        /**
        * Adds a command to set a constant buffer on a RayTracingShader.
        * @param rayTracingShader The RayTracingShader to set parameter for.
        * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
        * @param name The name of the constant buffer in shader code.
        * @param buffer The buffer to bind as constant buffer.
        * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
        * @param size The number of bytes to bind.
        * @methodSwap SetRayTracingConstantBufferParam_EBB7509C_H1A315641
        */
        public SetRayTracingConstantBufferParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: int, $size: int) : void
        /**
        * Adds a command to set a texture parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the texture variable in shader code.
        * @param nameID The ID of the property name for the texture in shader code. Use Shader.PropertyToID to get this ID.
        * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
        */
        public SetRayTracingTextureParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $rt: RenderTargetIdentifier) : void
        /**
        * Adds a command to set a texture parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the texture variable in shader code.
        * @param nameID The ID of the property name for the texture in shader code. Use Shader.PropertyToID to get this ID.
        * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
        * @methodSwap SetRayTracingTextureParam_EBB7509C_D5D78C1F
        */
        public SetRayTracingTextureParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, $rt: RenderTargetIdentifier) : void
        /**
        * Adds a command to set a float parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetRayTracingFloatParam_EBB7509C_FEF42276
        */
        public SetRayTracingFloatParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $val: float) : void
        /**
        * Adds a command to set a float parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetRayTracingFloatParam_EBB7509C_F9820661
        */
        public SetRayTracingFloatParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, $val: float) : void
        /**
        * Adds a command to set multiple consecutive float parameters on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Values to set.
        */
        public SetRayTracingFloatParams ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, ...values: float[]) : void
        /**
        * Adds a command to set multiple consecutive float parameters on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Values to set.
        * @methodSwap SetRayTracingFloatParams_EBB7509C_H5CEFC0DB
        */
        public SetRayTracingFloatParams ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, ...values: float[]) : void
        /**
        * Adds a command to set an integer parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetRayTracingIntParam_EBB7509C_CC52A752
        */
        public SetRayTracingIntParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $val: int) : void
        /**
        * Adds a command to set an integer parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetRayTracingIntParam_EBB7509C_H2B1D3D57
        */
        public SetRayTracingIntParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, $val: int) : void
        /**
        * Adds a command to set multiple consecutive integer parameters on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Values to set.
        */
        public SetRayTracingIntParams ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, ...values: int[]) : void
        /**
        * Adds a command to set multiple consecutive integer parameters on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Values to set.
        * @methodSwap SetRayTracingIntParams_EBB7509C_H93A9CD39
        */
        public SetRayTracingIntParams ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, ...values: int[]) : void
        /**
        * Adds a command to set a vector parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        */
        public SetRayTracingVectorParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $val: UnityEngine.Vector4) : void
        /**
        * Adds a command to set a vector parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetRayTracingVectorParam_EBB7509C_DEF0BC88
        */
        public SetRayTracingVectorParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, $val: UnityEngine.Vector4) : void
        /**
        * Adds a command to set a vector array parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Property name.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Value to set.
        */
        public SetRayTracingVectorArrayParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, ...values: UnityEngine.Vector4[]) : void
        /**
        * Adds a command to set a vector array parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Property name.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Value to set.
        * @methodSwap SetRayTracingVectorArrayParam_EBB7509C_H5EF561E2
        */
        public SetRayTracingVectorArrayParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, ...values: UnityEngine.Vector4[]) : void
        /**
        * Adds a command to set a matrix parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        */
        public SetRayTracingMatrixParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $val: UnityEngine.Matrix4x4) : void
        /**
        * Adds a command to set a matrix parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param val Value to set.
        * @methodSwap SetRayTracingMatrixParam_EBB7509C_D33CE37E
        */
        public SetRayTracingMatrixParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, $val: UnityEngine.Matrix4x4) : void
        /**
        * Adds a command to set a matrix array parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Value to set.
        */
        public SetRayTracingMatrixArrayParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, ...values: UnityEngine.Matrix4x4[]) : void
        /**
        * Adds a command to set a matrix array parameter on a RayTracingShader.
        * @param rayTracingShader RayTracingShader to set parameter for.
        * @param name Name of the variable in shader code.
        * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
        * @param values Value to set.
        * @methodSwap SetRayTracingMatrixArrayParam_EBB7509C_DE493108
        */
        public SetRayTracingMatrixArrayParam ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: int, ...values: UnityEngine.Matrix4x4[]) : void
        /**
        * Adds a command to execute a RayTracingShader.
        * @param rayTracingShader RayTracingShader to execute.
        * @param rayGenName The name of the ray generation shader.
        * @param width The width of the ray generation shader thread grid.
        * @param height The height of the ray generation shader thread grid.
        * @param depth The depth of the ray generation shader thread grid.
        * @param camera Optional parameter used to setup camera-related built-in shader variables.
        */
        public DispatchRays ($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $rayGenName: string, $width: uint, $height: uint, $depth: uint, $camera?: UnityEngine.Camera) : void
        /**
        * Generate mipmap levels of a render texture.
        * @param rt The render texture requiring mipmaps generation.
        */
        public GenerateMips ($rt: RenderTargetIdentifier) : void
        /**
        * Generate mipmap levels of a render texture.
        * @param rt The render texture requiring mipmaps generation.
        */
        public GenerateMips ($rt: UnityEngine.RenderTexture) : void
        /**
        * Force an antialiased render texture to be resolved.
        * @param rt The antialiased render texture to resolve.
        * @param target The render texture to resolve into.  If set, the target render texture must have the same dimensions and format as the source.
        */
        public ResolveAntiAliasedSurface ($rt: UnityEngine.RenderTexture, $target?: UnityEngine.RenderTexture) : void
        /**
        * Add a "draw mesh" command.
        * @param mesh Mesh to draw.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param submeshIndex Which subset of the mesh to render.
        * @param shaderPass Which pass of the shader to use (default is -1, which renders all passes).
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @methodSwap DrawMesh_EBB7509C_C266A27F
        */
        public DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: int, $shaderPass: int, $properties: UnityEngine.MaterialPropertyBlock) : void
        /**
        * Add a "draw mesh" command.
        * @param mesh Mesh to draw.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param submeshIndex Which subset of the mesh to render.
        * @param shaderPass Which pass of the shader to use (default is -1, which renders all passes).
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @methodSwap DrawMesh_EBB7509C_H7B9EC135
        */
        public DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: int, $shaderPass: int) : void
        /**
        * Add a "draw mesh" command.
        * @param mesh Mesh to draw.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param submeshIndex Which subset of the mesh to render.
        * @param shaderPass Which pass of the shader to use (default is -1, which renders all passes).
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @methodSwap DrawMesh_EBB7509C_DD285E6A
        */
        public DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: int) : void
        /**
        * Add a "draw mesh" command.
        * @param mesh Mesh to draw.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param submeshIndex Which subset of the mesh to render.
        * @param shaderPass Which pass of the shader to use (default is -1, which renders all passes).
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        */
        public DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material) : void
        /**
        * Add a "draw renderer" command.
        * @param renderer Renderer to draw.
        * @param material Material to use.
        * @param submeshIndex Which subset of the mesh to render.
        * @param shaderPass Which pass of the shader to use (default is -1, which renders all passes).
        * @methodSwap DrawRenderer_EBB7509C_H1C7EFC03
        */
        public DrawRenderer ($renderer: UnityEngine.Renderer, $material: UnityEngine.Material, $submeshIndex: int, $shaderPass: int) : void
        /**
        * Add a "draw renderer" command.
        * @param renderer Renderer to draw.
        * @param material Material to use.
        * @param submeshIndex Which subset of the mesh to render.
        * @param shaderPass Which pass of the shader to use (default is -1, which renders all passes).
        * @methodSwap DrawRenderer_EBB7509C_E2447CB0
        */
        public DrawRenderer ($renderer: UnityEngine.Renderer, $material: UnityEngine.Material, $submeshIndex: int) : void
        /**
        * Add a "draw renderer" command.
        * @param renderer Renderer to draw.
        * @param material Material to use.
        * @param submeshIndex Which subset of the mesh to render.
        * @param shaderPass Which pass of the shader to use (default is -1, which renders all passes).
        */
        public DrawRenderer ($renderer: UnityEngine.Renderer, $material: UnityEngine.Material) : void
        /**
        * Adds a "draw renderer list" command.
        * @param rendererList The RendererList to draw.
        */
        public DrawRendererList ($rendererList: RendererList) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param vertexCount Vertex count to render.
        * @param instanceCount Instance count to render.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProcedural_EBB7509C_H508A86F5
        */
        public DrawProcedural ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $vertexCount: int, $instanceCount: int, $properties: UnityEngine.MaterialPropertyBlock) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param vertexCount Vertex count to render.
        * @param instanceCount Instance count to render.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProcedural_EBB7509C_FEC1A56B
        */
        public DrawProcedural ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $vertexCount: int, $instanceCount: int) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param vertexCount Vertex count to render.
        * @param instanceCount Instance count to render.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProcedural_EBB7509C_H378D4A38
        */
        public DrawProcedural ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $vertexCount: int) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param indexCount Index count to render.
        * @param instanceCount Instance count to render.
        * @param indexBuffer The index buffer used to submit vertices to the GPU.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProcedural_EBB7509C_H8A4B409
        */
        public DrawProcedural ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $indexCount: int, $instanceCount: int, $properties: UnityEngine.MaterialPropertyBlock) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param indexCount Index count to render.
        * @param instanceCount Instance count to render.
        * @param indexBuffer The index buffer used to submit vertices to the GPU.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProcedural_EBB7509C_H8EC5488F
        */
        public DrawProcedural ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $indexCount: int, $instanceCount: int) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param indexCount Index count to render.
        * @param instanceCount Instance count to render.
        * @param indexBuffer The index buffer used to submit vertices to the GPU.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProcedural_EBB7509C_F2EC194
        */
        public DrawProcedural ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $indexCount: int) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @methodSwap DrawProceduralIndirect_EBB7509C_FC34CA5C
        */
        public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: int, $properties: UnityEngine.MaterialPropertyBlock) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H6B6702BC
        */
        public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: int) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @methodSwap DrawProceduralIndirect_EBB7509C_DD4BCA5B
        */
        public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H406A22D8
        */
        public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: int, $properties: UnityEngine.MaterialPropertyBlock) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H2D34B538
        */
        public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: int) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProceduralIndirect_EBB7509C_F474CD3F
        */
        public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H4A51E590
        */
        public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: int, $properties: UnityEngine.MaterialPropertyBlock) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H46711EE0
        */
        public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: int) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H9C9E32A7
        */
        public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H208EF184
        */
        public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: int, $properties: UnityEngine.MaterialPropertyBlock) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H1B556C14
        */
        public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: int) : void
        /**
        * Add a "draw procedural geometry" command.
        * @param indexBuffer Index buffer used to submit vertices to the GPU.
        * @param matrix Transformation matrix to use.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use (or -1 for all passes).
        * @param topology Topology of the procedural geometry.
        * @param bufferWithArgs Buffer with draw arguments.
        * @param argsOffset Byte offset where in the buffer the draw arguments are.
        * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
        * @methodSwap DrawProceduralIndirect_EBB7509C_H25EE7D3
        */
        public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: int, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer) : void
        /**
        * Adds a "draw mesh with instancing" command.
        * The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows.
        * The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.
        * InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
        * @param matrices The array of object transformation matrices.
        * @param count The number of instances to be drawn.
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @methodSwap DrawMeshInstanced_EBB7509C_D6B86C76
        */
        public DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: int, $material: UnityEngine.Material, $shaderPass: int, $matrices: UnityEngine.Matrix4x4[], $count: int, $properties: UnityEngine.MaterialPropertyBlock) : void
        /**
        * Adds a "draw mesh with instancing" command.
        * The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows.
        * The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.
        * InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
        * @param matrices The array of object transformation matrices.
        * @param count The number of instances to be drawn.
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @methodSwap DrawMeshInstanced_EBB7509C_H18DC3156
        */
        public DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: int, $material: UnityEngine.Material, $shaderPass: int, $matrices: UnityEngine.Matrix4x4[], $count: int) : void
        /**
        * Adds a "draw mesh with instancing" command.
        * The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows.
        * The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.
        * InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
        * @param matrices The array of object transformation matrices.
        * @param count The number of instances to be drawn.
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @methodSwap DrawMeshInstanced_EBB7509C_H5DA8F8F5
        */
        public DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: int, $material: UnityEngine.Material, $shaderPass: int, $matrices: UnityEngine.Matrix4x4[]) : void
        /**
        * Add a "draw mesh with instancing" command.
        * Draw a mesh using Procedural Instancing. This is similar to Graphics.DrawMeshInstancedIndirect, except that when the instance count is known from script, it can be supplied directly using this method, rather than via a ComputeBuffer.
        * If Material.enableInstancing is false, the command logs an error and skips rendering each time the command is executed; the command does not immediately fail and throw an exception.
        * InvalidOperationException will be thrown if the current platform doesn't support this API (for example, if GPU instancing is not available). See SystemInfo.supportsInstancing.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
        * @param count The number of instances to be drawn.
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        */
        public DrawMeshInstancedProcedural ($mesh: UnityEngine.Mesh, $submeshIndex: int, $material: UnityEngine.Material, $shaderPass: int, $count: int, $properties?: UnityEngine.MaterialPropertyBlock) : void
        /**
        * Add a "draw mesh with indirect instancing" command.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
        * @param argsOffset The byte offset into the buffer, where the draw arguments start.
        * @methodSwap DrawMeshInstancedIndirect_EBB7509C_H54034886
        */
        public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: int, $material: UnityEngine.Material, $shaderPass: int, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: int, $properties: UnityEngine.MaterialPropertyBlock) : void
        /**
        * Add a "draw mesh with indirect instancing" command.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
        * @param argsOffset The byte offset into the buffer, where the draw arguments start.
        * @methodSwap DrawMeshInstancedIndirect_EBB7509C_D1115F66
        */
        public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: int, $material: UnityEngine.Material, $shaderPass: int, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: int) : void
        /**
        * Add a "draw mesh with indirect instancing" command.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
        * @param argsOffset The byte offset into the buffer, where the draw arguments start.
        * @methodSwap DrawMeshInstancedIndirect_EBB7509C_H1A880F25
        */
        public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: int, $material: UnityEngine.Material, $shaderPass: int, $bufferWithArgs: UnityEngine.ComputeBuffer) : void
        /**
        * Add a "draw mesh with indirect instancing" command.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
        * @param argsOffset The byte offset into the buffer, where the draw arguments start.
        * @methodSwap DrawMeshInstancedIndirect_EBB7509C_H2AEBAD6
        */
        public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: int, $material: UnityEngine.Material, $shaderPass: int, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: int, $properties: UnityEngine.MaterialPropertyBlock) : void
        /**
        * Add a "draw mesh with indirect instancing" command.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
        * @param argsOffset The byte offset into the buffer, where the draw arguments start.
        * @methodSwap DrawMeshInstancedIndirect_EBB7509C_A19AAFF6
        */
        public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: int, $material: UnityEngine.Material, $shaderPass: int, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: int) : void
        /**
        * Add a "draw mesh with indirect instancing" command.
        * @param mesh The Mesh to draw.
        * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
        * @param material Material to use.
        * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
        * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
        * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
        * @param argsOffset The byte offset into the buffer, where the draw arguments start.
        * @methodSwap DrawMeshInstancedIndirect_EBB7509C_D83CEB95
        */
        public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: int, $material: UnityEngine.Material, $shaderPass: int, $bufferWithArgs: UnityEngine.GraphicsBuffer) : void
        /**
        * Adds a command onto the commandbuffer to draw the VR Device's occlusion mesh to the current render target.
        * @param normalizedCamViewport The viewport of the camera currently being rendered.
        */
        public DrawOcclusionMesh ($normalizedCamViewport: UnityEngine.RectInt) : void
        /**
        * Set random write target for level pixel shaders.
        * @param index Index of the random write target in the shader.
        * @param buffer Buffer to set as the write target.
        * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
        * @param rt RenderTargetIdentifier to set as the write target.
        * @methodSwap SetRandomWriteTarget_EBB7509C_H1BB1BC41
        */
        public SetRandomWriteTarget ($index: int, $rt: RenderTargetIdentifier) : void
        /**
        * Set random write target for level pixel shaders.
        * @param index Index of the random write target in the shader.
        * @param buffer Buffer to set as the write target.
        * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
        * @param rt RenderTargetIdentifier to set as the write target.
        * @methodSwap SetRandomWriteTarget_EBB7509C_EF0A05BB
        */
        public SetRandomWriteTarget ($index: int, $buffer: UnityEngine.ComputeBuffer, $preserveCounterValue: boolean) : void
        /**
        * Set random write target for level pixel shaders.
        * @param index Index of the random write target in the shader.
        * @param buffer Buffer to set as the write target.
        * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
        * @param rt RenderTargetIdentifier to set as the write target.
        * @methodSwap SetRandomWriteTarget_EBB7509C_E83D65D0
        */
        public SetRandomWriteTarget ($index: int, $buffer: UnityEngine.ComputeBuffer) : void
        /**
        * Set random write target for level pixel shaders.
        * @param index Index of the random write target in the shader.
        * @param buffer Buffer to set as the write target.
        * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
        * @param rt RenderTargetIdentifier to set as the write target.
        * @methodSwap SetRandomWriteTarget_EBB7509C_F29C30D5
        */
        public SetRandomWriteTarget ($index: int, $buffer: UnityEngine.GraphicsBuffer, $preserveCounterValue: boolean) : void
        /**
        * Set random write target for level pixel shaders.
        * @param index Index of the random write target in the shader.
        * @param buffer Buffer to set as the write target.
        * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
        * @param rt RenderTargetIdentifier to set as the write target.
        * @methodSwap SetRandomWriteTarget_EBB7509C_EA6F5EB6
        */
        public SetRandomWriteTarget ($index: int, $buffer: UnityEngine.GraphicsBuffer) : void
        /**
        * Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
        * @param src Append/consume buffer to copy the counter from.
        * @param dst A buffer to copy the counter to.
        * @param dstOffsetBytes Target byte offset in dst buffer.
        * @methodSwap CopyCounterValue_EBB7509C_A4712F23
        */
        public CopyCounterValue ($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: uint) : void
        /**
        * Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
        * @param src Append/consume buffer to copy the counter from.
        * @param dst A buffer to copy the counter to.
        * @param dstOffsetBytes Target byte offset in dst buffer.
        * @methodSwap CopyCounterValue_EBB7509C_D6AA8E13
        */
        public CopyCounterValue ($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: uint) : void
        /**
        * Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
        * @param src Append/consume buffer to copy the counter from.
        * @param dst A buffer to copy the counter to.
        * @param dstOffsetBytes Target byte offset in dst buffer.
        * @methodSwap CopyCounterValue_EBB7509C_A1BA0C5B
        */
        public CopyCounterValue ($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: uint) : void
        /**
        * Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
        * @param src Append/consume buffer to copy the counter from.
        * @param dst A buffer to copy the counter to.
        * @param dstOffsetBytes Target byte offset in dst buffer.
        * @methodSwap CopyCounterValue_EBB7509C_D5A90DEB
        */
        public CopyCounterValue ($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: uint) : void
        /**
        * Adds a command to copy pixel data from one texture to another.
        * @param src The source texture or RenderTargetIdentifier.
        * @param dst The destination texture or RenderTargetIdentifier.
        * @param srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
        * @param srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
        * @param dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
        * @param srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
        * @param srcWidth The width of src to copy.
        * @param srcHeight The height of src to copy.
        * @param dstX The x coordinate of dst to copy to.
        * @param dstY The y coordinate to dst to copy to.
        */
        public CopyTexture ($src: RenderTargetIdentifier, $dst: RenderTargetIdentifier) : void
        /**
        * Adds a command to copy pixel data from one texture to another.
        * @param src The source texture or RenderTargetIdentifier.
        * @param dst The destination texture or RenderTargetIdentifier.
        * @param srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
        * @param srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
        * @param dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
        * @param srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
        * @param srcWidth The width of src to copy.
        * @param srcHeight The height of src to copy.
        * @param dstX The x coordinate of dst to copy to.
        * @param dstY The y coordinate to dst to copy to.
        * @methodSwap CopyTexture_EBB7509C_H669624B1
        */
        public CopyTexture ($src: RenderTargetIdentifier, $srcElement: int, $dst: RenderTargetIdentifier, $dstElement: int) : void
        /**
        * Adds a command to copy pixel data from one texture to another.
        * @param src The source texture or RenderTargetIdentifier.
        * @param dst The destination texture or RenderTargetIdentifier.
        * @param srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
        * @param srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
        * @param dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
        * @param srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
        * @param srcWidth The width of src to copy.
        * @param srcHeight The height of src to copy.
        * @param dstX The x coordinate of dst to copy to.
        * @param dstY The y coordinate to dst to copy to.
        * @methodSwap CopyTexture_EBB7509C_H73D897DD
        */
        public CopyTexture ($src: RenderTargetIdentifier, $srcElement: int, $srcMip: int, $dst: RenderTargetIdentifier, $dstElement: int, $dstMip: int) : void
        /**
        * Adds a command to copy pixel data from one texture to another.
        * @param src The source texture or RenderTargetIdentifier.
        * @param dst The destination texture or RenderTargetIdentifier.
        * @param srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
        * @param srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
        * @param dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
        * @param srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
        * @param srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
        * @param srcWidth The width of src to copy.
        * @param srcHeight The height of src to copy.
        * @param dstX The x coordinate of dst to copy to.
        * @param dstY The y coordinate to dst to copy to.
        * @methodSwap CopyTexture_EBB7509C_H4B246349
        */
        public CopyTexture ($src: RenderTargetIdentifier, $srcElement: int, $srcMip: int, $srcX: int, $srcY: int, $srcWidth: int, $srcHeight: int, $dst: RenderTargetIdentifier, $dstElement: int, $dstMip: int, $dstX: int, $dstY: int) : void
        /**
        * Adds a command to use a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture or RenderTargetIdentifier.
        * @param dest The destination RenderTargetIdentifier.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        */
        public Blit ($source: UnityEngine.Texture, $dest: RenderTargetIdentifier) : void
        /**
        * Adds a command to use a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture or RenderTargetIdentifier.
        * @param dest The destination RenderTargetIdentifier.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        */
        public Blit ($source: UnityEngine.Texture, $dest: RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2) : void
        /**
        * Adds a command to use a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture or RenderTargetIdentifier.
        * @param dest The destination RenderTargetIdentifier.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        */
        public Blit ($source: UnityEngine.Texture, $dest: RenderTargetIdentifier, $mat: UnityEngine.Material) : void
        /**
        * Adds a command to use a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture or RenderTargetIdentifier.
        * @param dest The destination RenderTargetIdentifier.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        * @methodSwap Blit_EBB7509C_H80691737
        */
        public Blit ($source: UnityEngine.Texture, $dest: RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: int) : void
        /**
        * Adds a command to use a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture or RenderTargetIdentifier.
        * @param dest The destination RenderTargetIdentifier.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        */
        public Blit ($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier) : void
        /**
        * Adds a command to use a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture or RenderTargetIdentifier.
        * @param dest The destination RenderTargetIdentifier.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        */
        public Blit ($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2) : void
        /**
        * Adds a command to use a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture or RenderTargetIdentifier.
        * @param dest The destination RenderTargetIdentifier.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        */
        public Blit ($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $mat: UnityEngine.Material) : void
        /**
        * Adds a command to use a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture or RenderTargetIdentifier.
        * @param dest The destination RenderTargetIdentifier.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        * @methodSwap Blit_EBB7509C_AA0D58F4
        */
        public Blit ($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: int) : void
        /**
        * Adds a command to use a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture or RenderTargetIdentifier.
        * @param dest The destination RenderTargetIdentifier.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        * @methodSwap Blit_EBB7509C_H1DC26F69
        */
        public Blit ($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $sourceDepthSlice: int, $destDepthSlice: int) : void
        /**
        * Adds a command to use a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture or RenderTargetIdentifier.
        * @param dest The destination RenderTargetIdentifier.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        * @methodSwap Blit_EBB7509C_H5DD68569
        */
        public Blit ($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2, $sourceDepthSlice: int, $destDepthSlice: int) : void
        /**
        * Adds a command to use a shader to copy the pixel data from a texture into a render texture.
        * @param source The source texture or RenderTargetIdentifier.
        * @param dest The destination RenderTargetIdentifier.
        * @param mat The material to use. If you don't provide mat, Unity uses a default material.
        * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
        * @param scale The scale to apply.
        * @param offset The offset to apply.
        * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
        * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
        * @methodSwap Blit_EBB7509C_BC3578EF
        */
        public Blit ($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: int, $destDepthSlice: int) : void
        /**
        * Add a "set global shader float property" command.
        * @methodSwap SetGlobalFloat_EBB7509C_H45FF9778
        */
        public SetGlobalFloat ($name: string, $value: float) : void
        /**
        * Adds a command to set the value of a given property for all Shaders, where the property has a type of Int in ShaderLab code.
        * @methodSwap SetGlobalInt_EBB7509C_H72D17FE0
        */
        public SetGlobalInt ($name: string, $value: int) : void
        /**
        * Adds a command to set the value of a given property for all Shaders, where the property is an integer.
        * @methodSwap SetGlobalInteger_EBB7509C_H72D17FE0
        */
        public SetGlobalInteger ($name: string, $value: int) : void
        /**
        * Add a "set global shader vector property" command.
        */
        public SetGlobalVector ($name: string, $value: UnityEngine.Vector4) : void
        /**
        * Add a "set global shader color property" command.
        */
        public SetGlobalColor ($name: string, $value: UnityEngine.Color) : void
        /**
        * Add a "set global shader matrix property" command.
        */
        public SetGlobalMatrix ($name: string, $value: UnityEngine.Matrix4x4) : void
        public SetGlobalFloatArray ($propertyName: string, $values: System_Collections_Generic.List$1<float>) : void
        /**
        * @methodSwap SetGlobalFloatArray_EBB7509C_E8859065
        */
        public SetGlobalFloatArray ($nameID: int, $values: System_Collections_Generic.List$1<float>) : void
        /**
        * Add a "set global shader float array property" command.
        */
        public SetGlobalFloatArray ($propertyName: string, $values: float[]) : void
        public SetGlobalVectorArray ($propertyName: string, $values: System_Collections_Generic.List$1<UnityEngine.Vector4>) : void
        /**
        * @methodSwap SetGlobalVectorArray_EBB7509C_H5C64F93A
        */
        public SetGlobalVectorArray ($nameID: int, $values: System_Collections_Generic.List$1<UnityEngine.Vector4>) : void
        /**
        * Add a "set global shader vector array property" command.
        */
        public SetGlobalVectorArray ($propertyName: string, $values: UnityEngine.Vector4[]) : void
        public SetGlobalMatrixArray ($propertyName: string, $values: System_Collections_Generic.List$1<UnityEngine.Matrix4x4>) : void
        /**
        * @methodSwap SetGlobalMatrixArray_EBB7509C_H73E77D48
        */
        public SetGlobalMatrixArray ($nameID: int, $values: System_Collections_Generic.List$1<UnityEngine.Matrix4x4>) : void
        /**
        * Add a "set global shader matrix array property" command.
        */
        public SetGlobalMatrixArray ($propertyName: string, $values: UnityEngine.Matrix4x4[]) : void
        /**
        * Add a "set global shader texture property" command, referencing a RenderTexture.
        */
        public SetGlobalTexture ($name: string, $value: RenderTargetIdentifier) : void
        /**
        * Add a "set global shader texture property" command, referencing a RenderTexture.
        * @methodSwap SetGlobalTexture_EBB7509C_H1BB1BC41
        */
        public SetGlobalTexture ($nameID: int, $value: RenderTargetIdentifier) : void
        /**
        * Add a "set global shader texture property" command, referencing a RenderTexture.
        */
        public SetGlobalTexture ($name: string, $value: RenderTargetIdentifier, $element: RenderTextureSubElement) : void
        /**
        * Add a "set global shader texture property" command, referencing a RenderTexture.
        * @methodSwap SetGlobalTexture_EBB7509C_DBF1D525
        */
        public SetGlobalTexture ($nameID: int, $value: RenderTargetIdentifier, $element: RenderTextureSubElement) : void
        /**
        * Add a "set global shader buffer property" command.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The buffer to set.
        */
        public SetGlobalBuffer ($name: string, $value: UnityEngine.ComputeBuffer) : void
        /**
        * Add a "set global shader buffer property" command.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The buffer to set.
        * @methodSwap SetGlobalBuffer_EBB7509C_E83D65D0
        */
        public SetGlobalBuffer ($nameID: int, $value: UnityEngine.ComputeBuffer) : void
        /**
        * Add a "set global shader buffer property" command.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The buffer to set.
        */
        public SetGlobalBuffer ($name: string, $value: UnityEngine.GraphicsBuffer) : void
        /**
        * Add a "set global shader buffer property" command.
        * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
        * @param name The name of the property.
        * @param value The buffer to set.
        * @methodSwap SetGlobalBuffer_EBB7509C_EA6F5EB6
        */
        public SetGlobalBuffer ($nameID: int, $value: UnityEngine.GraphicsBuffer) : void
        /**
        * Add a command to bind a global constant buffer.
        * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
        * @param name The name of the constant buffer to override.
        * @param buffer The buffer to bind.
        * @param offset Offset from the start of the buffer in bytes.
        * @param size Size in bytes of the area to bind.
        * @methodSwap SetGlobalConstantBuffer_EBB7509C_H44C1D9E2
        */
        public SetGlobalConstantBuffer ($buffer: UnityEngine.ComputeBuffer, $nameID: int, $offset: int, $size: int) : void
        /**
        * Add a command to bind a global constant buffer.
        * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
        * @param name The name of the constant buffer to override.
        * @param buffer The buffer to bind.
        * @param offset Offset from the start of the buffer in bytes.
        * @param size Size in bytes of the area to bind.
        * @methodSwap SetGlobalConstantBuffer_EBB7509C_H548DC36F
        */
        public SetGlobalConstantBuffer ($buffer: UnityEngine.ComputeBuffer, $name: string, $offset: int, $size: int) : void
        /**
        * Add a command to bind a global constant buffer.
        * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
        * @param name The name of the constant buffer to override.
        * @param buffer The buffer to bind.
        * @param offset Offset from the start of the buffer in bytes.
        * @param size Size in bytes of the area to bind.
        * @methodSwap SetGlobalConstantBuffer_EBB7509C_H6F3BF8F2
        */
        public SetGlobalConstantBuffer ($buffer: UnityEngine.GraphicsBuffer, $nameID: int, $offset: int, $size: int) : void
        /**
        * Add a command to bind a global constant buffer.
        * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
        * @param name The name of the constant buffer to override.
        * @param buffer The buffer to bind.
        * @param offset Offset from the start of the buffer in bytes.
        * @param size Size in bytes of the area to bind.
        * @methodSwap SetGlobalConstantBuffer_EBB7509C_H34C0C9F
        */
        public SetGlobalConstantBuffer ($buffer: UnityEngine.GraphicsBuffer, $name: string, $offset: int, $size: int) : void
        /**
        * Add a "set shadow sampling mode" command.
        * @param shadowmap Shadowmap render target to change the sampling mode on.
        * @param mode New sampling mode.
        */
        public SetShadowSamplingMode ($shadowmap: RenderTargetIdentifier, $mode: ShadowSamplingMode) : void
        public SetSinglePassStereo ($mode: SinglePassStereoMode) : void
        /**
        * Send a user-defined event to a native code plugin.
        * @param callback Native code callback to queue for Unity's renderer to invoke.
        * @param eventID User defined id to send to the callback.
        */
        public IssuePluginEvent ($callback: System.IntPtr, $eventID: int) : void
        /**
        * Send a user-defined event to a native code plugin with custom data.
        * @param callback Native code callback to queue for Unity's renderer to invoke.
        * @param data Custom data to pass to the native plugin callback.
        * @param eventID Built in or user defined id to send to the callback.
        */
        public IssuePluginEventAndData ($callback: System.IntPtr, $eventID: int, $data: System.IntPtr) : void
        /**
        * Send a user-defined event to a native code plugin with custom data and callback flags.
        * @param callback Native code callback to queue for Unity's renderer to invoke.
        * @param eventID Built in or user defined id to send to the callback.
        * @param flags See CustomMarkerCallbackFlags for more details.
        * @param data Custom data to pass to the native plugin callback.
        */
        public IssuePluginEventAndDataWithFlags ($callback: System.IntPtr, $eventID: int, $flags: CustomMarkerCallbackFlags, $data: System.IntPtr) : void
        /**
        * Send a user-defined blit event to a native code plugin.
        * @param callback Native code callback to queue for Unity's renderer to invoke.
        * @param command User defined command id to send to the callback.
        * @param source Source render target.
        * @param dest Destination render target.
        * @param commandParam User data command parameters.
        * @param commandFlags User data command flags.
        */
        public IssuePluginCustomBlit ($callback: System.IntPtr, $command: uint, $source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $commandParam: uint, $commandFlags: uint) : void
        /**
        * Send a texture update event to a native code plugin.
        * @param callback Native code callback to queue for Unity's renderer to invoke.
        * @param targetTexture Texture resource to be updated.
        * @param userData User data to send to the native plugin.
        */
        public IssuePluginCustomTextureUpdateV2 ($callback: System.IntPtr, $targetTexture: UnityEngine.Texture, $userData: uint) : void
        public ProcessVTFeedback ($rt: RenderTargetIdentifier, $resolver: System.IntPtr, $slice: int, $x: int, $width: int, $y: int, $height: int, $mip: int) : void
        /**
        * Adds a command to copy the contents of one GraphicsBuffer into another.
        * @param source The source buffer.
        * @param dest The destination buffer.
        */
        public CopyBuffer ($source: UnityEngine.GraphicsBuffer, $dest: UnityEngine.GraphicsBuffer) : void
    }

    /**
    * Identifies a RenderTexture for a Rendering.CommandBuffer.
    */
    class RenderTargetIdentifier extends System.ValueType implements System.IEquatable$1<RenderTargetIdentifier> {

        /**
        * All depth-slices of the render resource are bound for rendering. For textures which are neither array nor 3D, the default slice is bound.
        */
        public static AllDepthSlices : int

        /**
        * Creates a render target identifier.
        * @param type Built-in temporary render texture type.
        * @param name Temporary render texture name.
        * @param nameID Temporary render texture name (as integer, see Shader.PropertyToID).
        * @param tex RenderTexture or Texture object to use.
        * @param mipLevel MipLevel of the RenderTexture to use.
        * @param cubemapFace Cubemap face of the Cubemap RenderTexture to use.
        * @param depthSlice Depth slice of the Array RenderTexture to use. The symbolic constant RenderTargetIdentifier.AllDepthSlices indicates that all slices should be bound for rendering. The default value is 0.
        * @param renderTargetIdentifier An existing render target identifier.
        */
        public constructor ($type: BuiltinRenderTextureType)
        public constructor ($type: BuiltinRenderTextureType, $mipLevel?: int, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: int)
        /**
        * Creates a render target identifier.
        * @param type Built-in temporary render texture type.
        * @param name Temporary render texture name.
        * @param nameID Temporary render texture name (as integer, see Shader.PropertyToID).
        * @param tex RenderTexture or Texture object to use.
        * @param mipLevel MipLevel of the RenderTexture to use.
        * @param cubemapFace Cubemap face of the Cubemap RenderTexture to use.
        * @param depthSlice Depth slice of the Array RenderTexture to use. The symbolic constant RenderTargetIdentifier.AllDepthSlices indicates that all slices should be bound for rendering. The default value is 0.
        * @param renderTargetIdentifier An existing render target identifier.
        */
        public constructor ($name: string)
        public constructor ($name: string, $mipLevel?: int, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: int)
        /**
        * Creates a render target identifier.
        * @param type Built-in temporary render texture type.
        * @param name Temporary render texture name.
        * @param nameID Temporary render texture name (as integer, see Shader.PropertyToID).
        * @param tex RenderTexture or Texture object to use.
        * @param mipLevel MipLevel of the RenderTexture to use.
        * @param cubemapFace Cubemap face of the Cubemap RenderTexture to use.
        * @param depthSlice Depth slice of the Array RenderTexture to use. The symbolic constant RenderTargetIdentifier.AllDepthSlices indicates that all slices should be bound for rendering. The default value is 0.
        * @param renderTargetIdentifier An existing render target identifier.
        */
        public constructor ($nameID: int)
        public constructor ($nameID: int, $mipLevel?: int, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: int)
        /**
        * Creates a render target identifier.
        * @param type Built-in temporary render texture type.
        * @param name Temporary render texture name.
        * @param nameID Temporary render texture name (as integer, see Shader.PropertyToID).
        * @param tex RenderTexture or Texture object to use.
        * @param mipLevel MipLevel of the RenderTexture to use.
        * @param cubemapFace Cubemap face of the Cubemap RenderTexture to use.
        * @param depthSlice Depth slice of the Array RenderTexture to use. The symbolic constant RenderTargetIdentifier.AllDepthSlices indicates that all slices should be bound for rendering. The default value is 0.
        * @param renderTargetIdentifier An existing render target identifier.
        */
        public constructor ($renderTargetIdentifier: RenderTargetIdentifier, $mipLevel: int, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: int)
        /**
        * Creates a render target identifier.
        * @param type Built-in temporary render texture type.
        * @param name Temporary render texture name.
        * @param nameID Temporary render texture name (as integer, see Shader.PropertyToID).
        * @param tex RenderTexture or Texture object to use.
        * @param mipLevel MipLevel of the RenderTexture to use.
        * @param cubemapFace Cubemap face of the Cubemap RenderTexture to use.
        * @param depthSlice Depth slice of the Array RenderTexture to use. The symbolic constant RenderTargetIdentifier.AllDepthSlices indicates that all slices should be bound for rendering. The default value is 0.
        * @param renderTargetIdentifier An existing render target identifier.
        */
        public constructor ($tex: UnityEngine.Texture)
        public constructor ($tex: UnityEngine.Texture, $mipLevel?: int, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: int)
        public constructor ($buf: UnityEngine.RenderBuffer, $mipLevel?: int, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: int)
        public ToString () : string
        public GetHashCode () : int
        public Equals ($rhs: RenderTargetIdentifier) : boolean
        public Equals ($obj: any) : boolean
        public static op_Implicit ($type: BuiltinRenderTextureType) : RenderTargetIdentifier
        public static op_Implicit ($name: string) : RenderTargetIdentifier
        public static op_Implicit ($nameID: int) : RenderTargetIdentifier
        public static op_Implicit ($tex: UnityEngine.Texture) : RenderTargetIdentifier
        public static op_Implicit ($buf: UnityEngine.RenderBuffer) : RenderTargetIdentifier
        public static op_Equality ($lhs: RenderTargetIdentifier, $rhs: RenderTargetIdentifier) : boolean
        public static op_Inequality ($lhs: RenderTargetIdentifier, $rhs: RenderTargetIdentifier) : boolean
    }

    /**
    * Built-in temporary render textures produced during camera's rendering.
    */
    enum BuiltinRenderTextureType {
        PropertyName = -4,
        BufferPtr = -3,
        RenderTexture = -2,
        BindableTexture = -1,
        None = 0,
        CurrentActive = 1,
        CameraTarget = 2,
        Depth = 3,
        DepthNormals = 4,
        ResolvedDepth = 5,
        PrepassNormalsSpec = 7,
        PrepassLight = 8,
        PrepassLightSpec = 9,
        GBuffer0 = 10,
        GBuffer1 = 11,
        GBuffer2 = 12,
        GBuffer3 = 13,
        Reflections = 14,
        MotionVectors = 15,
        GBuffer4 = 16,
        GBuffer5 = 17,
        GBuffer6 = 18,
        GBuffer7 = 19 
    }

    /**
    * Represents an asynchronous request for a GPU resource.
    */
    class AsyncGPUReadbackRequest extends System.ValueType {

        /**
        * Checks whether the request has been processed.
        */
        public get done(): boolean;
        /**
        * This property is true if the request has encountered an error.
        */
        public get hasError(): boolean;
        /**
        * Number of layers in the current request.
        */
        public get layerCount(): int;
        /**
        * The size in bytes of one layer of the readback data.
        */
        public get layerDataSize(): int;
        /**
        * The width of the requested GPU data.
        */
        public get width(): int;
        /**
        * When reading data from a ComputeBuffer, height is 1, otherwise, the property takes the value of the requested height from the texture.
        */
        public get height(): int;
        /**
        * When reading data from a ComputeBuffer, depth is 1, otherwise, the property takes the value of the requested depth from the texture.
        */
        public get depth(): int;
        /**
        * In the Editor, defines whether the Player loop is updated while the GPU request is in flight.
        */
        public get forcePlayerLoopUpdate(): boolean;
        public set forcePlayerLoopUpdate(value: boolean);

        /**
        * Triggers an update of the request.
        */
        public Update () : void
        /**
        * Waits for completion of the request.
        */
        public WaitForCompletion () : void
        /**
        * Fetches the data of a successful request.
        * @param layer The index of the layer to retrieve.
        */
        public GetData<T> ($layer?: int) : Unity_Collections.NativeArray$1<T>
    }

    /**
    * Flags that determine which render targets Unity clears when you use CommandBuffer.ClearRenderTarget.
    */
    enum RTClearFlags {
        None = 0,
        Color = 1,
        Depth = 2,
        Stencil = 4,
        All = 7,
        DepthStencil = 6,
        ColorDepth = 3,
        ColorStencil = 5 
    }

    /**
    * Flags describing the intention for how the command buffer will be executed. Set these via CommandBuffer.SetExecutionFlags.
    */
    enum CommandBufferExecutionFlags {
        None = 0,
        AsyncCompute = 2 
    }

    /**
    * The types of camera matrices that support late latching.
    */
    enum CameraLateLatchMatrixType {
        View = 0,
        InverseView = 1,
        ViewProjection = 2,
        InverseViewProjection = 3 
    }

    /**
    * Operation mode for the foveated rendering system.
    */
    enum FoveatedRenderingMode {
        Disabled = 0,
        Enabled = 1 
    }

    /**
    * This enum describes what should be done on the render target when it is activated (loaded).
    */
    enum RenderBufferLoadAction {
        Load = 0,
        Clear = 1,
        DontCare = 2 
    }

    /**
    * This enum describes what should be done on the render target when the GPU is done rendering into it.
    */
    enum RenderBufferStoreAction {
        Store = 0,
        Resolve = 1,
        StoreAndResolve = 2,
        DontCare = 3 
    }

    /**
    * Describes a render target with one or more color buffers, a depthstencil buffer and the associated loadstore-actions that are applied when the render target is active.
    */
    class RenderTargetBinding extends System.ValueType {

        /**
        * Color buffers to use as render targets.
        */
        public get colorRenderTargets(): RenderTargetIdentifier[];
        public set colorRenderTargets(value: RenderTargetIdentifier[]);
        /**
        * Depth/stencil buffer to use as render target.
        */
        public get depthRenderTarget(): RenderTargetIdentifier;
        public set depthRenderTarget(value: RenderTargetIdentifier);
        /**
        * Load actions for color buffers.
        */
        public get colorLoadActions(): RenderBufferLoadAction[];
        public set colorLoadActions(value: RenderBufferLoadAction[]);
        /**
        * Store actions for color buffers.
        */
        public get colorStoreActions(): RenderBufferStoreAction[];
        public set colorStoreActions(value: RenderBufferStoreAction[]);
        /**
        * Load action for the depth/stencil buffer.
        */
        public get depthLoadAction(): RenderBufferLoadAction;
        public set depthLoadAction(value: RenderBufferLoadAction);
        /**
        * Store action for the depth/stencil buffer.
        */
        public get depthStoreAction(): RenderBufferStoreAction;
        public set depthStoreAction(value: RenderBufferStoreAction);
        /**
        * Optional flags.
        */
        public get flags(): RenderTargetFlags;
        public set flags(value: RenderTargetFlags);

        /**
        * Constructs RenderTargetBinding.
        * @param color Color buffers to use as render targets.
        * @param depth Depth buffer to use as render target.
        * @param colorLoadAction Load actions for color buffers.
        * @param colorStoreAction Store actions for color buffers.
        * @param depthLoadAction Load action for the depth/stencil buffer.
        * @param depthStoreAction Store action for the depth/stencil buffer.
        */
        public constructor ($colorRenderTargets: RenderTargetIdentifier[], $colorLoadActions: RenderBufferLoadAction[], $colorStoreActions: RenderBufferStoreAction[], $depthRenderTarget: RenderTargetIdentifier, $depthLoadAction: RenderBufferLoadAction, $depthStoreAction: RenderBufferStoreAction)
        /**
        * Constructs RenderTargetBinding.
        * @param color Color buffers to use as render targets.
        * @param depth Depth buffer to use as render target.
        * @param colorLoadAction Load actions for color buffers.
        * @param colorStoreAction Store actions for color buffers.
        * @param depthLoadAction Load action for the depth/stencil buffer.
        * @param depthStoreAction Store action for the depth/stencil buffer.
        */
        public constructor ($colorRenderTarget: RenderTargetIdentifier, $colorLoadAction: RenderBufferLoadAction, $colorStoreAction: RenderBufferStoreAction, $depthRenderTarget: RenderTargetIdentifier, $depthLoadAction: RenderBufferLoadAction, $depthStoreAction: RenderBufferStoreAction)
        /**
        * Constructs RenderTargetBinding.
        * @param color Color buffers to use as render targets.
        * @param depth Depth buffer to use as render target.
        * @param colorLoadAction Load actions for color buffers.
        * @param colorStoreAction Store actions for color buffers.
        * @param depthLoadAction Load action for the depth/stencil buffer.
        * @param depthStoreAction Store action for the depth/stencil buffer.
        */
        public constructor ($setup: UnityEngine.RenderTargetSetup)
    }

    /**
    * This enum describes optional flags for the RenderTargetBinding structure.
    */
    enum RenderTargetFlags {
        None = 0,
        ReadOnlyDepth = 1,
        ReadOnlyStencil = 2,
        ReadOnlyDepthStencil = 3 
    }

    /**
    * Used to manage synchronisation between tasks on async compute queues and the graphics queue.
    */
    class GraphicsFence extends System.ValueType {

        /**
        * true if GPU execution has passed the processing point where you inserted the GraphicsFence, otherwise false.
        */
        public get passed(): boolean;

    }

    /**
    * The stages of the draw call processing on the GPU.
    */
    enum SynchronisationStage {
        VertexProcessing = 0,
        PixelProcessing = 1 
    }

    /**
    * The type of GraphicFence.
    */
    enum GraphicsFenceType {
        AsyncQueueSynchronisation = 0,
        CPUSynchronisation = 1 
    }

    /**
    * Describes the various stages of GPU processing against which the GraphicsFence can be set and waited against.
    */
    enum SynchronisationStageFlags {
        VertexProcessing = 1,
        PixelProcessing = 2,
        ComputeProcessing = 4,
        AllGPUOperations = 7 
    }

    /**
    * Format of the mesh index buffer data.
    */
    enum IndexFormat {
        UInt16 = 0,
        UInt32 = 1 
    }

    /**
    * Information about a single VertexAttribute of a Mesh vertex.
    */
    class VertexAttributeDescriptor extends System.ValueType implements System.IEquatable$1<VertexAttributeDescriptor> {

        /**
        * The vertex attribute.
        */
        public get attribute(): VertexAttribute;
        public set attribute(value: VertexAttribute);
        /**
        * Format of the vertex attribute.
        */
        public get format(): VertexAttributeFormat;
        public set format(value: VertexAttributeFormat);
        /**
        * Dimensionality of the vertex attribute.
        */
        public get dimension(): int;
        public set dimension(value: int);
        /**
        * Which vertex buffer stream the attribute should be in.
        */
        public get stream(): int;
        public set stream(value: int);

        /**
        * Create a VertexAttributeDescriptor structure.
        * @param attribute The VertexAttribute.
        * @param format Format of the vertex attribute. Default is VertexAttributeFormat.Float32.
        * @param dimension Dimensionality of the vertex attribute (1 to 4). Default is 3.
        * @param stream Vertex buffer stream that the attribute should be placed in. Default is 0.
        */
        public constructor ($attribute?: VertexAttribute, $format?: VertexAttributeFormat, $dimension?: int, $stream?: int)
        public ToString () : string
        public GetHashCode () : int
        public Equals ($other: any) : boolean
        public Equals ($other: VertexAttributeDescriptor) : boolean
        public static op_Equality ($lhs: VertexAttributeDescriptor, $rhs: VertexAttributeDescriptor) : boolean
        public static op_Inequality ($lhs: VertexAttributeDescriptor, $rhs: VertexAttributeDescriptor) : boolean
    }

    /**
    * Possible attribute types that describe a vertex in a Mesh.
    */
    enum VertexAttribute {
        Position = 0,
        Normal = 1,
        Tangent = 2,
        Color = 3,
        TexCoord0 = 4,
        TexCoord1 = 5,
        TexCoord2 = 6,
        TexCoord3 = 7,
        TexCoord4 = 8,
        TexCoord5 = 9,
        TexCoord6 = 10,
        TexCoord7 = 11,
        BlendWeight = 12,
        BlendIndices = 13 
    }

    /**
    * Data type of a VertexAttribute.
    */
    enum VertexAttributeFormat {
        Float32 = 0,
        Float16 = 1,
        UNorm8 = 2,
        SNorm8 = 3,
        UNorm16 = 4,
        SNorm16 = 5,
        UInt8 = 6,
        SInt8 = 7,
        UInt16 = 8,
        SInt16 = 9,
        UInt32 = 10,
        SInt32 = 11 
    }

    /**
    * Contains information about a single sub-mesh of a Mesh.
    */
    class SubMeshDescriptor extends System.ValueType {

        /**
        * Bounding box of vertices in local space.
        */
        public get bounds(): UnityEngine.Bounds;
        public set bounds(value: UnityEngine.Bounds);
        /**
        * Face topology of this sub-mesh.
        */
        public get topology(): UnityEngine.MeshTopology;
        public set topology(value: UnityEngine.MeshTopology);
        /**
        * Starting point inside the whole Mesh index buffer where the face index data is found.
        */
        public get indexStart(): int;
        public set indexStart(value: int);
        /**
        * Index count for this sub-mesh face data.
        */
        public get indexCount(): int;
        public set indexCount(value: int);
        /**
        * Offset that is added to each value in the index buffer, to compute the final vertex index.
        */
        public get baseVertex(): int;
        public set baseVertex(value: int);
        /**
        * First vertex in the index buffer for this sub-mesh.
        */
        public get firstVertex(): int;
        public set firstVertex(value: int);
        /**
        * Number of vertices used by the index buffer of this sub-mesh.
        */
        public get vertexCount(): int;
        public set vertexCount(value: int);

        /**
        * Create a submesh descriptor.
        * @param indexStart Initial value for indexStart field.
        * @param indexCount Initial value for indexCount field.
        * @param topology Initial value for topology field.
        */
        public constructor ($indexStart: int, $indexCount: int, $topology?: UnityEngine.MeshTopology)
        public ToString () : string
    }

    /**
    * Mesh data update flags.
    */
    enum MeshUpdateFlags {
        Default = 0,
        DontValidateIndices = 1,
        DontResetBoneBounds = 2,
        DontNotifyMeshUsers = 4,
        DontRecalculateBounds = 8 
    }

    /**
    * Determines the data that Unity returns when you call Mesh.GetBlendShapeBuffer.
    */
    enum BlendShapeBufferLayout {
        PerShape = 0,
        PerVertex = 1 
    }

    /**
    * Spherical harmonics up to the second order (3 bands, 9 coefficients).
    */
    class SphericalHarmonicsL2 extends System.ValueType implements System.IEquatable$1<SphericalHarmonicsL2> {

        /**
        * Clears the spherical harmonics coefficients to zero.
        */
        public Clear () : void
        /**
        * Add an ambient light to the spherical harmonics.
        */
        public AddAmbientLight ($color: UnityEngine.Color) : void
        /**
        * Add a directional light to the spherical harmonics.
        * @param direction The direction from the light probe to the light. The vector should be normalized for correct results.
        * @param color The color of the light.
        * @param intensity The intensity of the light.
        */
        public AddDirectionalLight ($direction: UnityEngine.Vector3, $color: UnityEngine.Color, $intensity: float) : void
        /**
        * Evaluates the spherical harmonics for each given direction. The directions and results arrays must have the same size.
        * @param directions Array of normalized directions in which to evaluate the spherical harmonics.
        * @param results Output array for the evaluated values. The order of the results is the same as the directions array.
        */
        public Evaluate ($directions: UnityEngine.Vector3[], $results: UnityEngine.Color[]) : void
        public GetHashCode () : int
        public Equals ($other: any) : boolean
        public Equals ($other: SphericalHarmonicsL2) : boolean
        /**
        * Scales SH by a given factor.
        * @methodSwap op_Multiply_EBB7509C_B6A3A888
        */
        public static op_Multiply ($lhs: SphericalHarmonicsL2, $rhs: float) : SphericalHarmonicsL2
        /**
        * Scales SH by a given factor.
        * @methodSwap op_Multiply_EBB7509C_H59471694
        */
        public static op_Multiply ($lhs: float, $rhs: SphericalHarmonicsL2) : SphericalHarmonicsL2
        public static op_Addition ($lhs: SphericalHarmonicsL2, $rhs: SphericalHarmonicsL2) : SphericalHarmonicsL2
        public static op_Equality ($lhs: SphericalHarmonicsL2, $rhs: SphericalHarmonicsL2) : boolean
        public static op_Inequality ($lhs: SphericalHarmonicsL2, $rhs: SphericalHarmonicsL2) : boolean
    }

    /**
    * ReflectionProbeBlendInfo contains information required for blending probes.
    */
    class ReflectionProbeBlendInfo extends System.ValueType {

        /**
        * Reflection Probe used in blending.
        */
        public probe : UnityEngine.ReflectionProbe
        /**
        * Specifies the weight used in the interpolation between two probes, value varies from 0.0 to 1.0.
        */
        public weight : float

    }

    /**
    * Values for ReflectionProbe.clearFlags, determining what to clear when rendering a ReflectionProbe.
    */
    enum ReflectionProbeClearFlags {
        Skybox = 1,
        SolidColor = 2 
    }

    /**
    * Reflection probe's update mode.
    */
    enum ReflectionProbeMode {
        Baked = 0,
        Realtime = 1,
        Custom = 2 
    }

    /**
    * An enum describing the way a real-time reflection probe refreshes in the Player.
    */
    enum ReflectionProbeRefreshMode {
        OnAwake = 0,
        EveryFrame = 1,
        ViaScripting = 2 
    }

    /**
    * When a probe's ReflectionProbe.refreshMode is set to ReflectionProbeRefreshMode.EveryFrame, this enum specify whether or not Unity should update the probe's cubemap over several frames or update the whole cubemap in one frame.
    * Updating a probe's cubemap is a costly operation. Unity needs to render the entire Scene for each face of the cubemap, as well as perform special blurring in order to get glossy reflections. The impact on frame rate can be significant. Time-slicing helps maintaning a more constant frame rate during these updates by performing the rendering over several frames.
    */
    enum ReflectionProbeTimeSlicingMode {
        AllFacesAtOnce = 0,
        IndividualFaces = 1,
        NoTimeSlicing = 2 
    }

    /**
    * How shadows are cast from this object.
    */
    enum ShadowCastingMode {
        Off = 0,
        On = 1,
        TwoSided = 2,
        ShadowsOnly = 3 
    }

    /**
    * Light probe interpolation type.
    */
    enum LightProbeUsage {
        Off = 0,
        BlendProbes = 1,
        UseProxyVolume = 2,
        CustomProvided = 4 
    }

    /**
    * Reflection Probe usage.
    */
    enum ReflectionProbeUsage {
        Off = 0,
        BlendProbes = 1,
        BlendProbesAndSkybox = 2,
        Simple = 3 
    }

    /**
    * Represents a set of visible GameObjects.
    */
    class RendererList extends System.ValueType {

        /**
        * Returns an empty RendererList.
        */
        public static nullRendererList : RendererList
        /**
        * Indicates whether the RendererList is valid or not. If the RendererList is valid, this returns true. Otherwise, this returns false.
        */
        public get isValid(): boolean;

    }

    /**
    * Enum type defines the different stereo rendering modes available.
    */
    enum SinglePassStereoMode {
        None = 0,
        SideBySide = 1,
        Instancing = 2,
        Multiview = 3 
    }

    /**
    * Flags that determine what custom events get called when native plugin callback is issued.
    */
    enum CustomMarkerCallbackFlags {
        CustomMarkerCallbackDefault = 0,
        CustomMarkerCallbackForceInvalidateStateTracking = 4 
    }

    /**
    * Describes the desired characteristics with respect to prioritisation and load balancing of the queue that a command buffer being submitted via Graphics.ExecuteCommandBufferAsync or [[ScriptableRenderContext.ExecuteCommandBufferAsync] should be sent to.
    */
    enum ComputeQueueType {
        Default = 0,
        Background = 1,
        Urgent = 2 
    }

    /**
    * Parameters that configure a culling operation in the Scriptable Render Pipeline.
    */
    class ScriptableCullingParameters extends System.ValueType implements System.IEquatable$1<ScriptableCullingParameters> {

        /**
        * Maximum amount of culling planes that can be specified.
        */
        public static maximumCullingPlaneCount : int
        /**
        * The amount of layers available.
        */
        public static layerCount : int
        /**
        * This parameter controls how many visible lights are allowed.
        */
        public get maximumVisibleLights(): int;
        public set maximumVisibleLights(value: int);
        /**
        * This property enables a conservative method for calculating the size and position of the minimal enclosing sphere around the frustum cascade corner points for shadow culling.
        */
        public get conservativeEnclosingSphere(): boolean;
        public set conservativeEnclosingSphere(value: boolean);
        /**
        */
        public get numIterationsEnclosingSphere(): int;
        public set numIterationsEnclosingSphere(value: int);
        /**
        * Number of culling planes to use.
        */
        public get cullingPlaneCount(): int;
        public set cullingPlaneCount(value: int);
        /**
        * Is the cull orthographic.
        */
        public get isOrthographic(): boolean;
        public set isOrthographic(value: boolean);
        /**
        * LODParameters for culling.
        */
        public get lodParameters(): LODParameters;
        public set lodParameters(value: LODParameters);
        /**
        * The mask for the culling operation.
        */
        public get cullingMask(): uint;
        public set cullingMask(value: uint);
        /**
        * The matrix for the culling operation.
        */
        public get cullingMatrix(): UnityEngine.Matrix4x4;
        public set cullingMatrix(value: UnityEngine.Matrix4x4);
        /**
        * Position for the origin of the cull.
        */
        public get origin(): UnityEngine.Vector3;
        public set origin(value: UnityEngine.Vector3);
        /**
        * Shadow distance to use for the cull.
        */
        public get shadowDistance(): float;
        public set shadowDistance(value: float);
        /**
        * Offset to apply to the near camera plane when performing shadow map rendering.
        */
        public get shadowNearPlaneOffset(): float;
        public set shadowNearPlaneOffset(value: float);
        /**
        * Flags to configure a culling operation in the Scriptable Render Pipeline.
        */
        public get cullingOptions(): CullingOptions;
        public set cullingOptions(value: CullingOptions);
        /**
        * Reflection Probe Sort options for the cull.
        */
        public get reflectionProbeSortingCriteria(): ReflectionProbeSortingCriteria;
        public set reflectionProbeSortingCriteria(value: ReflectionProbeSortingCriteria);
        /**
        * Camera Properties used for culling.
        */
        public get cameraProperties(): CameraProperties;
        public set cameraProperties(value: CameraProperties);
        /**
        * The view matrix generated for single-pass stereo culling.
        */
        public get stereoViewMatrix(): UnityEngine.Matrix4x4;
        public set stereoViewMatrix(value: UnityEngine.Matrix4x4);
        /**
        * The projection matrix generated for single-pass stereo culling.
        */
        public get stereoProjectionMatrix(): UnityEngine.Matrix4x4;
        public set stereoProjectionMatrix(value: UnityEngine.Matrix4x4);
        /**
        * Distance between the virtual eyes.
        */
        public get stereoSeparationDistance(): float;
        public set stereoSeparationDistance(value: float);
        /**
        * This parameter determines query distance for occlusion culling.
        */
        public get accurateOcclusionThreshold(): float;
        public set accurateOcclusionThreshold(value: float);
        /**
        * This parameter controls how many active jobs contribute to occlusion culling.
        */
        public get maximumPortalCullingJobs(): int;
        public set maximumPortalCullingJobs(value: int);
        /**
        * The lower limit to the value ScriptableCullingParameters.maximumPortalCullingJobs.
        */
        public static get cullingJobsLowerLimit(): int;
        /**
        * The upper limit to the value ScriptableCullingParameters.maximumPortalCullingJobs.
        */
        public static get cullingJobsUpperLimit(): int;

        /**
        * Get the distance for the culling of a specific layer.
        */
        public GetLayerCullingDistance ($layerIndex: int) : float
        /**
        * Set the distance for the culling of a specific layer.
        */
        public SetLayerCullingDistance ($layerIndex: int, $distance: float) : void
        /**
        * Fetch the culling plane at the given index.
        */
        public GetCullingPlane ($index: int) : UnityEngine.Plane
        /**
        * Set the culling plane at a given index.
        */
        public SetCullingPlane ($index: int, $plane: UnityEngine.Plane) : void
        public Equals ($other: ScriptableCullingParameters) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: ScriptableCullingParameters, $right: ScriptableCullingParameters) : boolean
        public static op_Inequality ($left: ScriptableCullingParameters, $right: ScriptableCullingParameters) : boolean
    }

    /**
    * LODGroup culling parameters.
    */
    class LODParameters extends System.ValueType implements System.IEquatable$1<LODParameters> {

        /**
        * Indicates whether camera is orthographic.
        */
        public get isOrthographic(): boolean;
        public set isOrthographic(value: boolean);
        /**
        * Camera position.
        */
        public get cameraPosition(): UnityEngine.Vector3;
        public set cameraPosition(value: UnityEngine.Vector3);
        /**
        * Camera's field of view.
        */
        public get fieldOfView(): float;
        public set fieldOfView(value: float);
        /**
        * Orhographic camera size.
        */
        public get orthoSize(): float;
        public set orthoSize(value: float);
        /**
        * Rendering view height in pixels.
        */
        public get cameraPixelHeight(): int;
        public set cameraPixelHeight(value: int);

        public Equals ($other: LODParameters) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: LODParameters, $right: LODParameters) : boolean
        public static op_Inequality ($left: LODParameters, $right: LODParameters) : boolean
    }

    /**
    * Flags used by ScriptableCullingParameters.cullingOptions to configure a culling operation.
    */
    enum CullingOptions {
        None = 0,
        ForceEvenIfCameraIsNotActive = 1,
        OcclusionCull = 2,
        NeedsLighting = 4,
        NeedsReflectionProbes = 8,
        Stereo = 16,
        DisablePerObjectCulling = 32,
        ShadowCasters = 64 
    }

    /**
    * Visible reflection probes sorting options.
    */
    enum ReflectionProbeSortingCriteria {
        None = 0,
        Importance = 1,
        Size = 2,
        ImportanceThenSize = 3 
    }

    /**
    * Camera related properties in CullingParameters.
    */
    class CameraProperties extends System.ValueType implements System.IEquatable$1<CameraProperties> {

        /**
        * Get a shadow culling plane.
        * @param index Plane index (up to 5).
        * @returns Shadow culling plane.
        */
        public GetShadowCullingPlane ($index: int) : UnityEngine.Plane
        /**
        * Set a shadow culling plane.
        * @param index Plane index (up to 5).
        * @param plane Shadow culling plane.
        */
        public SetShadowCullingPlane ($index: int, $plane: UnityEngine.Plane) : void
        /**
        * Get a camera culling plane.
        * @param index Plane index (up to 5).
        * @returns Camera culling plane.
        */
        public GetCameraCullingPlane ($index: int) : UnityEngine.Plane
        /**
        * Set a camera culling plane.
        * @param index Plane index (up to 5).
        * @param plane Camera culling plane.
        */
        public SetCameraCullingPlane ($index: int, $plane: UnityEngine.Plane) : void
        public Equals ($other: CameraProperties) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: CameraProperties, $right: CameraProperties) : boolean
        public static op_Inequality ($left: CameraProperties, $right: CameraProperties) : boolean
    }

    /**
    * Opaque object sorting mode of a Camera.
    */
    enum OpaqueSortMode {
        Default = 0,
        FrontToBack = 1,
        NoDistanceSort = 2 
    }

    /**
    * An enum that represents.
    */
    enum GraphicsTier {
        Tier1 = 0,
        Tier2 = 1,
        Tier3 = 2 
    }

    /**
    * Specifies the OpenGL ES version.
    */
    enum OpenGLESVersion {
        None = 0,
        OpenGLES20 = 1,
        OpenGLES30 = 2,
        OpenGLES31 = 3,
        OpenGLES31AEP = 4,
        OpenGLES32 = 5 
    }

    /**
    * Ambient lighting mode.
    */
    enum AmbientMode {
        Skybox = 0,
        Trilight = 1,
        Flat = 3,
        Custom = 4 
    }

    /**
    * Defines a place in light's rendering to attach Rendering.CommandBuffer objects to.
    */
    enum LightEvent {
        BeforeShadowMap = 0,
        AfterShadowMap = 1,
        BeforeScreenspaceMask = 2,
        AfterScreenspaceMask = 3,
        BeforeShadowMapPass = 4,
        AfterShadowMapPass = 5 
    }

    /**
    * Allows precise control over which shadow map passes to execute Rendering.CommandBuffer objects attached using Light.AddCommandBuffer.
    */
    enum ShadowMapPass {
        PointlightPositiveX = 1,
        PointlightNegativeX = 2,
        PointlightPositiveY = 4,
        PointlightNegativeY = 8,
        PointlightPositiveZ = 16,
        PointlightNegativeZ = 32,
        DirectionalCascade0 = 64,
        DirectionalCascade1 = 128,
        DirectionalCascade2 = 256,
        DirectionalCascade3 = 512,
        Spotlight = 1024,
        Pointlight = 63,
        Directional = 960,
        All = 2047 
    }

    /**
    * Shadow resolution options for a Light.
    */
    enum LightShadowResolution {
        FromQualitySettings = -1,
        Low = 0,
        Medium = 1,
        High = 2,
        VeryHigh = 3 
    }

    /**
    * Default reflection mode.
    */
    enum DefaultReflectionMode {
        Skybox = 0,
        Custom = 1 
    }

    /**
    * Shader pass type for Unity's lighting pipeline.
    */
    enum PassType {
        Normal = 0,
        Vertex = 1,
        VertexLM = 2,
        VertexLMRGBM = 3,
        ForwardBase = 4,
        ForwardAdd = 5,
        LightPrePassBase = 6,
        LightPrePassFinal = 7,
        ShadowCaster = 8,
        Deferred = 10,
        Meta = 11,
        MotionVectors = 12,
        ScriptableRenderPipeline = 13,
        ScriptableRenderPipelineDefaultUnlit = 14,
        GrabPass = 15 
    }

    /**
    * Graphics device API type.
    */
    enum GraphicsDeviceType {
        OpenGL2 = 0,
        Direct3D9 = 1,
        Direct3D11 = 2,
        PlayStation3 = 3,
        Null = 4,
        Xbox360 = 6,
        OpenGLES2 = 8,
        OpenGLES3 = 11,
        PlayStationVita = 12,
        PlayStation4 = 13,
        XboxOne = 14,
        PlayStationMobile = 15,
        Metal = 16,
        OpenGLCore = 17,
        Direct3D12 = 18,
        N3DS = 19,
        Vulkan = 21,
        Switch = 22,
        XboxOneD3D12 = 23,
        GameCoreXboxOne = 24,
        GameCoreScarlett = -1,
        GameCoreXboxSeries = 25,
        PlayStation5 = 26,
        PlayStation5NGGC = 27 
    }

    /**
    * Options for the application's actual rendering threading mode.
    */
    enum RenderingThreadingMode {
        Direct = 0,
        SingleThreaded = 1,
        MultiThreaded = 2,
        LegacyJobified = 3,
        NativeGraphicsJobs = 4,
        NativeGraphicsJobsWithoutRenderThread = 5 
    }

    /**
    * Capabilities of the foveated rendering implementation.
    */
    enum FoveatedRenderingCaps {
        None = 0,
        FoveationImage = 1,
        NonUniformRaster = 2 
    }

    /**
    * Support for various Graphics.CopyTexture cases.
    */
    enum CopyTextureSupport {
        None = 0,
        Basic = 1,
        Copy3D = 2,
        DifferentTypes = 4,
        TextureToRT = 8,
        RTToTexture = 16 
    }

    /**
    * Allows the asynchronous read back of GPU resources.
    */
    class AsyncGPUReadback {

        /**
        * Waits until the completion of every request.
        */
        public static WaitAllRequests () : void
        public static Request ($src: UnityEngine.ComputeBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap Request_EBB7509C_H4A868EE8
        */
        public static Request ($src: UnityEngine.ComputeBuffer, $size: int, $offset: int, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        public static Request ($src: UnityEngine.GraphicsBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap Request_EBB7509C_CE3A6FB8
        */
        public static Request ($src: UnityEngine.GraphicsBuffer, $size: int, $offset: int, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap Request_EBB7509C_C82D0C57
        */
        public static Request ($src: UnityEngine.Texture, $mipIndex?: int, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap Request_EBB7509C_CE39E4C6
        */
        public static Request ($src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap Request_EBB7509C_H3E2402CA
        */
        public static Request ($src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap Request_EBB7509C_H2F409B83
        */
        public static Request ($src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap Request_EBB7509C_H8D139492
        */
        public static Request ($src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap Request_EBB7509C_H1F0FE80E
        */
        public static Request ($src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        public static RequestIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeArray_EBB7509C_E4BD98D6
        */
        public static RequestIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $size: int, $offset: int, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        public static RequestIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeArray_EBB7509C_H8229894A
        */
        public static RequestIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: int, $offset: int, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeArray_EBB7509C_BA105A91
        */
        public static RequestIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex?: int, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeArray_EBB7509C_D36A53F0
        */
        public static RequestIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeArray_EBB7509C_B801095C
        */
        public static RequestIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeArray_EBB7509C_H464F73E4
        */
        public static RequestIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeArray_EBB7509C_F8D9598
        */
        public static RequestIntoNativeArray<T> ($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        public static RequestIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeSlice_EBB7509C_B02C9F97
        */
        public static RequestIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $size: int, $offset: int, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        public static RequestIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeSlice_EBB7509C_H8CC87C79
        */
        public static RequestIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: int, $offset: int, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeSlice_EBB7509C_BF4CE790
        */
        public static RequestIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex?: int, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeSlice_EBB7509C_H29B0E39B
        */
        public static RequestIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeSlice_EBB7509C_H11CE4207
        */
        public static RequestIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeSlice_EBB7509C_H123FE0F
        */
        public static RequestIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
        /**
        * @methodSwap RequestIntoNativeSlice_EBB7509C_H4D718EA3
        */
        public static RequestIntoNativeSlice<T> ($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: int, $x: int, $width: int, $y: int, $height: int, $z: int, $depth: int, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>) : AsyncGPUReadbackRequest
    }

    /**
    * Provides an interface to control GPU frame capture in Microsoft's PIX software.
    */
    class PIX extends System.Object {

        public constructor ()
        /**
        * Begins a GPU frame capture in PIX. If not running via PIX, or as a development build, then it has no effect.
        */
        public static BeginGPUCapture () : void
        /**
        * Ends the current GPU frame capture in PIX. If not running via PIX, or as a development build, then it has no effect.
        */
        public static EndGPUCapture () : void
        /**
        * Returns true if running via PIX and in a development build.
        */
        public static IsAttached () : boolean
    }

    /**
    * Whether to show undefined areas of the display that might cause rendering problems in your built application.
    */
    class LoadStoreActionDebugModeSettings {

        /**
        * Enables or disables Unity highlighting undefined areas of the display.
        */
        public static get LoadStoreDebugModeEnabled(): boolean;
        public static set LoadStoreDebugModeEnabled(value: boolean);

    }

    /**
    * Options for the data type of a shader constant's members.
    */
    enum ShaderParamType {
        Float = 0,
        Int = 1,
        Bool = 2,
        Half = 3,
        Short = 4,
        UInt = 5 
    }

    /**
    * Options for the shader constant value type.
    */
    enum ShaderConstantType {
        Vector = 0,
        Matrix = 1,
        Struct = 2 
    }

    /**
    * Determine in which order objects are renderered.
    */
    enum RenderQueue {
        Background = 1000,
        Geometry = 2000,
        AlphaTest = 2450,
        GeometryLast = 2500,
        Transparent = 3000,
        Overlay = 4000 
    }

    /**
    * Control Fast Memory render target layout.
    */
    enum FastMemoryFlags {
        None = 0,
        SpillTop = 1,
        SpillBottom = 2 
    }

    /**
    * Blend mode for controlling the blending.
    */
    enum BlendMode {
        Zero = 0,
        One = 1,
        DstColor = 2,
        SrcColor = 3,
        OneMinusDstColor = 4,
        SrcAlpha = 5,
        OneMinusSrcColor = 6,
        DstAlpha = 7,
        OneMinusDstAlpha = 8,
        SrcAlphaSaturate = 9,
        OneMinusSrcAlpha = 10 
    }

    /**
    * Blend operation.
    */
    enum BlendOp {
        Add = 0,
        Subtract = 1,
        ReverseSubtract = 2,
        Min = 3,
        Max = 4,
        LogicalClear = 5,
        LogicalSet = 6,
        LogicalCopy = 7,
        LogicalCopyInverted = 8,
        LogicalNoop = 9,
        LogicalInvert = 10,
        LogicalAnd = 11,
        LogicalNand = 12,
        LogicalOr = 13,
        LogicalNor = 14,
        LogicalXor = 15,
        LogicalEquivalence = 16,
        LogicalAndReverse = 17,
        LogicalAndInverted = 18,
        LogicalOrReverse = 19,
        LogicalOrInverted = 20,
        Multiply = 21,
        Screen = 22,
        Overlay = 23,
        Darken = 24,
        Lighten = 25,
        ColorDodge = 26,
        ColorBurn = 27,
        HardLight = 28,
        SoftLight = 29,
        Difference = 30,
        Exclusion = 31,
        HSLHue = 32,
        HSLSaturation = 33,
        HSLColor = 34,
        HSLLuminosity = 35 
    }

    /**
    * Depth or stencil comparison function.
    */
    enum CompareFunction {
        Disabled = 0,
        Never = 1,
        Less = 2,
        Equal = 3,
        LessEqual = 4,
        Greater = 5,
        NotEqual = 6,
        GreaterEqual = 7,
        Always = 8 
    }

    /**
    * Determines which faces Unity culls.
    */
    enum CullMode {
        Off = 0,
        Front = 1,
        Back = 2 
    }

    /**
    * Specifies which color components will get written into the target framebuffer.
    */
    enum ColorWriteMask {
        Alpha = 1,
        Blue = 2,
        Green = 4,
        Red = 8,
        All = 15 
    }

    /**
    * Specifies the operation that's performed on the stencil buffer when rendering.
    */
    enum StencilOp {
        Keep = 0,
        Zero = 1,
        Replace = 2,
        IncrementSaturate = 3,
        DecrementSaturate = 4,
        Invert = 5,
        IncrementWrap = 6,
        DecrementWrap = 7 
    }

    /**
    * Determines how Unity will compress baked reflection cubemap.
    */
    enum ReflectionCubemapCompression {
        Uncompressed = 0,
        Compressed = 1,
        Auto = 2 
    }

    /**
    * Graphics Format Swizzle.
    */
    enum FormatSwizzle {
        FormatSwizzleR = 0,
        FormatSwizzleG = 1,
        FormatSwizzleB = 2,
        FormatSwizzleA = 3,
        FormatSwizzle0 = 4,
        FormatSwizzle1 = 5 
    }

    enum ReflectionProbeType {
        Cube = 0,
        Card = 1 
    }

    /**
    * Built-in shader types used by Rendering.GraphicsSettings.
    */
    enum BuiltinShaderType {
        DeferredShading = 0,
        DeferredReflections = 1,
        LegacyDeferredLighting = 2,
        ScreenSpaceShadows = 3,
        DepthNormals = 4,
        MotionVectors = 5,
        LightHalo = 6,
        LensFlare = 7 
    }

    /**
    * Built-in shader modes used by Rendering.GraphicsSettings.
    */
    enum BuiltinShaderMode {
        Disabled = 0,
        UseBuiltin = 1,
        UseCustom = 2 
    }

    /**
    * Defines set by editor when compiling shaders, based on the target platform and GraphicsTier.
    */
    enum BuiltinShaderDefine {
        UNITY_NO_DXT5nm = 0,
        UNITY_NO_RGBM = 1,
        UNITY_USE_NATIVE_HDR = 2,
        UNITY_ENABLE_REFLECTION_BUFFERS = 3,
        UNITY_FRAMEBUFFER_FETCH_AVAILABLE = 4,
        UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS = 5,
        UNITY_METAL_SHADOWS_USE_POINT_FILTERING = 6,
        UNITY_NO_CUBEMAP_ARRAY = 7,
        UNITY_NO_SCREENSPACE_SHADOWS = 8,
        UNITY_USE_DITHER_MASK_FOR_ALPHABLENDED_SHADOWS = 9,
        UNITY_PBS_USE_BRDF1 = 10,
        UNITY_PBS_USE_BRDF2 = 11,
        UNITY_PBS_USE_BRDF3 = 12,
        UNITY_NO_FULL_STANDARD_SHADER = 13,
        UNITY_SPECCUBE_BOX_PROJECTION = 14,
        UNITY_SPECCUBE_BLENDING = 15,
        UNITY_ENABLE_DETAIL_NORMALMAP = 16,
        SHADER_API_MOBILE = 17,
        SHADER_API_DESKTOP = 18,
        UNITY_HARDWARE_TIER1 = 19,
        UNITY_HARDWARE_TIER2 = 20,
        UNITY_HARDWARE_TIER3 = 21,
        UNITY_COLORSPACE_GAMMA = 22,
        UNITY_LIGHT_PROBE_PROXY_VOLUME = 23,
        UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS = 24,
        UNITY_LIGHTMAP_DLDR_ENCODING = 25,
        UNITY_LIGHTMAP_RGBM_ENCODING = 26,
        UNITY_LIGHTMAP_FULL_HDR = 27,
        UNITY_VIRTUAL_TEXTURING = 28,
        UNITY_PRETRANSFORM_TO_DISPLAY_ORIENTATION = 29,
        UNITY_ASTC_NORMALMAP_ENCODING = 30,
        SHADER_API_GLES30 = 31,
        UNITY_UNIFIED_SHADER_PRECISION_MODEL = 32,
        UNITY_PLATFORM_SUPPORTS_WAVE_32 = 33,
        UNITY_PLATFORM_SUPPORTS_WAVE_64 = 34,
        UNITY_NEEDS_RENDERPASS_FBFETCH_FALLBACK = 35 
    }

    /**
    * Video shaders mode used by Rendering.GraphicsSettings.
    */
    enum VideoShadersIncludeMode {
        Never = 0,
        Referenced = 1,
        Always = 2 
    }

    /**
    * The HDR mode to use for rendering.
    */
    enum CameraHDRMode {
        FP16 = 1,
        R11G11B10 = 2 
    }

    /**
    * How much CPU usage to assign to the final lighting calculations at runtime.
    */
    enum RealtimeGICPUUsage {
        Low = 25,
        Medium = 50,
        High = 75,
        Unlimited = 100 
    }

    /**
    * Defines the way Unity chooses a probe to light a Renderer that is lit by Light Probes but positioned outside the bounds of the Light Probe tetrahedral hull.
    */
    enum LightProbeOutsideHullStrategy {
        kLightProbeSearchTetrahedralHull = 0,
        kLightProbeUseAmbientProbe = 1 
    }

    /**
    * Script interface for.
    */
    class GraphicsSettings extends UnityEngine.Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Transparent object sorting mode.
        */
        public static get transparencySortMode(): UnityEngine.TransparencySortMode;
        public static set transparencySortMode(value: UnityEngine.TransparencySortMode);
        /**
        * An axis that describes the direction along which the distances of objects are measured for the purpose of sorting.
        */
        public static get transparencySortAxis(): UnityEngine.Vector3;
        public static set transparencySortAxis(value: UnityEngine.Vector3);
        /**
        * Is the current render pipeline capable of rendering direct lighting for rectangular area Lights?
        */
        public static get realtimeDirectRectangularAreaLights(): boolean;
        public static set realtimeDirectRectangularAreaLights(value: boolean);
        /**
        * If this is true, Light intensity is multiplied against linear color values. If it is false, gamma color values are used.
        */
        public static get lightsUseLinearIntensity(): boolean;
        public static set lightsUseLinearIntensity(value: boolean);
        /**
        * Whether to use a Light's color temperature when calculating the final color of that Light."
        */
        public static get lightsUseColorTemperature(): boolean;
        public static set lightsUseColorTemperature(value: boolean);
        /**
        * Stores the default value for the RenderingLayerMask property of newly created Renderers.
        */
        public static get defaultRenderingLayerMask(): uint;
        public static set defaultRenderingLayerMask(value: uint);
        /**
        * Enable/Disable SRP batcher (experimental) at runtime.
        */
        public static get useScriptableRenderPipelineBatching(): boolean;
        public static set useScriptableRenderPipelineBatching(value: boolean);
        /**
        * If this is true, a log entry is made each time a shader is compiled at application runtime.
        */
        public static get logWhenShaderIsCompiled(): boolean;
        public static set logWhenShaderIsCompiled(value: boolean);
        /**
        * Disables the built-in update loop for Custom Render Textures, so that you can write your own update loop.
        */
        public static get disableBuiltinCustomRenderTextureUpdate(): boolean;
        public static set disableBuiltinCustomRenderTextureUpdate(value: boolean);
        /**
        * Defines the way Unity chooses a probe to light a Renderer that is lit by Light Probes but positioned outside the bounds of the Light Probe tetrahedral hull.
        */
        public static get lightProbeOutsideHullStrategy(): LightProbeOutsideHullStrategy;
        public static set lightProbeOutsideHullStrategy(value: LightProbeOutsideHullStrategy);
        /**
        * The RenderPipelineAsset that defines the active render pipeline for the current quality level.
        */
        public static get currentRenderPipeline(): RenderPipelineAsset;
        /**
        * Deprecated, use GraphicsSettings.defaultRenderPipeline instead.
        */
        public static get renderPipelineAsset(): RenderPipelineAsset;
        public static set renderPipelineAsset(value: RenderPipelineAsset);
        /**
        * The RenderPipelineAsset that defines the default render pipeline.
        */
        public static get defaultRenderPipeline(): RenderPipelineAsset;
        public static set defaultRenderPipeline(value: RenderPipelineAsset);
        /**
        * An array containing the RenderPipelineAsset instances that describe the default render pipeline and any quality level overrides.
        */
        public static get allConfiguredRenderPipelines(): RenderPipelineAsset[];
        /**
        * Enable or disable using the camera position as the reference point for culling lights.
        */
        public static get cameraRelativeLightCulling(): boolean;
        public static set cameraRelativeLightCulling(value: boolean);
        /**
        * Enable or disable using the camera position as the reference point for culling shadows.
        */
        public static get cameraRelativeShadowCulling(): boolean;
        public static set cameraRelativeShadowCulling(value: boolean);

        /**
        * Returns true if shader define was set when compiling shaders for current GraphicsTier. Graphics Tiers are only available in the Built-in Render Pipeline.
        */
        public static HasShaderDefine ($tier: GraphicsTier, $defineHash: BuiltinShaderDefine) : boolean
        /**
        * Returns true if shader define was set when compiling shaders for a given GraphicsTier. Graphics Tiers are only available in the Built-in Render Pipeline.
        */
        public static HasShaderDefine ($defineHash: BuiltinShaderDefine) : boolean
        /**
        * Provides a reference to the GraphicSettings object.
        * @returns Returns the GraphicsSettings object.
        */
        public static GetGraphicsSettings () : UnityEngine.Object
        /**
        * Set built-in shader mode.
        * @param type Built-in shader type to change.
        * @param mode Mode to use for built-in shader.
        */
        public static SetShaderMode ($type: BuiltinShaderType, $mode: BuiltinShaderMode) : void
        /**
        * Get built-in shader mode.
        * @param type Built-in shader type to query.
        * @returns Mode used for built-in shader.
        */
        public static GetShaderMode ($type: BuiltinShaderType) : BuiltinShaderMode
        /**
        * Set custom shader to use instead of a built-in shader.
        * @param type Built-in shader type to set custom shader to.
        * @param shader The shader to use.
        */
        public static SetCustomShader ($type: BuiltinShaderType, $shader: UnityEngine.Shader) : void
        /**
        * Get custom shader used instead of a built-in shader.
        * @param type Built-in shader type to query custom shader for.
        * @returns The shader used.
        */
        public static GetCustomShader ($type: BuiltinShaderType) : UnityEngine.Shader
        /**
        * Register a RenderPipelineGlobalSettings instance for a given RenderPipeline. A RenderPipeline can have only one registered RenderPipelineGlobalSettings instance.
        * @param settings RenderPipelineGlobalSettings asset to register for a given RenderPipeline. The method does nothing if the parameter is null.
        */
        public static RegisterRenderPipelineSettings<T extends RenderPipeline> ($settings: RenderPipelineGlobalSettings) : void
        /**
        * The method removes the association between the given RenderPipeline and the RenderPipelineGlobalSettings asset from GraphicsSettings.
        */
        public static UnregisterRenderPipelineSettings<T extends RenderPipeline> () : void
        /**
        * Get the registered RenderPipelineGlobalSettings for the given RenderPipeline.
        */
        public static GetSettingsForRenderPipeline<T extends RenderPipeline> () : RenderPipelineGlobalSettings
    }

    /**
    * A ScriptableObject to associate with a RenderPipeline and store project-wide settings for that Pipeline.
    */
    class RenderPipelineGlobalSettings extends UnityEngine.ScriptableObject {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);

        private constructor ()
    }

    /**
    * Defines a series of commands and settings that describes how Unity renders a frame.
    */
    class RenderPipeline extends System.Object {

        /**
        * Returns true when the RenderPipeline is invalid or destroyed.
        */
        public get disposed(): boolean;
        public get defaultSettings(): RenderPipelineGlobalSettings;

        public static SupportsRenderRequest<RequestData> ($camera: UnityEngine.Camera, $data: RequestData) : boolean
        public static SubmitRenderRequest<RequestData> ($camera: UnityEngine.Camera, $data: RequestData) : void
    }

    /**
    * An asset that produces a specific IRenderPipeline.
    */
    class RenderPipelineAsset extends UnityEngine.ScriptableObject {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Returns the names of the Rendering Layer Masks for this pipeline.
        * @returns An array of 32 Rendering Layer Mask names.
        */
        public get renderingLayerMaskNames(): string[];
        /**
        * Returns the names of the Rendering Layer Masks for this pipeline, with each name prefixed by a unique numerical ID.
        * @returns Returns the mask names defined in renderingLayerMaskNames, but with each name prefixed by its index in the array, a colon, and a space. For example, if the element with an index of 2 has the name "Example Name", its value in this array is "2: Example Name".
        */
        public get prefixedRenderingLayerMaskNames(): string[];
        /**
        * Return the default Material for this pipeline.
        * @returns Default material.
        */
        public get defaultMaterial(): UnityEngine.Material;
        /**
        * Retrieves the default Autodesk Interactive Shader for this pipeline.
        * @returns Returns the default shader.
        */
        public get autodeskInteractiveShader(): UnityEngine.Shader;
        /**
        * Retrieves the default Autodesk Interactive transparent Shader for this pipeline.
        * @returns Returns the default shader.
        */
        public get autodeskInteractiveTransparentShader(): UnityEngine.Shader;
        /**
        * Retrieves the default Autodesk Interactive masked Shader for this pipeline.
        * @returns Returns the default shader.
        */
        public get autodeskInteractiveMaskedShader(): UnityEngine.Shader;
        /**
        * Return the detail lit Shader for this pipeline.
        */
        public get terrainDetailLitShader(): UnityEngine.Shader;
        /**
        * Return the detail grass Shader for this pipeline.
        */
        public get terrainDetailGrassShader(): UnityEngine.Shader;
        /**
        * Return the detail grass billboard Shader for this pipeline.
        */
        public get terrainDetailGrassBillboardShader(): UnityEngine.Shader;
        /**
        * Return the default particle Material for this pipeline.
        * @returns Default material.
        */
        public get defaultParticleMaterial(): UnityEngine.Material;
        /**
        * Return the default Line Material for this pipeline.
        * @returns Default material.
        */
        public get defaultLineMaterial(): UnityEngine.Material;
        /**
        * Return the default Terrain  Material for this pipeline.
        * @returns Default material.
        */
        public get defaultTerrainMaterial(): UnityEngine.Material;
        /**
        * Return the default UI Material for this pipeline.
        * @returns Default material.
        */
        public get defaultUIMaterial(): UnityEngine.Material;
        /**
        * Return the default UI overdraw Material for this pipeline.
        * @returns Default material.
        */
        public get defaultUIOverdrawMaterial(): UnityEngine.Material;
        /**
        * Return the default UI ETC1  Material for this pipeline.
        * @returns Default material.
        */
        public get defaultUIETC1SupportedMaterial(): UnityEngine.Material;
        /**
        * Return the default 2D Material for this pipeline.
        * @returns Default material.
        */
        public get default2DMaterial(): UnityEngine.Material;
        /**
        * Gets the default 2D Mask Material used by Sprite Masks in Universal Render Pipeline.
        * @returns Returns the default material.
        */
        public get default2DMaskMaterial(): UnityEngine.Material;
        /**
        * Return the default Shader for this pipeline.
        * @returns Default shader.
        */
        public get defaultShader(): UnityEngine.Shader;
        /**
        * Return the default SpeedTree v7 Shader for this pipeline.
        */
        public get defaultSpeedTree7Shader(): UnityEngine.Shader;
        /**
        * Return the default SpeedTree v8 Shader for this pipeline.
        */
        public get defaultSpeedTree8Shader(): UnityEngine.Shader;
        /**
        * Returns the Shader Tag value for the render pipeline that is described by this asset.
        * @returns String with the Shader Tag.
        */
        public get renderPipelineShaderTag(): string;

        private constructor ()
    }

    /**
    * Use the OnDemandRendering class to control and query information about your application's rendering speed independent from all other subsystems (such as physics, input, or animation).
    */
    class OnDemandRendering extends System.Object {

        /**
        * True if the current frame will be rendered.
        */
        public static get willCurrentFrameRender(): boolean;
        /**
        * Get or set the current frame rate interval. To restore rendering back to the value of Application.targetFrameRate or QualitySettings.vSyncCount set this to 0 or 1.
        */
        public static get renderFrameInterval(): int;
        public static set renderFrameInterval(value: int);
        /**
        * The current estimated rate of rendering in frames per second rounded to the nearest integer.
        */
        public static get effectiveRenderFrameRate(): int;

        public constructor ()
    }

    /**
    * Static class providing extension methods for CommandBuffer.
    */
    class CommandBufferExtensions {

        /**
        * Adds a command to put a given render target into fast GPU memory.
        * @param rid The render target to put into fast GPU memory.
        * @param fastMemoryFlags The memory layout to use if only part of the render target is put into fast GPU memory, either because of the residency parameter or because of fast GPU memory availability.
        * @param residency The amount of the render target to put into fast GPU memory. Valid values are 0.0f - 1.0f inclusive.
        A value of 0.0f is equal to none of the render target, and a value of 1.0f is equal to the whole render target.
        
        * @param copyContents When this value is true, Unity copies the existing contents of the render target into fast memory.
        When this value is false, Unity does not copy the existing contents of the render target into fast memory.
        Set this value to true if you plan to add to the existing contents, and set it to false if you plan to overwrite or clear the existing contents.
        Where possible, set this value to false for better performance.
        
        * @methodSwap SwitchIntoFastMemory_EBB7509C_CDF38423
        */
        public static SwitchIntoFastMemory ($cmd: CommandBuffer, $rid: RenderTargetIdentifier, $fastMemoryFlags: FastMemoryFlags, $residency: float, $copyContents: boolean) : void
        /**
        * Adds a command to remove a given render target from fast GPU memory.
        * @param rid The render target to remove from fast GPU memory.
        * @param copyContents When this value is true, Unity copies the existing contents of the render target when it removes it from fast GPU memory. When this value is false, Unity does not copy the existing contents of the render target when it removes it from fast GPU memory. Set this value to true if you plan to add to the existing contents, and set it to false if you plan to overwrite or clear the existing contents. Where possible, set this value to false for better performance.
        */
        public static SwitchOutOfFastMemory ($cmd: CommandBuffer, $rid: RenderTargetIdentifier, $copyContents: boolean) : void
    }

    /**
    * Provides an interface to the Unity splash screen.
    */
    class SplashScreen extends System.Object {

        /**
        * Returns true once the splash screen has finished. This is once all logos have been shown for their specified duration.
        */
        public static get isFinished(): boolean;

        public constructor ()
        /**
        * Initializes the splash screen so it is ready to begin drawing. Call this before you start calling Rendering.SplashScreen.Draw. Internally this function resets the timer and prepares the logos for drawing.
        */
        public static Begin () : void
        /**
        * Stop the SplashScreen rendering.
        */
        public static Stop ($stopBehavior: UnityEngine_Rendering_SplashScreen.StopBehavior) : void
        /**
        * Immediately draws the splash screen. Ensure you have called Rendering.SplashScreen.Begin before you start calling this.
        */
        public static Draw () : void
    }

    /**
    * A declaration of a single color or depth rendering surface to be attached into a RenderPass.
    */
    class AttachmentDescriptor extends System.ValueType implements System.IEquatable$1<AttachmentDescriptor> {

        /**
        * The load action to be used on this attachment when the RenderPass starts.
        */
        public get loadAction(): RenderBufferLoadAction;
        public set loadAction(value: RenderBufferLoadAction);
        /**
        * The store action to use with this attachment when the RenderPass ends. Only used when either ConfigureTarget or ConfigureResolveTarget has been called.
        */
        public get storeAction(): RenderBufferStoreAction;
        public set storeAction(value: RenderBufferStoreAction);
        /**
        * The GraphicsFormat of this attachment. To use in place of format.
        */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set graphicsFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
        * The format of this attachment.
        */
        public get format(): UnityEngine.RenderTextureFormat;
        public set format(value: UnityEngine.RenderTextureFormat);
        /**
        * The surface to use as the backing storage for this AttachmentDescriptor.
        */
        public get loadStoreTarget(): RenderTargetIdentifier;
        public set loadStoreTarget(value: RenderTargetIdentifier);
        /**
        * When the renderpass that uses this attachment ends, resolve the MSAA surface into the given target.
        */
        public get resolveTarget(): RenderTargetIdentifier;
        public set resolveTarget(value: RenderTargetIdentifier);
        /**
        * The currently assigned clear color for this attachment. Default is black.
        */
        public get clearColor(): UnityEngine.Color;
        public set clearColor(value: UnityEngine.Color);
        /**
        * Currently assigned depth clear value for this attachment. Default value is 1.0.
        */
        public get clearDepth(): float;
        public set clearDepth(value: float);
        /**
        * Currently assigned stencil clear value for this attachment. Default is 0.
        */
        public get clearStencil(): uint;
        public set clearStencil(value: uint);

        /**
        * Create a AttachmentDescriptor to be used with RenderPass.
        * @param fmt The format of this attachment.
        */
        public constructor ($format: UnityEngine_Experimental_Rendering.GraphicsFormat)
        /**
        * Create a AttachmentDescriptor to be used with RenderPass.
        * @param fmt The format of this attachment.
        */
        public constructor ($format: UnityEngine.RenderTextureFormat)
        /**
        * Create a AttachmentDescriptor to be used with RenderPass.
        * @param fmt The format of this attachment.
        */
        public constructor ($format: UnityEngine.RenderTextureFormat, $target: RenderTargetIdentifier, $loadExistingContents?: boolean, $storeResults?: boolean, $resolve?: boolean)
        /**
        * Binds this AttachmentDescriptor to the given target surface.
        * @param tgt The surface to use as the backing storage for this AttachmentDescriptor.
        * @param loadExistingContents Whether to read in the existing contents of the surface when the RenderPass starts.
        * @param storeResults Whether to store the rendering results of the attachment when the RenderPass ends.
        */
        public ConfigureTarget ($target: RenderTargetIdentifier, $loadExistingContents: boolean, $storeResults: boolean) : void
        /**
        * When the renderpass that uses this attachment ends, resolve the MSAA surface into the given target.
        * @param tgt The target surface to receive the MSAA-resolved pixels.
        */
        public ConfigureResolveTarget ($target: RenderTargetIdentifier) : void
        /**
        * When the RenderPass starts, clear this attachment into the color or depth/stencil values given (depending on the format of this attachment). Changes loadAction to RenderBufferLoadAction.Clear.
        * @param clearCol Color clear value. Ignored on depth/stencil attachments.
        * @param clearDep Depth clear value. Ignored on color surfaces.
        * @param clearStenc Stencil clear value. Ignored on color or depth-only surfaces.
        */
        public ConfigureClear ($clearColor: UnityEngine.Color, $clearDepth?: float, $clearStencil?: uint) : void
        public Equals ($other: AttachmentDescriptor) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: AttachmentDescriptor, $right: AttachmentDescriptor) : boolean
        public static op_Inequality ($left: AttachmentDescriptor, $right: AttachmentDescriptor) : boolean
    }

    /**
    * Values for the blend state.
    */
    class BlendState extends System.ValueType implements System.IEquatable$1<BlendState> {

        /**
        * Default values for the blend state.
        */
        public static get defaultValue(): BlendState;
        /**
        * Determines whether each render target uses a separate blend state.
        */
        public get separateMRTBlendStates(): boolean;
        public set separateMRTBlendStates(value: boolean);
        /**
        * Turns on alpha-to-coverage.
        */
        public get alphaToMask(): boolean;
        public set alphaToMask(value: boolean);
        /**
        * Blend state for render target 0.
        */
        public get blendState0(): RenderTargetBlendState;
        public set blendState0(value: RenderTargetBlendState);
        /**
        * Blend state for render target 1.
        */
        public get blendState1(): RenderTargetBlendState;
        public set blendState1(value: RenderTargetBlendState);
        /**
        * Blend state for render target 2.
        */
        public get blendState2(): RenderTargetBlendState;
        public set blendState2(value: RenderTargetBlendState);
        /**
        * Blend state for render target 3.
        */
        public get blendState3(): RenderTargetBlendState;
        public set blendState3(value: RenderTargetBlendState);
        /**
        * Blend state for render target 4.
        */
        public get blendState4(): RenderTargetBlendState;
        public set blendState4(value: RenderTargetBlendState);
        /**
        * Blend state for render target 5.
        */
        public get blendState5(): RenderTargetBlendState;
        public set blendState5(value: RenderTargetBlendState);
        /**
        * Blend state for render target 6.
        */
        public get blendState6(): RenderTargetBlendState;
        public set blendState6(value: RenderTargetBlendState);
        /**
        * Blend state for render target 7.
        */
        public get blendState7(): RenderTargetBlendState;
        public set blendState7(value: RenderTargetBlendState);

        /**
        * Creates a new blend state with the specified values.
        * @param separateMRTBlend Determines whether each render target uses a separate blend state.
        * @param alphaToMask Turns on alpha-to-coverage.
        */
        public constructor ($separateMRTBlend?: boolean, $alphaToMask?: boolean)
        public Equals ($other: BlendState) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: BlendState, $right: BlendState) : boolean
        public static op_Inequality ($left: BlendState, $right: BlendState) : boolean
    }

    /**
    * Values for the blend state.
    */
    class RenderTargetBlendState extends System.ValueType implements System.IEquatable$1<RenderTargetBlendState> {

        /**
        * Default values for the blend state.
        */
        public static get defaultValue(): RenderTargetBlendState;
        /**
        * Specifies which color components will get written into the target framebuffer.
        */
        public get writeMask(): ColorWriteMask;
        public set writeMask(value: ColorWriteMask);
        /**
        * Blend factor used for the color (RGB) channel of the source.
        */
        public get sourceColorBlendMode(): BlendMode;
        public set sourceColorBlendMode(value: BlendMode);
        /**
        * Blend factor used for the color (RGB) channel of the destination.
        */
        public get destinationColorBlendMode(): BlendMode;
        public set destinationColorBlendMode(value: BlendMode);
        /**
        * Blend factor used for the alpha (A) channel of the source.
        */
        public get sourceAlphaBlendMode(): BlendMode;
        public set sourceAlphaBlendMode(value: BlendMode);
        /**
        * Blend factor used for the alpha (A) channel of the destination.
        */
        public get destinationAlphaBlendMode(): BlendMode;
        public set destinationAlphaBlendMode(value: BlendMode);
        /**
        * Operation used for blending the color (RGB) channel.
        */
        public get colorBlendOperation(): BlendOp;
        public set colorBlendOperation(value: BlendOp);
        /**
        * Operation used for blending the alpha (A) channel.
        */
        public get alphaBlendOperation(): BlendOp;
        public set alphaBlendOperation(value: BlendOp);

        /**
        * Creates a new blend state with the given values.
        * @param writeMask Specifies which color components will get written into the target framebuffer.
        * @param sourceColorBlendMode Blend factor used for the color (RGB) channel of the source.
        * @param destinationColorBlendMode Blend factor used for the color (RGB) channel of the destination.
        * @param sourceAlphaBlendMode Blend factor used for the alpha (A) channel of the source.
        * @param destinationAlphaBlendMode Blend factor used for the alpha (A) channel of the destination.
        * @param colorBlendOperation Operation used for blending the color (RGB) channel.
        * @param alphaBlendOperation Operation used for blending the alpha (A) channel.
        */
        public constructor ($writeMask?: ColorWriteMask, $sourceColorBlendMode?: BlendMode, $destinationColorBlendMode?: BlendMode, $sourceAlphaBlendMode?: BlendMode, $destinationAlphaBlendMode?: BlendMode, $colorBlendOperation?: BlendOp, $alphaBlendOperation?: BlendOp)
        public Equals ($other: RenderTargetBlendState) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: RenderTargetBlendState, $right: RenderTargetBlendState) : boolean
        public static op_Inequality ($left: RenderTargetBlendState, $right: RenderTargetBlendState) : boolean
    }

    /**
    * A struct containing the results of a culling operation.
    */
    class CullingResults extends System.ValueType implements System.IEquatable$1<CullingResults> {

        /**
        * Array of visible lights.
        */
        public get visibleLights(): Unity_Collections.NativeArray$1<VisibleLight>;
        /**
        * Off-screen lights that still affect visible vertices.
        */
        public get visibleOffscreenVertexLights(): Unity_Collections.NativeArray$1<VisibleLight>;
        /**
        * Array of visible reflection probes.
        */
        public get visibleReflectionProbes(): Unity_Collections.NativeArray$1<VisibleReflectionProbe>;
        /**
        * Gets the number of per-object light indices.
        * @returns The number of per-object light indices.
        */
        public get lightIndexCount(): int;
        /**
        * Gets the number of per-object reflection probe indices.
        * @returns The number of per-object reflection probe indices.
        */
        public get reflectionProbeIndexCount(): int;
        /**
        * Gets the number of per-object light and reflection probe indices.
        * @returns The number of per-object light and reflection probe indices.
        */
        public get lightAndReflectionProbeIndexCount(): int;

        /**
        * Fills a buffer with per-object light indices.
        * @param computeBuffer The compute buffer object to fill.
        * @param buffer The buffer object to fill.
        */
        public FillLightAndReflectionProbeIndices ($computeBuffer: UnityEngine.ComputeBuffer) : void
        /**
        * Fills a buffer with per-object light indices.
        * @param computeBuffer The compute buffer object to fill.
        * @param buffer The buffer object to fill.
        */
        public FillLightAndReflectionProbeIndices ($buffer: UnityEngine.GraphicsBuffer) : void
        /**
        * If a RenderPipeline sorts or otherwise modifies the VisibleLight list, an index remap will be necessary to properly make use of per-object light lists.
        * @param allocator The allocator to use.
        * @returns Array of indices that map from VisibleLight indices to internal per-object light list indices.
        */
        public GetLightIndexMap ($allocator: Unity_Collections.Allocator) : Unity_Collections.NativeArray$1<int>
        public SetLightIndexMap ($lightIndexMap: Unity_Collections.NativeArray$1<int>) : void
        /**
        * If a RenderPipeline sorts or otherwise modifies the VisibleReflectionProbe list, an index remap will be necessary to properly make use of per-object reflection probe lists.
        * @param allocator The allocator to use.
        * @returns Array of indices that map from VisibleReflectionProbe indices to internal per-object reflection probe list indices.
        */
        public GetReflectionProbeIndexMap ($allocator: Unity_Collections.Allocator) : Unity_Collections.NativeArray$1<int>
        public SetReflectionProbeIndexMap ($lightIndexMap: Unity_Collections.NativeArray$1<int>) : void
        /**
        * Returns the bounding box that encapsulates the visible shadow casters.  Can be used to, for instance, dynamically adjust cascade ranges.
        * @param lightIndex The index of the shadow-casting light.
        * @param outBounds The bounds to be computed.
        * @returns True if the light affects at least one shadow casting object in the Scene.
        */
        public GetShadowCasterBounds ($lightIndex: int, $outBounds: $Ref<UnityEngine.Bounds>) : boolean
        /**
        * Calculates the view and projection matrices and shadow split data for a spot light.
        * @param activeLightIndex The index into the active light array.
        * @param viewMatrix The computed view matrix.
        * @param projMatrix The computed projection matrix.
        * @param shadowSplitData The computed split data.
        * @returns If false, the shadow map for this light does not need to be rendered this frame.
        */
        public ComputeSpotShadowMatricesAndCullingPrimitives ($activeLightIndex: int, $viewMatrix: $Ref<UnityEngine.Matrix4x4>, $projMatrix: $Ref<UnityEngine.Matrix4x4>, $shadowSplitData: $Ref<ShadowSplitData>) : boolean
        /**
        * Calculates the view and projection matrices and shadow split data for a point light.
        * @param activeLightIndex The index into the active light array.
        * @param cubemapFace The cubemap face to be rendered.
        * @param fovBias The amount by which to increase the camera FOV above 90 degrees.
        * @param viewMatrix The computed view matrix.
        * @param projMatrix The computed projection matrix.
        * @param shadowSplitData The computed split data.
        * @returns If false, the shadow map for this light and cubemap face does not need to be rendered this frame.
        */
        public ComputePointShadowMatricesAndCullingPrimitives ($activeLightIndex: int, $cubemapFace: UnityEngine.CubemapFace, $fovBias: float, $viewMatrix: $Ref<UnityEngine.Matrix4x4>, $projMatrix: $Ref<UnityEngine.Matrix4x4>, $shadowSplitData: $Ref<ShadowSplitData>) : boolean
        /**
        * Calculates the view and projection matrices and shadow split data for a directional light.
        * @param activeLightIndex The index into the active light array.
        * @param splitIndex The cascade index.
        * @param splitCount The number of cascades.
        * @param splitRatio The cascade ratios.
        * @param shadowResolution The resolution of the shadowmap.
        * @param shadowNearPlaneOffset The near plane offset for the light.
        * @param viewMatrix The computed view matrix.
        * @param projMatrix The computed projection matrix.
        * @param shadowSplitData The computed cascade data.
        * @returns If false, the shadow map for this cascade does not need to be rendered this frame.
        */
        public ComputeDirectionalShadowMatricesAndCullingPrimitives ($activeLightIndex: int, $splitIndex: int, $splitCount: int, $splitRatio: UnityEngine.Vector3, $shadowResolution: int, $shadowNearPlaneOffset: float, $viewMatrix: $Ref<UnityEngine.Matrix4x4>, $projMatrix: $Ref<UnityEngine.Matrix4x4>, $shadowSplitData: $Ref<ShadowSplitData>) : boolean
        public Equals ($other: CullingResults) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: CullingResults, $right: CullingResults) : boolean
        public static op_Inequality ($left: CullingResults, $right: CullingResults) : boolean
    }

    /**
    * Describes the culling information for a given shadow split (e.g. directional cascade).
    */
    class ShadowSplitData extends System.ValueType implements System.IEquatable$1<ShadowSplitData> {

        /**
        * The maximum number of culling planes.
        */
        public static maximumCullingPlaneCount : int
        /**
        * The number of culling planes.
        */
        public get cullingPlaneCount(): int;
        public set cullingPlaneCount(value: int);
        /**
        * The culling sphere.  The first three components of the vector describe the sphere center, and the last component specifies the radius.
        */
        public get cullingSphere(): UnityEngine.Vector4;
        public set cullingSphere(value: UnityEngine.Vector4);
        /**
        * The model view projection matrix Unity uses to cull objects it renders into this shadow map.
        */
        public get cullingMatrix(): UnityEngine.Matrix4x4;
        public set cullingMatrix(value: UnityEngine.Matrix4x4);
        /**
        * The near plane distance that Unity uses to cull objects. Unity transforms the objects with ShadowSplitData.cullingMatrix, and then culls the ones that are farther than the near plane distance.
        */
        public get cullingNearPlane(): float;
        public set cullingNearPlane(value: float);
        /**
        * A multiplier applied to the radius of the culling sphere.
        * Values must be in the range 0 to 1. With higher values, Unity culls more objects. Lower makes the cascades share more rendered objects. Using lower values allows blending between different cascades as they then share objects.
        */
        public get shadowCascadeBlendCullingFactor(): float;
        public set shadowCascadeBlendCullingFactor(value: float);

        /**
        * Gets a culling plane.
        * @param index The culling plane index.
        * @returns The culling plane.
        */
        public GetCullingPlane ($index: int) : UnityEngine.Plane
        /**
        * Sets a culling plane.
        * @param index The index of the culling plane to set.
        * @param plane The culling plane.
        */
        public SetCullingPlane ($index: int, $plane: UnityEngine.Plane) : void
        public Equals ($other: ShadowSplitData) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: ShadowSplitData, $right: ShadowSplitData) : boolean
        public static op_Inequality ($left: ShadowSplitData, $right: ShadowSplitData) : boolean
    }

    /**
    * Holds data of a visible light.
    */
    class VisibleLight extends System.ValueType implements System.IEquatable$1<VisibleLight> {

        /**
        * Accessor to Light component.
        */
        public get light(): UnityEngine.Light;
        /**
        * Light type.
        */
        public get lightType(): UnityEngine.LightType;
        public set lightType(value: UnityEngine.LightType);
        /**
        * Light color multiplied by intensity.
        */
        public get finalColor(): UnityEngine.Color;
        public set finalColor(value: UnityEngine.Color);
        /**
        * Light's influence rectangle on screen.
        */
        public get screenRect(): UnityEngine.Rect;
        public set screenRect(value: UnityEngine.Rect);
        /**
        * Light transformation matrix.
        */
        public get localToWorldMatrix(): UnityEngine.Matrix4x4;
        public set localToWorldMatrix(value: UnityEngine.Matrix4x4);
        /**
        * Light range.
        */
        public get range(): float;
        public set range(value: float);
        /**
        * Spot light angle.
        */
        public get spotAngle(): float;
        public set spotAngle(value: float);
        /**
        * Light intersects near clipping plane.
        */
        public get intersectsNearPlane(): boolean;
        public set intersectsNearPlane(value: boolean);
        /**
        * Light intersects far clipping plane.
        */
        public get intersectsFarPlane(): boolean;
        public set intersectsFarPlane(value: boolean);

        public Equals ($other: VisibleLight) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: VisibleLight, $right: VisibleLight) : boolean
        public static op_Inequality ($left: VisibleLight, $right: VisibleLight) : boolean
    }

    /**
    * Holds data of a visible reflection reflectionProbe.
    */
    class VisibleReflectionProbe extends System.ValueType implements System.IEquatable$1<VisibleReflectionProbe> {

        /**
        * Probe texture.
        */
        public get texture(): UnityEngine.Texture;
        /**
        * Accessor to ReflectionProbe component.
        */
        public get reflectionProbe(): UnityEngine.ReflectionProbe;
        /**
        * The probe's world space axis-aligned bounding box in which the probe can contribute to reflections.
        */
        public get bounds(): UnityEngine.Bounds;
        public set bounds(value: UnityEngine.Bounds);
        /**
        * Probe transformation matrix.
        */
        public get localToWorldMatrix(): UnityEngine.Matrix4x4;
        public set localToWorldMatrix(value: UnityEngine.Matrix4x4);
        /**
        * Shader data for probe HDR texture decoding.
        */
        public get hdrData(): UnityEngine.Vector4;
        public set hdrData(value: UnityEngine.Vector4);
        /**
        * The center of the probe's bounding box in which the probe can contribute to reflections. The center is relative to the position of the probe.
        */
        public get center(): UnityEngine.Vector3;
        public set center(value: UnityEngine.Vector3);
        /**
        * Probe blending distance.
        */
        public get blendDistance(): float;
        public set blendDistance(value: float);
        /**
        * Probe importance.
        */
        public get importance(): int;
        public set importance(value: int);
        /**
        * Should probe use box projection.
        */
        public get isBoxProjection(): boolean;
        public set isBoxProjection(value: boolean);

        public Equals ($other: VisibleReflectionProbe) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: VisibleReflectionProbe, $right: VisibleReflectionProbe) : boolean
        public static op_Inequality ($left: VisibleReflectionProbe, $right: VisibleReflectionProbe) : boolean
    }

    /**
    * Values for the depth state.
    */
    class DepthState extends System.ValueType implements System.IEquatable$1<DepthState> {

        /**
        * Default values for the depth state.
        */
        public static get defaultValue(): DepthState;
        /**
        * Controls whether pixels from this object are written to the depth buffer.
        */
        public get writeEnabled(): boolean;
        public set writeEnabled(value: boolean);
        /**
        * How should depth testing be performed.
        */
        public get compareFunction(): CompareFunction;
        public set compareFunction(value: CompareFunction);

        /**
        * Creates a new depth state with the given values.
        * @param writeEnabled Controls whether pixels from this object are written to the depth buffer.
        * @param compareFunction How should depth testing be performed.
        */
        public constructor ($writeEnabled?: boolean, $compareFunction?: CompareFunction)
        public Equals ($other: DepthState) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: DepthState, $right: DepthState) : boolean
        public static op_Inequality ($left: DepthState, $right: DepthState) : boolean
    }

    /**
    * Settings for ScriptableRenderContext.DrawRenderers.
    */
    class DrawingSettings extends System.ValueType implements System.IEquatable$1<DrawingSettings> {

        /**
        * The maxiumum number of passes that can be rendered in 1 DrawRenderers call.
        */
        public static maxShaderPasses : int
        /**
        * How to sort objects during rendering.
        */
        public get sortingSettings(): SortingSettings;
        public set sortingSettings(value: SortingSettings);
        /**
        * What kind of per-object data to setup during rendering.
        */
        public get perObjectData(): PerObjectData;
        public set perObjectData(value: PerObjectData);
        /**
        * Controls whether dynamic batching is enabled.
        */
        public get enableDynamicBatching(): boolean;
        public set enableDynamicBatching(value: boolean);
        /**
        * Controls whether instancing is enabled.
        */
        public get enableInstancing(): boolean;
        public set enableInstancing(value: boolean);
        /**
        * Sets the Material to use for all drawers that would render in this group.
        */
        public get overrideMaterial(): UnityEngine.Material;
        public set overrideMaterial(value: UnityEngine.Material);
        /**
        * Sets the shader to use for all drawers that would render in this group. Override shaders do not override existing material properties.
        */
        public get overrideShader(): UnityEngine.Shader;
        public set overrideShader(value: UnityEngine.Shader);
        /**
        * Selects which pass of the override material to use.
        */
        public get overrideMaterialPassIndex(): int;
        public set overrideMaterialPassIndex(value: int);
        /**
        * Selects which pass of the override shader to use.
        */
        public get overrideShaderPassIndex(): int;
        public set overrideShaderPassIndex(value: int);
        /**
        * Sets the Material to use for any drawers in this group that don't meet the requirements.
        */
        public get fallbackMaterial(): UnityEngine.Material;
        public set fallbackMaterial(value: UnityEngine.Material);
        /**
        * Configures what light should be used as main light.
        */
        public get mainLightIndex(): int;
        public set mainLightIndex(value: int);

        /**
        * Create a draw settings struct.
        * @param shaderPassName Shader pass to use.
        * @param sortingSettings Describes the methods to sort objects during rendering.
        */
        public constructor ($shaderPassName: ShaderTagId, $sortingSettings: SortingSettings)
        /**
        * Get the name of the shader pass.
        * @param index Index of the shader pass to use.
        */
        public GetShaderPassName ($index: int) : ShaderTagId
        /**
        * Set the name of the shader pass.
        * @param index Index of the shader pass to use.
        * @param shaderPassName Name of the shader pass.
        */
        public SetShaderPassName ($index: int, $shaderPassName: ShaderTagId) : void
        public Equals ($other: DrawingSettings) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: DrawingSettings, $right: DrawingSettings) : boolean
        public static op_Inequality ($left: DrawingSettings, $right: DrawingSettings) : boolean
    }

    /**
    * This struct describes the methods to sort objects during rendering.
    */
    class SortingSettings extends System.ValueType implements System.IEquatable$1<SortingSettings> {

        /**
        * Used to calculate the distance to objects.
        */
        public get worldToCameraMatrix(): UnityEngine.Matrix4x4;
        public set worldToCameraMatrix(value: UnityEngine.Matrix4x4);
        /**
        * Used to calculate the distance to objects.
        */
        public get cameraPosition(): UnityEngine.Vector3;
        public set cameraPosition(value: UnityEngine.Vector3);
        /**
        * Used to calculate distance to objects, by comparing the positions of objects to this axis.
        */
        public get customAxis(): UnityEngine.Vector3;
        public set customAxis(value: UnityEngine.Vector3);
        /**
        * What kind of sorting to do while rendering.
        */
        public get criteria(): SortingCriteria;
        public set criteria(value: SortingCriteria);
        /**
        * Type of sorting to use while rendering.
        */
        public get distanceMetric(): DistanceMetric;
        public set distanceMetric(value: DistanceMetric);

        /**
        * Create a sorting settings struct.
        * @param camera The camera's transparency sort mode is used to determine whether to use orthographic or distance based sorting.
        */
        public constructor ($camera: UnityEngine.Camera)
        public Equals ($other: SortingSettings) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: SortingSettings, $right: SortingSettings) : boolean
        public static op_Inequality ($left: SortingSettings, $right: SortingSettings) : boolean
    }

    /**
    * How to sort objects during rendering.
    */
    enum SortingCriteria {
        None = 0,
        SortingLayer = 1,
        RenderQueue = 2,
        BackToFront = 4,
        QuantizedFrontToBack = 8,
        OptimizeStateChanges = 16,
        CanvasOrder = 32,
        RendererPriority = 64,
        CommonOpaque = 59,
        CommonTransparent = 23 
    }

    /**
    * Type of sorting to use while rendering.
    */
    enum DistanceMetric {
        Perspective = 0,
        Orthographic = 1,
        CustomAxis = 2 
    }

    /**
    * What kind of per-object data to setup during rendering.
    */
    enum PerObjectData {
        None = 0,
        LightProbe = 1,
        ReflectionProbes = 2,
        LightProbeProxyVolume = 4,
        Lightmaps = 8,
        LightData = 16,
        MotionVectors = 32,
        LightIndices = 64,
        ReflectionProbeData = 128,
        OcclusionProbe = 256,
        OcclusionProbeProxyVolume = 512,
        ShadowMask = 1024 
    }

    /**
    * A struct that represents filtering settings for ScriptableRenderContext.DrawRenderers.
    */
    class FilteringSettings extends System.ValueType implements System.IEquatable$1<FilteringSettings> {

        /**
        * Creates a FilteringSettings struct that contains default values for all properties. With these default values, Unity does not perform any filtering.
        */
        public static get defaultValue(): FilteringSettings;
        /**
        * Unity renders objects whose Material.renderQueue value is within range specified by this Rendering.RenderQueueRange.
        */
        public get renderQueueRange(): RenderQueueRange;
        public set renderQueueRange(value: RenderQueueRange);
        /**
        * Unity renders objects whose GameObject.layer value is enabled in this bit mask.
        */
        public get layerMask(): int;
        public set layerMask(value: int);
        /**
        * Unity renders objects whose Renderer.renderingLayerMask value is enabled in this bit mask.
        */
        public get renderingLayerMask(): uint;
        public set renderingLayerMask(value: uint);
        /**
        * Determines if Unity excludes GameObjects that are in motion from rendering. This refers to GameObjects that have an active Motion Vector pass assigned to their Material or have set the Motion Vector mode to per object motion (Menu: Mesh Renderer > Additional Settings > Motion Vectors > Per Object Motion).
        * For Unity to exclude a GameObject from rendering, the GameObject must have moved since the last frame. To exclude a GameObject manually, enable a pass.
        */
        public get excludeMotionVectorObjects(): boolean;
        public set excludeMotionVectorObjects(value: boolean);
        /**
        * Unity renders objects whose SortingLayer.value value is within range specified by this Rendering.SortingLayerRange.
        */
        public get sortingLayerRange(): SortingLayerRange;
        public set sortingLayerRange(value: SortingLayerRange);

        public constructor ($renderQueueRange?: System.Nullable$1<RenderQueueRange>, $layerMask?: int, $renderingLayerMask?: uint, $excludeMotionVectorObjects?: int)
        public Equals ($other: FilteringSettings) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: FilteringSettings, $right: FilteringSettings) : boolean
        public static op_Inequality ($left: FilteringSettings, $right: FilteringSettings) : boolean
    }

    /**
    * Describes a material render queue range.
    */
    class RenderQueueRange extends System.ValueType implements System.IEquatable$1<RenderQueueRange> {

        /**
        * Minimum value that can be used as a bound.
        */
        public static minimumBound : int
        /**
        * Maximum value that can be used as a bound.
        */
        public static maximumBound : int
        /**
        * A range that includes all objects.
        */
        public static get all(): RenderQueueRange;
        /**
        * A range that includes only opaque objects.
        */
        public static get opaque(): RenderQueueRange;
        /**
        * A range that includes only transparent objects.
        */
        public static get transparent(): RenderQueueRange;
        /**
        * Inclusive lower bound for the range.
        */
        public get lowerBound(): int;
        public set lowerBound(value: int);
        /**
        * Inclusive upper bound for the range.
        */
        public get upperBound(): int;
        public set upperBound(value: int);

        /**
        * Create a render queue range struct.
        * @param lowerBound Inclusive lower bound for the range.
        * @param upperBound Inclusive upper bound for the range.
        */
        public constructor ($lowerBound: int, $upperBound: int)
        public Equals ($other: RenderQueueRange) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: RenderQueueRange, $right: RenderQueueRange) : boolean
        public static op_Inequality ($left: RenderQueueRange, $right: RenderQueueRange) : boolean
    }

    /**
    * Describes a renderer's sorting layer range.
    */
    class SortingLayerRange extends System.ValueType implements System.IEquatable$1<SortingLayerRange> {

        /**
        * Inclusive lower bound for the range.
        */
        public get lowerBound(): short;
        public set lowerBound(value: short);
        /**
        * Inclusive upper bound for the range.
        */
        public get upperBound(): short;
        public set upperBound(value: short);
        /**
        * A range that includes all objects.
        */
        public static get all(): SortingLayerRange;

        /**
        * Sets the inclusive range for a sorting layer object.
        * @param lowerBound Lowest sorting layer value to include.
        * @param upperBound Highest sorting layer value to include.
        */
        public constructor ($lowerBound: short, $upperBound: short)
        public Equals ($other: SortingLayerRange) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Inequality ($lhs: SortingLayerRange, $rhs: SortingLayerRange) : boolean
        public static op_Equality ($lhs: SortingLayerRange, $rhs: SortingLayerRange) : boolean
    }

    /**
    * Specifies whether gizmos render before or after postprocessing for a camera render.
    */
    enum GizmoSubset {
        PreImageEffects = 0,
        PostImageEffects = 1 
    }

    /**
    * ObjectId request that can be used to determine the object corresponding to each pixel. Can be submitted using either Camera.SubmitRenderRequest or RenderPipeline.SubmitRenderRequest, and the results can be used either on the CPU in C# or the GPU in a shader.
    */
    class ObjectIdRequest extends System.Object {

        /**
        * RenderTexture to store the rendering result of the request. The colors in this RenderTexture can be decoded to determine the object that was rendered at each pixel, first by decoding the color to an index using ObjectIdResult.DecodeIdFromColor and then by looking this index up in ObjectIdResult._idToObjectMapping.
        */
        public get destination(): UnityEngine.RenderTexture;
        public set destination(value: UnityEngine.RenderTexture);
        /**
        * Target mipLevel to store the rendering output.
        */
        public get mipLevel(): int;
        public set mipLevel(value: int);
        /**
        * Target Cubemap face to store the rendering result.
        */
        public get face(): UnityEngine.CubemapFace;
        public set face(value: UnityEngine.CubemapFace);
        /**
        * Target slice to store the rendering output.
        */
        public get slice(): int;
        public set slice(value: int);
        /**
        * A result field that is filled when the render request has been submitted and completed, containing the ObjectIdResult._idToObjectMapping that is needed to interpret the color-encoded object IDs that are rendered in the ObjectIdRequest._destination RenderTexture.
        */
        public get result(): ObjectIdResult;

        public constructor ($destination: UnityEngine.RenderTexture, $mipLevel?: int, $face?: UnityEngine.CubemapFace, $slice?: int)
    }

    /**
    * The results of an ObjectIdRequest, stored in ObjectIdRequest._result, containing the ObjectIdResult.idToObjectMapping that is needed to interpret the color-encoded object IDs that are rendered in the ObjectIdRequest._destination RenderTexture.
    */
    class ObjectIdResult extends System.Object {

        /**
        * An array of Objects that can be used to deterimine the object at each pixel in ObjectIdRequest._destination, first by decoding colors from ObjectIdRequest._destination to an index using ObjectIdResult.DecodeIdFromColor, and then by looking up this index in this array.
        */
        public get idToObjectMapping(): UnityEngine.Object[];

        /**
        * A utility function that can be used to decode colors from ObjectIdRequest._destination to an index that can then be looked up in ObjectIdResult._idToObjectMapping.
        */
        public static DecodeIdFromColor ($color: UnityEngine.Color) : int
    }

    /**
    * Values for the raster state.
    */
    class RasterState extends System.ValueType implements System.IEquatable$1<RasterState> {

        /**
        * Default values for the raster state.
        */
        public static defaultValue : RasterState
        /**
        * Controls which sides of polygons should be culled (not drawn).
        */
        public get cullingMode(): CullMode;
        public set cullingMode(value: CullMode);
        /**
        * Enable clipping based on depth.
        */
        public get depthClip(): boolean;
        public set depthClip(value: boolean);
        /**
        * Enables conservative rasterization. Before using check for support via SystemInfo.supportsConservativeRaster property.
        */
        public get conservative(): boolean;
        public set conservative(value: boolean);
        /**
        * Scales the minimum resolvable depth buffer value in the GPU's depth bias setting.
        */
        public get offsetUnits(): int;
        public set offsetUnits(value: int);
        /**
        * Scales the maximum Z slope in the GPU's depth bias setting.
        */
        public get offsetFactor(): float;
        public set offsetFactor(value: float);

        /**
        * Creates a new raster state with the given values.
        * @param cullingMode Controls which sides of polygons should be culled (not drawn).
        * @param offsetUnits Scales the minimum resolvable depth buffer value in the GPU's depth bias setting.
        * @param offsetFactor Scales the maximum Z slope in the GPU's depth bias setting.
        */
        public constructor ($cullingMode?: CullMode, $offsetUnits?: int, $offsetFactor?: float, $depthClip?: boolean)
        public Equals ($other: RasterState) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: RasterState, $right: RasterState) : boolean
        public static op_Inequality ($left: RasterState, $right: RasterState) : boolean
    }

    /**
    * Render Pipeline manager.
    */
    class RenderPipelineManager {

        /**
        * Returns the active RenderPipeline.
        */
        public static get currentPipeline(): RenderPipeline;
        /**
        * Indicate when Render Pipeline switch is in progress.
        */
        public static get pipelineSwitchCompleted(): boolean;

        public static add_beginFrameRendering ($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera[]>) : void
        public static add_endFrameRendering ($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera[]>) : void
        public static add_beginContextRendering ($value: System.Action$2<ScriptableRenderContext, System_Collections_Generic.List$1<UnityEngine.Camera>>) : void
        public static add_endContextRendering ($value: System.Action$2<ScriptableRenderContext, System_Collections_Generic.List$1<UnityEngine.Camera>>) : void
        public static add_beginCameraRendering ($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera>) : void
        public static add_endCameraRendering ($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera>) : void
        public static add_activeRenderPipelineTypeChanged ($value: System.Action) : void
        public static add_activeRenderPipelineAssetChanged ($value: System.Action$2<RenderPipelineAsset, RenderPipelineAsset>) : void
        public static add_activeRenderPipelineCreated ($value: System.Action) : void
        public static add_activeRenderPipelineDisposed ($value: System.Action) : void
        public static remove_beginFrameRendering ($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera[]>) : void
        public static remove_endFrameRendering ($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera[]>) : void
        public static remove_beginContextRendering ($value: System.Action$2<ScriptableRenderContext, System_Collections_Generic.List$1<UnityEngine.Camera>>) : void
        public static remove_endContextRendering ($value: System.Action$2<ScriptableRenderContext, System_Collections_Generic.List$1<UnityEngine.Camera>>) : void
        public static remove_beginCameraRendering ($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera>) : void
        public static remove_endCameraRendering ($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera>) : void
        public static remove_activeRenderPipelineTypeChanged ($value: System.Action) : void
        public static remove_activeRenderPipelineAssetChanged ($value: System.Action$2<RenderPipelineAsset, RenderPipelineAsset>) : void
        public static remove_activeRenderPipelineCreated ($value: System.Action) : void
        public static remove_activeRenderPipelineDisposed ($value: System.Action) : void
    }

    /**
    * Defines state and drawing commands that custom render pipelines use.
    */
    class ScriptableRenderContext extends System.ValueType implements System.IEquatable$1<ScriptableRenderContext> {

        /**
        * Emits UI geometry for rendering for the specified camera.
        * @param camera Camera to emit the geometry for.
        */
        public static EmitGeometryForCamera ($camera: UnityEngine.Camera) : void
        /**
        * @methodSwap BeginRenderPass_EBB7509C_ECC2BC8E
        */
        public BeginRenderPass ($width: int, $height: int, $volumeDepth: int, $samples: int, $attachments: Unity_Collections.NativeArray$1<AttachmentDescriptor>, $depthAttachmentIndex?: int) : void
        /**
        * @methodSwap BeginRenderPass_EBB7509C_H29981A33
        */
        public BeginRenderPass ($width: int, $height: int, $samples: int, $attachments: Unity_Collections.NativeArray$1<AttachmentDescriptor>, $depthAttachmentIndex?: int) : void
        public BeginScopedRenderPass ($width: int, $height: int, $samples: int, $attachments: Unity_Collections.NativeArray$1<AttachmentDescriptor>, $depthAttachmentIndex?: int) : ScopedRenderPass
        public BeginSubPass ($colors: Unity_Collections.NativeArray$1<int>, $inputs: Unity_Collections.NativeArray$1<int>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean) : void
        public BeginSubPass ($colors: Unity_Collections.NativeArray$1<int>, $inputs: Unity_Collections.NativeArray$1<int>, $isDepthStencilReadOnly?: boolean) : void
        public BeginSubPass ($colors: Unity_Collections.NativeArray$1<int>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean) : void
        public BeginSubPass ($colors: Unity_Collections.NativeArray$1<int>, $isDepthStencilReadOnly?: boolean) : void
        public BeginScopedSubPass ($colors: Unity_Collections.NativeArray$1<int>, $inputs: Unity_Collections.NativeArray$1<int>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean) : ScopedSubPass
        public BeginScopedSubPass ($colors: Unity_Collections.NativeArray$1<int>, $inputs: Unity_Collections.NativeArray$1<int>, $isDepthStencilReadOnly?: boolean) : ScopedSubPass
        public BeginScopedSubPass ($colors: Unity_Collections.NativeArray$1<int>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean) : ScopedSubPass
        public BeginScopedSubPass ($colors: Unity_Collections.NativeArray$1<int>, $isDepthStencilReadOnly?: boolean) : ScopedSubPass
        /**
        * Schedules the end of the currently active sub pass.
        */
        public EndSubPass () : void
        /**
        * Schedules the end of a currently active render pass.
        */
        public EndRenderPass () : void
        /**
        * Submits all the scheduled commands to the rendering loop for execution.
        */
        public Submit () : void
        /**
        * This method submits all the scheduled commands to the rendering loop for validation. The validation checks whether render passes that were started with the BeginRenderPass call can execute the scheduled commands.
        */
        public SubmitForRenderPassValidation () : boolean
        /**
        * Schedules the drawing of a set of visible objects, and optionally overrides the GPU's render state.
        * @param cullingResults The set of visible objects to draw. You typically obtain this from ScriptableRenderContext.Cull.
        * @param drawingSettings A struct that describes how to draw the objects.
        * @param filteringSettings A struct that describes how to filter the set of visible objects, so that Unity only draws a subset.
        * @param stateBlock A set of values that Unity uses to override the GPU's render state.
        * @param tagName The name of a.
        * @param isPassTagName If set to true, tagName specifies a.
        * @param tagValues An array of ShaderTagId structs, where the ShaderTagId.name|name is the value of a given.
        * @param renderTypes An array of ShaderTagId structs, where the ShaderTagId.name|name is the value of a that has the name "RenderType".
        * @param stateBlocks An array of structs that describe which parts of the GPU's render state to override.
        */
        public DrawRenderers ($cullingResults: CullingResults, $drawingSettings: $Ref<DrawingSettings>, $filteringSettings: $Ref<FilteringSettings>) : void
        /**
        * Schedules the drawing of a set of visible objects, and optionally overrides the GPU's render state.
        * @param cullingResults The set of visible objects to draw. You typically obtain this from ScriptableRenderContext.Cull.
        * @param drawingSettings A struct that describes how to draw the objects.
        * @param filteringSettings A struct that describes how to filter the set of visible objects, so that Unity only draws a subset.
        * @param stateBlock A set of values that Unity uses to override the GPU's render state.
        * @param tagName The name of a.
        * @param isPassTagName If set to true, tagName specifies a.
        * @param tagValues An array of ShaderTagId structs, where the ShaderTagId.name|name is the value of a given.
        * @param renderTypes An array of ShaderTagId structs, where the ShaderTagId.name|name is the value of a that has the name "RenderType".
        * @param stateBlocks An array of structs that describe which parts of the GPU's render state to override.
        */
        public DrawRenderers ($cullingResults: CullingResults, $drawingSettings: $Ref<DrawingSettings>, $filteringSettings: $Ref<FilteringSettings>, $stateBlock: $Ref<RenderStateBlock>) : void
        public DrawRenderers ($cullingResults: CullingResults, $drawingSettings: $Ref<DrawingSettings>, $filteringSettings: $Ref<FilteringSettings>, $renderTypes: Unity_Collections.NativeArray$1<ShaderTagId>, $stateBlocks: Unity_Collections.NativeArray$1<RenderStateBlock>) : void
        public DrawRenderers ($cullingResults: CullingResults, $drawingSettings: $Ref<DrawingSettings>, $filteringSettings: $Ref<FilteringSettings>, $tagName: ShaderTagId, $isPassTagName: boolean, $tagValues: Unity_Collections.NativeArray$1<ShaderTagId>, $stateBlocks: Unity_Collections.NativeArray$1<RenderStateBlock>) : void
        /**
        * Schedules the drawing of shadow casters for a single Light.
        * @param settings Specifies which set of shadow casters to draw, and how to draw them.
        */
        public DrawShadows ($settings: $Ref<ShadowDrawingSettings>) : void
        /**
        * Schedules the execution of a custom graphics Command Buffer.
        * @param commandBuffer Specifies the Command Buffer to execute.
        */
        public ExecuteCommandBuffer ($commandBuffer: CommandBuffer) : void
        /**
        * Schedules the execution of a Command Buffer on an async compute queue. The ComputeQueueType that you pass in determines the queue order.
        * @param commandBuffer The CommandBuffer to be executed.
        * @param queueType Describes the desired async compute queue the supplied CommandBuffer should be executed on.
        */
        public ExecuteCommandBufferAsync ($commandBuffer: CommandBuffer, $queueType: ComputeQueueType) : void
        /**
        * Schedules the setup of Camera specific global Shader variables.
        * @param camera Camera to setup shader variables for.
        * @param stereoSetup Set up the stereo shader variables and state.
        * @param eye The current eye to be rendered.
        */
        public SetupCameraProperties ($camera: UnityEngine.Camera, $stereoSetup?: boolean) : void
        /**
        * Schedules the setup of Camera specific global Shader variables.
        * @param camera Camera to setup shader variables for.
        * @param stereoSetup Set up the stereo shader variables and state.
        * @param eye The current eye to be rendered.
        * @methodSwap SetupCameraProperties_EBB7509C_H4B7704F9
        */
        public SetupCameraProperties ($camera: UnityEngine.Camera, $stereoSetup: boolean, $eye: int) : void
        /**
        * Schedule notification of completion of stereo rendering on a single frame.
        * @param camera Camera to indicate completion of stereo rendering.
        * @param eye The current eye to be rendered.
        */
        public StereoEndRender ($camera: UnityEngine.Camera) : void
        /**
        * Schedule notification of completion of stereo rendering on a single frame.
        * @param camera Camera to indicate completion of stereo rendering.
        * @param eye The current eye to be rendered.
        * @methodSwap StereoEndRender_EBB7509C_H9DD16062
        */
        public StereoEndRender ($camera: UnityEngine.Camera, $eye: int) : void
        /**
        * Schedule notification of completion of stereo rendering on a single frame.
        * @param camera Camera to indicate completion of stereo rendering.
        * @param eye The current eye to be rendered.
        * @methodSwap StereoEndRender_EBB7509C_AEA419E1
        */
        public StereoEndRender ($camera: UnityEngine.Camera, $eye: int, $isFinalPass: boolean) : void
        /**
        * Schedules a fine-grained beginning of stereo rendering on the ScriptableRenderContext.
        * @param camera Camera to enable stereo rendering on.
        * @param eye The current eye to be rendered.
        */
        public StartMultiEye ($camera: UnityEngine.Camera) : void
        /**
        * Schedules a fine-grained beginning of stereo rendering on the ScriptableRenderContext.
        * @param camera Camera to enable stereo rendering on.
        * @param eye The current eye to be rendered.
        * @methodSwap StartMultiEye_EBB7509C_H9DD16062
        */
        public StartMultiEye ($camera: UnityEngine.Camera, $eye: int) : void
        /**
        * Schedules a stop of stereo rendering on the ScriptableRenderContext.
        * @param camera Camera to disable stereo rendering on.
        */
        public StopMultiEye ($camera: UnityEngine.Camera) : void
        /**
        * Schedules the drawing of the skybox.
        * @param camera Camera to draw the skybox for.
        */
        public DrawSkybox ($camera: UnityEngine.Camera) : void
        /**
        * Schedules an invocation of the OnRenderObject callback for MonoBehaviour scripts.
        */
        public InvokeOnRenderObjectCallback () : void
        /**
        * Schedules the drawing of a subset of Gizmos (before or after post-processing) for the given Camera.
        * @param camera The camera of the current view.
        * @param gizmoSubset Set to GizmoSubset.PreImageEffects to draw Gizmos that should be affected by postprocessing, or GizmoSubset.PostImageEffects to draw Gizmos that should not be affected by postprocessing. See also: GizmoSubset.
        */
        public DrawGizmos ($camera: UnityEngine.Camera, $gizmoSubset: GizmoSubset) : void
        /**
        * Schedules the drawing of a wireframe overlay for a given Scene view Camera.
        * @param camera The Scene view Camera to draw the overlay for.
        */
        public DrawWireOverlay ($camera: UnityEngine.Camera) : void
        /**
        * Draw the UI overlay.
        * @param camera The camera of the current view.
        */
        public DrawUIOverlay ($camera: UnityEngine.Camera) : void
        /**
        * Performs culling based on the ScriptableCullingParameters typically obtained from the Camera currently being rendered.
        * @param parameters Parameters for culling.
        * @returns Culling results.
        */
        public Cull ($parameters: $Ref<ScriptableCullingParameters>) : CullingResults
        public Equals ($other: ScriptableRenderContext) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        /**
        * Creates a new renderers RendererList.
        * @param desc A high level descriptor that represents the set of GameObjects the RendererList contains.
        * @param param The parameters used to derive the set of GameObjects the RendererList contains.
        * @returns Returns a new RendererList based on the descriptor or parameters you pass in.
        */
        public CreateRendererList ($desc: UnityEngine_Rendering_RendererUtils.RendererListDesc) : RendererList
        /**
        * Creates a new renderers RendererList.
        * @param desc A high level descriptor that represents the set of GameObjects the RendererList contains.
        * @param param The parameters used to derive the set of GameObjects the RendererList contains.
        * @returns Returns a new RendererList based on the descriptor or parameters you pass in.
        */
        public CreateRendererList ($param: $Ref<RendererListParams>) : RendererList
        /**
        * Creates a new shadow RendererList.
        * @param settings The settings used to derive the set of GameObjects the RendererList contains when drawing shadows.
        * @returns Returns a new RendererList based on the settings you pass in.
        */
        public CreateShadowRendererList ($settings: $Ref<ShadowDrawingSettings>) : RendererList
        /**
        * Creates a new skybox RendererList.
        * @param camera The camera that is used for rendering the skybox.
        * @param projectionMatrix The projection matrix used during XR rendering of the skybox.
        * @param viewMatrix The view matrix used during XR rendering of the skybox.
        * @param projectionMatrixL The left eye projection matrix used during Legacy single pass XR rendering of the skybox.
        * @param viewMatrixL The left eye view matrix used during Legacy single pass XR rendering of the skybox.
        * @param projectionMatrixR The right eye projection matrix used during Legacy single pass XR rendering of the skybox.
        * @param viewMatrixR The right eye view matrix used during Legacy single pass XR rendering of the skybox.
        * @returns Returns a new RendererList based on the settings you pass in.
        */
        public CreateSkyboxRendererList ($camera: UnityEngine.Camera, $projectionMatrixL: UnityEngine.Matrix4x4, $viewMatrixL: UnityEngine.Matrix4x4, $projectionMatrixR: UnityEngine.Matrix4x4, $viewMatrixR: UnityEngine.Matrix4x4) : RendererList
        /**
        * Creates a new skybox RendererList.
        * @param camera The camera that is used for rendering the skybox.
        * @param projectionMatrix The projection matrix used during XR rendering of the skybox.
        * @param viewMatrix The view matrix used during XR rendering of the skybox.
        * @param projectionMatrixL The left eye projection matrix used during Legacy single pass XR rendering of the skybox.
        * @param viewMatrixL The left eye view matrix used during Legacy single pass XR rendering of the skybox.
        * @param projectionMatrixR The right eye projection matrix used during Legacy single pass XR rendering of the skybox.
        * @param viewMatrixR The right eye view matrix used during Legacy single pass XR rendering of the skybox.
        * @returns Returns a new RendererList based on the settings you pass in.
        */
        public CreateSkyboxRendererList ($camera: UnityEngine.Camera, $projectionMatrix: UnityEngine.Matrix4x4, $viewMatrix: UnityEngine.Matrix4x4) : RendererList
        /**
        * Creates a new skybox RendererList.
        * @param camera The camera that is used for rendering the skybox.
        * @param projectionMatrix The projection matrix used during XR rendering of the skybox.
        * @param viewMatrix The view matrix used during XR rendering of the skybox.
        * @param projectionMatrixL The left eye projection matrix used during Legacy single pass XR rendering of the skybox.
        * @param viewMatrixL The left eye view matrix used during Legacy single pass XR rendering of the skybox.
        * @param projectionMatrixR The right eye projection matrix used during Legacy single pass XR rendering of the skybox.
        * @param viewMatrixR The right eye view matrix used during Legacy single pass XR rendering of the skybox.
        * @returns Returns a new RendererList based on the settings you pass in.
        */
        public CreateSkyboxRendererList ($camera: UnityEngine.Camera) : RendererList
        public PrepareRendererListsAsync ($rendererLists: System_Collections_Generic.List$1<RendererList>) : void
        /**
        * Queries the status of a RendererList.
        * @param rendererList The RendererList to query.
        * @returns Returns the status of the RendererList.
        */
        public QueryRendererListStatus ($rendererList: RendererList) : RendererListStatus
        public static op_Equality ($left: ScriptableRenderContext, $right: ScriptableRenderContext) : boolean
        public static op_Inequality ($left: ScriptableRenderContext, $right: ScriptableRenderContext) : boolean
    }

    /**
    * Represents an active render pass until disposed.
    */
    class ScopedRenderPass extends System.ValueType implements System.IDisposable {

        /**
        * Ends the current render pass in the ScriptableRenderContext that was used to create the ScopedRenderPass.
        */
        public Dispose () : void
    }

    /**
    * Represents an active sub pass until disposed.
    */
    class ScopedSubPass extends System.ValueType implements System.IDisposable {

        /**
        * Ends the current sub pass in the ScriptableRenderContext that was used to create the ScopedSubPass.
        */
        public Dispose () : void
    }

    /**
    * A set of values that Unity uses to override the GPU's render state.
    */
    class RenderStateBlock extends System.ValueType implements System.IEquatable$1<RenderStateBlock> {

        /**
        * Specifies the new blend state.
        */
        public get blendState(): BlendState;
        public set blendState(value: BlendState);
        /**
        * Specifies the new raster state.
        */
        public get rasterState(): RasterState;
        public set rasterState(value: RasterState);
        /**
        * Specifies the new depth state.
        */
        public get depthState(): DepthState;
        public set depthState(value: DepthState);
        /**
        * Specifies the new stencil state.
        */
        public get stencilState(): StencilState;
        public set stencilState(value: StencilState);
        /**
        * The value to be compared against and/or the value to be written to the buffer, based on the stencil state.
        */
        public get stencilReference(): int;
        public set stencilReference(value: int);
        /**
        * Specifies which parts of the GPU's render state to override.
        */
        public get mask(): RenderStateMask;
        public set mask(value: RenderStateMask);

        /**
        * Creates a new render state block with the specified mask.
        * @param mask Specifies which parts of the GPU's render state to override.
        */
        public constructor ($mask: RenderStateMask)
        public Equals ($other: RenderStateBlock) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: RenderStateBlock, $right: RenderStateBlock) : boolean
        public static op_Inequality ($left: RenderStateBlock, $right: RenderStateBlock) : boolean
    }

    /**
    * Specifies which parts of the render state that is overriden.
    */
    enum RenderStateMask {
        Nothing = 0,
        Blend = 1,
        Raster = 2,
        Depth = 4,
        Stencil = 8,
        Everything = 15 
    }

    /**
    * Values for the stencil state.
    */
    class StencilState extends System.ValueType implements System.IEquatable$1<StencilState> {

        /**
        * Default values for the stencil state.
        */
        public static get defaultValue(): StencilState;
        /**
        * Controls whether the stencil buffer is enabled.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * An 8 bit mask as an 0–255 integer, used when comparing the reference value with the contents of the buffer.
        */
        public get readMask(): byte;
        public set readMask(value: byte);
        /**
        * An 8 bit mask as an 0–255 integer, used when writing to the buffer.
        */
        public get writeMask(): byte;
        public set writeMask(value: byte);
        /**
        * The function used to compare the reference value to the current contents of the buffer for front-facing geometry.
        */
        public get compareFunctionFront(): CompareFunction;
        public set compareFunctionFront(value: CompareFunction);
        /**
        * What to do with the contents of the buffer if the stencil test (and the depth test) passes for front-facing geometry.
        */
        public get passOperationFront(): StencilOp;
        public set passOperationFront(value: StencilOp);
        /**
        * What to do with the contents of the buffer if the stencil test fails for front-facing geometry.
        */
        public get failOperationFront(): StencilOp;
        public set failOperationFront(value: StencilOp);
        /**
        * What to do with the contents of the buffer if the stencil test passes, but the depth test fails for front-facing geometry.
        */
        public get zFailOperationFront(): StencilOp;
        public set zFailOperationFront(value: StencilOp);
        /**
        * The function used to compare the reference value to the current contents of the buffer for back-facing geometry.
        */
        public get compareFunctionBack(): CompareFunction;
        public set compareFunctionBack(value: CompareFunction);
        /**
        * What to do with the contents of the buffer if the stencil test (and the depth test) passes for back-facing geometry.
        */
        public get passOperationBack(): StencilOp;
        public set passOperationBack(value: StencilOp);
        /**
        * What to do with the contents of the buffer if the stencil test fails for back-facing geometry.
        */
        public get failOperationBack(): StencilOp;
        public set failOperationBack(value: StencilOp);
        /**
        * What to do with the contents of the buffer if the stencil test passes, but the depth test fails for back-facing geometry.
        */
        public get zFailOperationBack(): StencilOp;
        public set zFailOperationBack(value: StencilOp);

        /**
        * Creates a new stencil state with the given values.
        * @param readMask An 8 bit mask as an 0–255 integer, used when comparing the reference value with the contents of the buffer.
        * @param writeMask An 8 bit mask as an 0–255 integer, used when writing to the buffer.
        * @param enabled Controls whether the stencil buffer is enabled.
        * @param compareFunctionFront The function used to compare the reference value to the current contents of the buffer for front-facing geometry.
        * @param passOperationFront What to do with the contents of the buffer if the stencil test (and the depth test) passes for front-facing geometry.
        * @param failOperationFront What to do with the contents of the buffer if the stencil test fails for front-facing geometry.
        * @param zFailOperationFront What to do with the contents of the buffer if the stencil test passes, but the depth test fails for front-facing geometry.
        * @param compareFunctionBack The function used to compare the reference value to the current contents of the buffer for back-facing geometry.
        * @param passOperationBack What to do with the contents of the buffer if the stencil test (and the depth test) passes for back-facing geometry.
        * @param failOperationBack What to do with the contents of the buffer if the stencil test fails for back-facing geometry.
        * @param zFailOperationBack What to do with the contents of the buffer if the stencil test passes, but the depth test fails for back-facing geometry.
        * @param compareFunction The function used to compare the reference value to the current contents of the buffer.
        * @param passOperation What to do with the contents of the buffer if the stencil test (and the depth test) passes.
        * @param failOperation What to do with the contents of the buffer if the stencil test fails.
        * @param zFailOperation What to do with the contents of the buffer if the stencil test passes, but the depth test.
        */
        public constructor ($enabled?: boolean, $readMask?: byte, $writeMask?: byte, $compareFunction?: CompareFunction, $passOperation?: StencilOp, $failOperation?: StencilOp, $zFailOperation?: StencilOp)
        /**
        * Creates a new stencil state with the given values.
        * @param readMask An 8 bit mask as an 0–255 integer, used when comparing the reference value with the contents of the buffer.
        * @param writeMask An 8 bit mask as an 0–255 integer, used when writing to the buffer.
        * @param enabled Controls whether the stencil buffer is enabled.
        * @param compareFunctionFront The function used to compare the reference value to the current contents of the buffer for front-facing geometry.
        * @param passOperationFront What to do with the contents of the buffer if the stencil test (and the depth test) passes for front-facing geometry.
        * @param failOperationFront What to do with the contents of the buffer if the stencil test fails for front-facing geometry.
        * @param zFailOperationFront What to do with the contents of the buffer if the stencil test passes, but the depth test fails for front-facing geometry.
        * @param compareFunctionBack The function used to compare the reference value to the current contents of the buffer for back-facing geometry.
        * @param passOperationBack What to do with the contents of the buffer if the stencil test (and the depth test) passes for back-facing geometry.
        * @param failOperationBack What to do with the contents of the buffer if the stencil test fails for back-facing geometry.
        * @param zFailOperationBack What to do with the contents of the buffer if the stencil test passes, but the depth test fails for back-facing geometry.
        * @param compareFunction The function used to compare the reference value to the current contents of the buffer.
        * @param passOperation What to do with the contents of the buffer if the stencil test (and the depth test) passes.
        * @param failOperation What to do with the contents of the buffer if the stencil test fails.
        * @param zFailOperation What to do with the contents of the buffer if the stencil test passes, but the depth test.
        */
        public constructor ($enabled: boolean, $readMask: byte, $writeMask: byte, $compareFunctionFront: CompareFunction, $passOperationFront: StencilOp, $failOperationFront: StencilOp, $zFailOperationFront: StencilOp, $compareFunctionBack: CompareFunction, $passOperationBack: StencilOp, $failOperationBack: StencilOp, $zFailOperationBack: StencilOp)
        /**
        * The function used to compare the reference value to the current contents of the buffer.
        * @param value The value to set.
        */
        public SetCompareFunction ($value: CompareFunction) : void
        /**
        * What to do with the contents of the buffer if the stencil test (and the depth test) passes.
        * @param value The value to set.
        */
        public SetPassOperation ($value: StencilOp) : void
        /**
        * What to do with the contents of the buffer if the stencil test fails.
        * @param value The value to set.
        */
        public SetFailOperation ($value: StencilOp) : void
        /**
        * What to do with the contents of the buffer if the stencil test passes, but the depth test fails.
        * @param value The value to set.
        */
        public SetZFailOperation ($value: StencilOp) : void
        public Equals ($other: StencilState) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: StencilState, $right: StencilState) : boolean
        public static op_Inequality ($left: StencilState, $right: StencilState) : boolean
    }

    /**
    * Settings for ScriptableRenderContext.DrawShadows.
    */
    class ShadowDrawingSettings extends System.ValueType implements System.IEquatable$1<ShadowDrawingSettings> {

        /**
        * Culling results to use.
        */
        public get cullingResults(): CullingResults;
        public set cullingResults(value: CullingResults);
        /**
        * The index of the shadow-casting light to be rendered.
        */
        public get lightIndex(): int;
        public set lightIndex(value: int);
        /**
        * Set this to true to make Unity filter Renderers during shadow rendering. Unity filters Renderers based on the Rendering Layer Mask of the Renderer itself, and the Rendering Layer Mask of each shadow casting Light.
        */
        public get useRenderingLayerMaskTest(): boolean;
        public set useRenderingLayerMaskTest(value: boolean);
        /**
        * The split data.
        */
        public get splitData(): ShadowSplitData;
        public set splitData(value: ShadowSplitData);
        /**
        * Specifies the filter Unity applies to GameObjects that it renders in the shadow pass.
        */
        public get objectsFilter(): UnityEngine.ShadowObjectsFilter;
        public set objectsFilter(value: UnityEngine.ShadowObjectsFilter);
        /**
        * The projection type of the shadow-casting light to be rendered. For example, directional light shadow-maps will have orthographic projection. Spot lights will usually have perspective projection, but you might want to implement orthographically-projected box-shaped spot lights in your scriptable renderer pipeline. This member variable is accessible later, in the culling process, when rendering the shadow map.
        */
        public get projectionType(): BatchCullingProjectionType;
        public set projectionType(value: BatchCullingProjectionType);

        /**
        * Create a shadow settings object.
        * @param cullResults The cull results for this light.
        * @param lightIndex The light index.
        * @param projectionType The projection type of the shadow map. For directional lights this is usually BatchCullingProjectionType.Orthographic and for point or spot lights, it is usually BatchCullingProjectionType.Perspective.
        */
        public constructor ($cullingResults: CullingResults, $lightIndex: int, $projectionType: BatchCullingProjectionType)
        public Equals ($other: ShadowDrawingSettings) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: ShadowDrawingSettings, $right: ShadowDrawingSettings) : boolean
        public static op_Inequality ($left: ShadowDrawingSettings, $right: ShadowDrawingSettings) : boolean
    }

    /**
    * The projection type of a view that is being culled.
    */
    enum BatchCullingProjectionType {
        Unknown = 0,
        Perspective = 1,
        Orthographic = 2 
    }

    /**
    * Struct holding the arguments that are needed to create a renderers RendererList.
    */
    class RendererListParams extends System.ValueType implements System.IEquatable$1<RendererListParams> {

        /**
        * Returns an empty RendererListParams.
        */
        public static Invalid : RendererListParams
        /**
        * The set of visible objects to draw. You typically obtain this from ScriptableRenderContext.Cull.
        */
        public cullingResults : CullingResults
        /**
        * A struct that describes how to draw the objects.
        */
        public drawSettings : DrawingSettings
        /**
        * A struct that describes how to filter the set of visible objects, so that Unity only draws a subset.
        */
        public filteringSettings : FilteringSettings
        /**
        * The name of a.
        */
        public tagName : ShaderTagId
        /**
        * If set to true, tagName specifies a.
        */
        public isPassTagName : boolean
        /**
        * An array of ShaderTagId structs, where the ShaderTagId.name|name is the value of a given.
        */
        public tagValues : System.Nullable$1<Unity_Collections.NativeArray$1<ShaderTagId>>
        /**
        * An array of structs that describe which parts of the GPU's render state to override.
        */
        public stateBlocks : System.Nullable$1<Unity_Collections.NativeArray$1<RenderStateBlock>>

        /**
        * Create a RendererListParams struct.
        * @param cullingResults The set of visible objects to draw. You typically obtain this from ScriptableRenderContext.Cull.
        * @param drawSettings A struct that describes how to draw the objects.
        * @param filteringSettings A struct that describes how to filter the set of visible objects, so that Unity only draws a subset.
        */
        public constructor ($cullingResults: CullingResults, $drawSettings: DrawingSettings, $filteringSettings: FilteringSettings)
        public Equals ($other: RendererListParams) : boolean
        public Equals ($obj: any) : boolean
        public GetHashCode () : int
        public static op_Equality ($left: RendererListParams, $right: RendererListParams) : boolean
        public static op_Inequality ($left: RendererListParams, $right: RendererListParams) : boolean
    }

    /**
    * Options that represent the result of a ScriptableRenderContext.QueryRendererList operation.
    */
    enum RendererListStatus {
        kRendererListInvalid = -2,
        kRendererListProcessing = -1,
        kRendererListEmpty = 0,
        kRendererListPopulated = 1 
    }

    /**
    * Describes the rendering features supported by a given render pipeline.
    */
    class SupportedRenderingFeatures extends System.Object {

        /**
        * Get / Set a SupportedRenderingFeatures.
        */
        public static get active(): SupportedRenderingFeatures;
        public static set active(value: SupportedRenderingFeatures);
        /**
        * Flags for supported reflection probes.
        */
        public get reflectionProbeModes(): UnityEngine_Rendering_SupportedRenderingFeatures.ReflectionProbeModes;
        public set reflectionProbeModes(value: UnityEngine_Rendering_SupportedRenderingFeatures.ReflectionProbeModes);
        /**
        * This is the fallback mode if the mode the user had previously selected is no longer available. See SupportedRenderingFeatures.mixedLightingModes.
        */
        public get defaultMixedLightingModes(): UnityEngine_Rendering_SupportedRenderingFeatures.LightmapMixedBakeModes;
        public set defaultMixedLightingModes(value: UnityEngine_Rendering_SupportedRenderingFeatures.LightmapMixedBakeModes);
        /**
        * Specifies what LightmapMixedBakeModes that are supported. Please define a SupportedRenderingFeatures.defaultMixedLightingModes in case multiple modes are supported.
        */
        public get mixedLightingModes(): UnityEngine_Rendering_SupportedRenderingFeatures.LightmapMixedBakeModes;
        public set mixedLightingModes(value: UnityEngine_Rendering_SupportedRenderingFeatures.LightmapMixedBakeModes);
        /**
        * What baking types are supported. The unsupported ones will be hidden from the UI. See LightmapBakeType.
        */
        public get lightmapBakeTypes(): UnityEngine.LightmapBakeType;
        public set lightmapBakeTypes(value: UnityEngine.LightmapBakeType);
        /**
        * Specifies what modes are supported. Has to be at least one. See LightmapsMode.
        */
        public get lightmapsModes(): UnityEngine.LightmapsMode;
        public set lightmapsModes(value: UnityEngine.LightmapsMode);
        /**
        * Determines if Enlighten Realtime Global Illumination lightmapper is supported by the currently selected pipeline. If it is not supported, Enlighten-specific settings do not appear in the Editor, which then defaults to the CPU Lightmapper.
        */
        public get enlighten(): boolean;
        public set enlighten(value: boolean);
        /**
        * Are light probe proxy volumes supported?
        */
        public get lightProbeProxyVolumes(): boolean;
        public set lightProbeProxyVolumes(value: boolean);
        /**
        * Are motion vectors supported?
        */
        public get motionVectors(): boolean;
        public set motionVectors(value: boolean);
        /**
        * Can renderers support receiving shadows?
        */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
        * Are reflection probes supported?
        */
        public get reflectionProbes(): boolean;
        public set reflectionProbes(value: boolean);
        /**
        * If this property is true, the blend distance field in the Reflection Probe Inspector window is editable.
        */
        public get reflectionProbesBlendDistance(): boolean;
        public set reflectionProbesBlendDistance(value: boolean);
        /**
        * Determines if the renderer supports renderer priority sorting.
        */
        public get rendererPriority(): boolean;
        public set rendererPriority(value: boolean);
        /**
        * Determines whether the function to render UI overlays is called by SRP and not by the engine.
        */
        public get rendersUIOverlay(): boolean;
        public set rendersUIOverlay(value: boolean);
        /**
        * Determines if the renderer will override the Environment Lighting and will no longer need the built-in UI for it.
        */
        public get overridesEnvironmentLighting(): boolean;
        public set overridesEnvironmentLighting(value: boolean);
        /**
        * Determines if the renderer will override the fog settings in the Lighting Panel and will no longer need the built-in UI for it.
        */
        public get overridesFog(): boolean;
        public set overridesFog(value: boolean);
        /**
        * Specifies whether the render pipeline overrides the real-time Reflection Probes settings in the Quality settings. If It does, the render pipeline does not need the built-in UI for real-time Reflection Probes settings.
        */
        public get overridesRealtimeReflectionProbes(): boolean;
        public set overridesRealtimeReflectionProbes(value: boolean);
        /**
        * Determines if the renderer will override halo and flare settings in the Lighting Panel and will no longer need the built-in UI for it.
        */
        public get overridesOtherLightingSettings(): boolean;
        public set overridesOtherLightingSettings(value: boolean);
        /**
        * Determines whether the Scriptable Render Pipeline will override the default Material’s Render Queue settings and, if true, hides the Render Queue property in the Inspector.
        */
        public get editableMaterialRenderQueue(): boolean;
        public set editableMaterialRenderQueue(value: boolean);
        /**
        * Specifies whether the renderer overrides the LOD bias settings in the Quality Settings Panel. If It does, the renderer does not need the built-in UI for LOD bias settings.
        */
        public get overridesLODBias(): boolean;
        public set overridesLODBias(value: boolean);
        /**
        * Specifies whether the renderer overrides the maximum LOD level settings in the Quality Settings Panel. If It does, the renderer does not need the built-in UI for maximum LOD level settings.
        */
        public get overridesMaximumLODLevel(): boolean;
        public set overridesMaximumLODLevel(value: boolean);
        /**
        * Specifies whether the renderer overrides the Enable LOD Cross Fade settings in the Quality Settings Panel. If It does, the renderer does not need the built-in UI for Enable LOD Cross Fade settings.
        */
        public get overridesEnableLODCrossFade(): boolean;
        public set overridesEnableLODCrossFade(value: boolean);
        /**
        * Determines whether the Renderer supports probe lighting.
        */
        public get rendererProbes(): boolean;
        public set rendererProbes(value: boolean);
        /**
        * Determines if the renderer supports Particle System GPU instancing.
        */
        public get particleSystemInstancing(): boolean;
        public set particleSystemInstancing(value: boolean);
        /**
        * Determines if this renderer supports automatic ambient probe generation.
        */
        public get autoAmbientProbeBaking(): boolean;
        public set autoAmbientProbeBaking(value: boolean);
        /**
        * Determines if this renderer supports automatic default reflection probe generation.
        */
        public get autoDefaultReflectionProbeBaking(): boolean;
        public set autoDefaultReflectionProbeBaking(value: boolean);
        /**
        * Specifies whether the render pipeline overrides the Shadowmask settings in the Quality settings.
        */
        public get overridesShadowmask(): boolean;
        public set overridesShadowmask(value: boolean);
        /**
        * Determines if the renderer will override the light probe system with a different one.
        */
        public get overridesLightProbeSystem(): boolean;
        public set overridesLightProbeSystem(value: boolean);
        /**
        * If True, the renderer supports HDR display output.
        */
        public get supportsHDR(): boolean;
        public set supportsHDR(value: boolean);
        /**
        * The message to display in the LightProbeGroup editor if the light probe system is overridden by the renderer.
        */
        public get overridesLightProbeSystemWarningMessage(): string;
        public set overridesLightProbeSystemWarningMessage(value: string);

        public constructor ()
    }

    /**
    * The batch ID.
    */
    class BatchID extends System.ValueType implements System.IEquatable$1<BatchID> {

        public static Null : BatchID
        public value : uint

        public GetHashCode () : int
        public Equals ($obj: any) : boolean
        public Equals ($other: BatchID) : boolean
        public CompareTo ($other: BatchID) : int
        public static op_Equality ($a: BatchID, $b: BatchID) : boolean
        public static op_Inequality ($a: BatchID, $b: BatchID) : boolean
    }

    /**
    * The batch Material ID.
    */
    class BatchMaterialID extends System.ValueType implements System.IEquatable$1<BatchMaterialID> {

        public static Null : BatchMaterialID
        public value : uint

        public GetHashCode () : int
        public Equals ($obj: any) : boolean
        public Equals ($other: BatchMaterialID) : boolean
        public CompareTo ($other: BatchMaterialID) : int
        public static op_Equality ($a: BatchMaterialID, $b: BatchMaterialID) : boolean
        public static op_Inequality ($a: BatchMaterialID, $b: BatchMaterialID) : boolean
    }

    /**
    * The batch mesh ID.
    */
    class BatchMeshID extends System.ValueType implements System.IEquatable$1<BatchMeshID> {

        public static Null : BatchMeshID
        public value : uint

        public GetHashCode () : int
        public Equals ($obj: any) : boolean
        public Equals ($other: BatchMeshID) : boolean
        public CompareTo ($other: BatchMeshID) : int
        public static op_Equality ($a: BatchMeshID, $b: BatchMeshID) : boolean
        public static op_Inequality ($a: BatchMeshID, $b: BatchMeshID) : boolean
    }

    /**
    * Rendering options for the BatchDrawCommand struct.
    */
    enum BatchDrawCommandFlags {
        None = 0,
        FlipWinding = 1,
        HasMotion = 2,
        IsLightMapped = 4,
        HasSortingPosition = 8,
        LODCrossFade = 16 
    }

    /**
    * Additional parameters for the current culling context
    */
    enum BatchCullingFlags {
        None = 0,
        CullLightmappedShadowCasters = 1 
    }

    /**
    * The type of an object that is requesting culling.
    */
    enum BatchCullingViewType {
        Unknown = 0,
        Camera = 1,
        Light = 2,
        Picking = 3,
        SelectionOutline = 4 
    }

    /**
    * Expected target for the buffer passed to BatchRendererGroup.AddBatch.
    */
    enum BatchBufferTarget {
        Unknown = 0,
        UnsupportedByUnderlyingGraphicsApi = -1,
        RawBuffer = 1,
        ConstantBuffer = 2 
    }

    /**
    * The ID of the view from which Unity invoked the culling.
    */
    class BatchPackedCullingViewID extends System.ValueType implements System.IEquatable$1<BatchPackedCullingViewID> {

        public constructor ($instanceID: int, $sliceIndex: int)
        /**
        * Returns the hash code for the ID.
        */
        public GetHashCode () : int
        /**
        * Returns true if the ID in the argument equals this view ID.
        */
        public Equals ($other: BatchPackedCullingViewID) : boolean
        /**
        * Returns true if the ID in the argument equals this view ID.
        */
        public Equals ($obj: any) : boolean
        /**
        * Returns the instance ID of the GameObject from which Unity performs the culling (for example, Camera, Light, etc.).
        */
        public GetInstanceID () : int
        /**
        * Returns the slice index of the culled view. The slice index depends on the view type. For cameras, the slice index is always zero. For cascaded shadow maps, it is equal to the index of the cascade.
        */
        public GetSliceIndex () : int
        public static op_Equality ($lhs: BatchPackedCullingViewID, $rhs: BatchPackedCullingViewID) : boolean
        public static op_Inequality ($lhs: BatchPackedCullingViewID, $rhs: BatchPackedCullingViewID) : boolean
    }

    /**
    * Represents a draw command for a Rendering.BatchRendererGroup.
    */
    class BatchDrawCommand extends System.ValueType {

        /**
        * The index of the element in Rendering.BatchCullingOutputDrawCommands.visibleInstances that matches the first instance in this draw command.
        */
        public visibleOffset : uint
        /**
        * The number of instances to draw with this draw command. This must be a value greater than 1.
        */
        public visibleCount : uint
        /**
        * The batch ID that this draw command uses. Determines the metadata values that are available to a shader.
        */
        public batchID : BatchID
        /**
        * Identifies which Material to use to render the instances in this draw command.
        */
        public materialID : BatchMaterialID
        /**
        * Identifies which Mesh to use to render the instances in this draw command.
        */
        public meshID : BatchMeshID
        /**
        * Specifies which sub-mesh of the Mesh identified by Rendering.BatchDrawCommand.meshID to use to render the instances in this draw command.
        */
        public submeshIndex : ushort
        /**
        * Indicates which splits that the draw command is visible in.
        */
        public splitVisibilityMask : ushort
        /**
        * Specifies rendering options for the draw command.
        */
        public flags : BatchDrawCommandFlags
        /**
        * Together with Rendering.BatchDrawCommand.flags, this specifies how to depth sort the instances in this draw command.
        */
        public sortingPosition : int

    }

    /**
    * Represents settings that Unity applies to draw commands in this Rendering.BatchDrawRange|draw range.
    */
    class BatchFilterSettings extends System.ValueType {

        /**
        * The rendering layer mask to use for draw commands in this draw range.
        */
        public renderingLayerMask : uint
        /**
        * The layer to use for draw commands in this draw range.
        */
        public layer : byte
        /**
        * Specifies how to generate motion vectors in this draw range.
        */
        public get motionMode(): UnityEngine.MotionVectorGenerationMode;
        public set motionMode(value: UnityEngine.MotionVectorGenerationMode);
        /**
        * Specifies how instances from the draw commands in this draw range cast shadows.
        */
        public get shadowCastingMode(): ShadowCastingMode;
        public set shadowCastingMode(value: ShadowCastingMode);
        /**
        * ndicates whether instances from draw commands in this draw range should receive shadows.
        */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
        * Indicates whether instances from the draw commands in this draw range render into cached shadow maps.
        */
        public get staticShadowCaster(): boolean;
        public set staticShadowCaster(value: boolean);
        /**
        * Indicates whether all draw commands in the current draw range have the Rendering.BatchDrawCommandFlags.HasSortingPosition flag set.
        */
        public get allDepthSorted(): boolean;
        public set allDepthSorted(value: boolean);

    }

    /**
    * Specifies a draw range of Rendering.BatchFilterSettings|draw commands.
    */
    class BatchDrawRange extends System.ValueType {

        /**
        * The index of the first Rendering.BatchFilterSettings|draw command inside the Rendering.BatchCullingOutput.drawCommands array that this draw range applies to.
        */
        public drawCommandsBegin : uint
        /**
        * The number of Rendering.BatchFilterSettings|draw commands, starting from Rendering.BatchDrawRange.drawCommandsBegin, this draw range applies to.
        */
        public drawCommandsCount : uint
        /**
        * The Rendering.BatchFilterSettings that apply to draw commands in this draw range.
        */
        public filterSettings : BatchFilterSettings

    }

    /**
    * Draw commands generated by the culling request.
    */
    class BatchCullingOutputDrawCommands extends System.ValueType {

        /**
        * The number of elements in the Rendering.BatchCullingOutputDrawCommands.drawCommands array.
        */
        public drawCommandCount : int
        /**
        * The number of elements in the Rendering.BatchCullingOutputDrawCommands.visibleInstances array.
        */
        public visibleInstanceCount : int
        /**
        * The number of elements in the Rendering.BatchCullingOutputDrawCommands.drawRanges array.
        */
        public drawRangeCount : int
        /**
        * If Rendering.BatchDrawCommandFlags.HasSortingPosition is set for one or more draw commands, this contains float3 world-space positions that Unity uses for depth sorting.
        */
        public instanceSortingPositionFloatCount : int

    }

    /**
    * Contains a single metadata value for a batch.
    */
    class MetadataValue extends System.ValueType {

        /**
        * The name ID of the property that the metadata value is tied to. To specify a value for a property declared with UNITY_DOTS_INSTANCED_PROP(float4, Example), pass Shader.PropertyToID("Example") here.
        */
        public NameID : int
        /**
        * Unity passes this uint32 value to the shader for this property. The value is shared between all instances in the batch.
        * Usage example: provide a buffer address for the property.
        */
        public Value : uint

    }

    /**
    * This struct contains the properties of a culling split.
    */
    class CullingSplit extends System.ValueType {

        /**
        * The center of the culling sphere.
        */
        public sphereCenter : UnityEngine.Vector3
        /**
        * The radius of the culling sphere.
        */
        public sphereRadius : float
        /**
        * The index of the first plane in this split in BatchCullingContext.cullingPlanes.
        */
        public cullingPlaneOffset : int
        /**
        * The number of culling planes this split has in BatchCullingContext.cullingPlanes.
        */
        public cullingPlaneCount : int
        /**
        * Cascade blend culling factor.
        */
        public cascadeBlendCullingFactor : float
        /**
        * The near plane distance of the culling frustum.
        */
        public nearPlane : float
        /**
        * Culling matrix.
        */
        public cullingMatrix : UnityEngine.Matrix4x4

    }

    /**
    * Culling context for a batch.
    */
    class BatchCullingContext extends System.ValueType {

        /**
        * Planes to cull against.
        */
        public cullingPlanes : Unity_Collections.NativeArray$1<UnityEngine.Plane>
        /**
        * The array of CullingSplit structs.
        */
        public cullingSplits : Unity_Collections.NativeArray$1<CullingSplit>
        /**
        * Additional resources: LODParameters.
        */
        public lodParameters : LODParameters
        /**
        * Local to world matrix.
        */
        public localToWorldMatrix : UnityEngine.Matrix4x4
        /**
        * The type of the view from which the culling is invoked. Usage examples: skip culling, take different culling paths depending on the view type, etc.
        */
        public viewType : BatchCullingViewType
        /**
        * The projection of the view from which the culling is invoked. Usage example: take different culling paths for orthographic vs perspective views.
        */
        public projectionType : BatchCullingProjectionType
        /**
        * Additional culling information for the current context.
        */
        public cullingFlags : BatchCullingFlags
        /**
        * The ID of the object from which the culling is invoked. Usage example: store culling-related data for each object.
        */
        public viewID : BatchPackedCullingViewID
        /**
        * The cullingLayerMask value of the object from which the culling is invoked. The draw command is discarded by the internal culling if the expression (1 << layer) & cullingLayerMask is false. Using this field is optional, use it for performance or other optimization purposes.
        */
        public cullingLayerMask : uint
        /**
        * Use this bit mask to discard the draw commands in a particular context. A draw command is not discarded if the expression (1 << layer) & sceneCullingMask is true. This field is typically used when rendering Editor previews.
        */
        public sceneCullingMask : bigint
        /**
        * The index of the first receiver plane in the BatchCullingContext.cullingPlanes array.
        */
        public receiverPlaneOffset : int
        /**
        * The number of receiver planes.
        */
        public receiverPlaneCount : int

    }

    /**
    * Contains the output data where OnPerformCulling will write draw commands into.
    */
    class BatchCullingOutput extends System.ValueType {

        /**
        * A single-element array of BatchCullingOutputDrawCommands that OnPerformCulling can write into without unnecessary copying.
        */
        public drawCommands : Unity_Collections.NativeArray$1<BatchCullingOutputDrawCommands>

    }

    /**
    * Thread-safe and Burst-safe API for interacting with a BatchRendererGroup from Burst jobs.
    */
    class ThreadedBatchContext extends System.ValueType {

        /**
        * An internal handle to the BatchRendererGroup object that created this threaded context.
        */
        public batchRendererGroup : System.IntPtr

        public AddBatch ($batchMetadata: Unity_Collections.NativeArray$1<MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle) : BatchID
        /**
        * @methodSwap AddBatch_EBB7509C_H823016B7
        */
        public AddBatch ($batchMetadata: Unity_Collections.NativeArray$1<MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle, $bufferOffset: uint, $windowSize: uint) : BatchID
        /**
        * Change the GraphicsBuffer associated with the given batch. Thread-safe alias for BatchRendererGroup.SetBatchBuffer.
        * @param batchID Unity changes the batch with this ID.
        * @param buffer The GraphicsBufferHandle of the GraphicsBuffer to be associated with the batch.
        */
        public SetBatchBuffer ($batchID: BatchID, $buffer: UnityEngine.GraphicsBufferHandle) : void
        /**
        * Thread-safe alias for BatchRendererGroup.RemoveBatch.
        * @param batchID Unity removes the batch with this ID.
        */
        public RemoveBatch ($batchID: BatchID) : void
    }

    /**
    * A BatchRendererGroup is an object that lets you perform customizable high performance rendering.
    */
    class BatchRendererGroup extends System.Object implements System.IDisposable {

        /**
        * The buffer target BatchRendererGroup.AddBatch accepts for the active graphics API.
        */
        public static get BufferTarget(): BatchBufferTarget;

        /**
        * Constructor for a BatchRendererGroup object.
        * @param cullingCallback Unity calls this callback when this BatchRendererGroup performs culling.
        * @param userContext Optional callback argument. A pointer to custom data.
        */
        public constructor ($cullingCallback: UnityEngine_Rendering_BatchRendererGroup.OnPerformCulling, $userContext: System.IntPtr)
        /**
        * Deletes a group.
        */
        public Dispose () : void
        /**
        * Get the thread-safe API for interacting with a BatchRendererGroup from Burst jobs.
        * @returns Thread-safe and Burst-safe context.
        */
        public GetThreadedBatchContext () : ThreadedBatchContext
        public AddBatch ($batchMetadata: Unity_Collections.NativeArray$1<MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle) : BatchID
        /**
        * @methodSwap AddBatch_EBB7509C_H823016B7
        */
        public AddBatch ($batchMetadata: Unity_Collections.NativeArray$1<MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle, $bufferOffset: uint, $windowSize: uint) : BatchID
        /**
        * Delete a batch that was previously created with AddBatch.
        * @param batchID Batch ID.
        */
        public RemoveBatch ($batchID: BatchID) : void
        /**
        * Change the GraphicsBuffer associated with the given batch.
        * @param batchID Unity changes the batch with this ID.
        * @param buffer The GraphicsBufferHandle of the GraphicsBuffer to be associated with the batch.
        */
        public SetBatchBuffer ($batchID: BatchID, $buffer: UnityEngine.GraphicsBufferHandle) : void
        /**
        * Registers a Material in BatchRendererGroup and returns its BatchMaterialID. Each registration of a specific Material increases its number of owners by 1.
        * @param material Unity Material.
        * @returns BatchRendererGroup Material ID.
        */
        public RegisterMaterial ($material: UnityEngine.Material) : BatchMaterialID
        /**
        * Registers a Material in BatchRendererGroup and returns its BatchMaterialID. Each registration of a specific Material increases its number of owners by 1.
        * @param materialInstanceID Unity Material's InstanceID.
        * @returns BatchRendererGroup Material ID.
        * @methodSwap RegisterMaterial_EBB7509C_F92D023A
        */
        public RegisterMaterial ($materialInstanceID: int) : BatchMaterialID
        /**
        * Unregister the Material ID associated with BatchRendererGroup. Each deregistration of a specific Material reduces its number of owners by 1.
        * @param material BatchRendererGroup Material ID.
        */
        public UnregisterMaterial ($material: BatchMaterialID) : void
        /**
        * Returns the previously registered Material associated with this MaterialID.
        * @param material BatchRendererGroup Material ID.
        * @returns Unity Material.
        */
        public GetRegisteredMaterial ($material: BatchMaterialID) : UnityEngine.Material
        /**
        * Registers a mesh in BatchRendererGroup and returns its BatchMeshID. Each registration of a specific mesh increases its number of owners by 1.
        * @param mesh Unity mesh.
        * @returns BatchRendererGroup mesh ID.
        */
        public RegisterMesh ($mesh: UnityEngine.Mesh) : BatchMeshID
        /**
        * Registers a mesh in BatchRendererGroup and returns its BatchMeshID. Each registration of a specific mesh increases its number of owners by 1.
        * @param meshInstanceID Unity Mesh's InstanceID.
        * @returns BatchRendererGroup mesh ID.
        * @methodSwap RegisterMesh_EBB7509C_F92D023A
        */
        public RegisterMesh ($meshInstanceID: int) : BatchMeshID
        /**
        * Unregister the mesh ID associated with BatchRendererGroup. Each deregistration of a specific mesh reduces its number of owners by 1.
        * @param mesh BatchRendererGroup mesh ID.
        */
        public UnregisterMesh ($mesh: BatchMeshID) : void
        /**
        * Returns the previously registered Mesh associated with this MeshID.
        * @param mesh BatchRendererGroup Mesh ID.
        * @returns Unity Mesh.
        */
        public GetRegisteredMesh ($mesh: BatchMeshID) : UnityEngine.Mesh
        /**
        * Set the bounds of the BatchRendererGroup. The bounds should encapsulate the render bounds of every object rendered with this BatchRendererGroup. Unity uses these bounds internally for culling.
        * @param bounds The center and the size of the global batch bounding box.
        */
        public SetGlobalBounds ($bounds: UnityEngine.Bounds) : void
        /**
        * Set the material that Unity uses to render object picking data using the draw commands in the Scene view.
        * @param material Unity Material.
        */
        public SetPickingMaterial ($material: UnityEngine.Material) : void
        /**
        * Set the error material for the BatchRendererGroup. This material will be used internally by Unity to render the draw commands referring to erroneous shaders. You can also pass 'null' to this method to unset the material.
        * @param material The material to display when there is a problem with a shader or material. If this value is null, Unity does not display anything.
        */
        public SetErrorMaterial ($material: UnityEngine.Material) : void
        /**
        * Set the loading material for the BatchRendererGroup.
        * @param material The material to display while a shader is compiling. If this value is null, Unity does not display anything.
        */
        public SetLoadingMaterial ($material: UnityEngine.Material) : void
        /**
        * Set the combination of BatchCullingViewType for which this BatchRendererGroup should receive an OnPerformCulling callback.
        * @param viewTypes The BatchCullingViewType array.
        */
        public SetEnabledViewTypes ($viewTypes: BatchCullingViewType[]) : void
        /**
        * Defines the maxiumum amount (in bytes) the BatchRendererGroup constant buffer window size is visible from the shader.
        * @returns The maximum window size in bytes.
        */
        public static GetConstantBufferMaxWindowSize () : int
        /**
        * @returns The alignment (in bytes) you should use to offset any data in the Uniform Buffer Object (UBO).
        */
        public static GetConstantBufferOffsetAlignment () : int
    }

    /**
    * Represents an identifier of a specific Pass in a Shader.
    */
    class PassIdentifier extends System.ValueType implements System.IEquatable$1<PassIdentifier> {

        /**
        * The index of the subshader within the shader (Read Only).
        */
        public get SubshaderIndex(): uint;
        /**
        * The index of the pass within the subshader (Read Only).
        */
        public get PassIndex(): uint;

        /**
        * Constructs a new PassIdentifier with the given subshaderIndex and passIndex.
        * @param subshaderIndex The index of the SubShader the Pass belongs to.
        * @param passIndex The index of the Pass in the SubShader.
        */
        public constructor ($subshaderIndex: uint, $passIndex: uint)
        public Equals ($o: any) : boolean
        public Equals ($rhs: PassIdentifier) : boolean
        public GetHashCode () : int
        public static op_Equality ($lhs: PassIdentifier, $rhs: PassIdentifier) : boolean
        public static op_Inequality ($lhs: PassIdentifier, $rhs: PassIdentifier) : boolean
    }

    /**
    * A collection of Rendering.ShaderKeyword that represents a specific platform variant.
    */
    class PlatformKeywordSet extends System.ValueType {

        /**
        * Check whether a specific shader keyword is enabled.
        */
        public IsEnabled ($define: BuiltinShaderDefine) : boolean
        public Enable ($define: BuiltinShaderDefine) : void
        public Disable ($define: BuiltinShaderDefine) : void
    }

    /**
    * Represents an identifier for a specific code path in a shader.
    */
    class ShaderKeyword extends System.ValueType {

        /**
        * The name of the shader keyword. (Read Only)
        */
        public get name(): string;
        /**
        * The index of the shader keyword.
        */
        public get index(): int;

        /**
        * Initializes a new instance of the ShaderKeyword class from a shader global keyword name.
        * @param keywordName The name of the keyword.
        */
        public constructor ($keywordName: string)
        /**
        * Initializes a new instance of the ShaderKeyword class from a local shader keyword name.
        * @param shader The shader that declares the keyword.
        * @param keywordName The name of the keyword.
        */
        public constructor ($shader: UnityEngine.Shader, $keywordName: string)
        /**
        * Initializes a new instance of the ShaderKeyword class from a local shader keyword name, and the compute shader that defines that local keyword.
        * @param shader The compute shader that declares the local keyword.
        * @param keywordName The name of the keyword.
        */
        public constructor ($shader: UnityEngine.ComputeShader, $keywordName: string)
        /**
        * Returns the type of global keyword: built-in or user defined.
        */
        public static GetGlobalKeywordType ($index: ShaderKeyword) : ShaderKeywordType
        /**
        * Returns true if the keyword is local.
        */
        public static IsKeywordLocal ($keyword: ShaderKeyword) : boolean
        /**
        * Checks whether the global shader keyword exists.
        * @returns Returns true if the global shader keyword exists. Otherwise, returns false.
        */
        public IsValid () : boolean
        /**
        * Checks whether the shader keyword exists in the compute shader you pass in.
        * @param shader The shader that declares the keyword.
        * @returns Returns true if the shader keyword exists. Otherwise, returns false.
        */
        public IsValid ($shader: UnityEngine.ComputeShader) : boolean
        /**
        * Checks whether the shader keyword exists in the shader you pass in.
        * @param shader The shader that declares the keyword.
        * @returns Returns true if the shader keyword exists. Otherwise, returns false.
        */
        public IsValid ($shader: UnityEngine.Shader) : boolean
        public ToString () : string
    }

    /**
    * A collection of Rendering.ShaderKeyword that represents a specific shader variant.
    */
    class ShaderKeywordSet extends System.ValueType {

        /**
        * Check whether a specific shader keyword is enabled.
        */
        public IsEnabled ($keyword: ShaderKeyword) : boolean
        /**
        * Check whether a specific shader keyword is enabled.
        */
        public IsEnabled ($keyword: GlobalKeyword) : boolean
        /**
        * Check whether a specific shader keyword is enabled.
        */
        public IsEnabled ($keyword: LocalKeyword) : boolean
        /**
        * Enable a specific shader keyword.
        */
        public Enable ($keyword: ShaderKeyword) : void
        /**
        * Disable a specific shader keyword.
        */
        public Disable ($keyword: ShaderKeyword) : void
        /**
        * Return an array with all the enabled keywords in the ShaderKeywordSet.
        */
        public GetShaderKeywords () : ShaderKeyword[]
    }

    /**
    * Adding a SortingGroup component to a GameObject will ensure that all Renderers within the GameObject's descendants will be sorted and rendered together.
    */
    class SortingGroup extends UnityEngine.Behaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;
        /**
        * Name of the Renderer's sorting layer.
        */
        public get sortingLayerName(): string;
        public set sortingLayerName(value: string);
        /**
        * Unique ID of the Renderer's sorting layer.
        */
        public get sortingLayerID(): int;
        public set sortingLayerID(value: int);
        /**
        * Renderer's order within a sorting layer.
        */
        public get sortingOrder(): int;
        public set sortingOrder(value: int);
        /**
        * Ignores any parent SortingGroup and sorts this and its descendant Renderers against other Renderers at the root level.
        */
        public get sortAtRoot(): boolean;
        public set sortAtRoot(value: boolean);

        private constructor ()
        /**
        * Updates all Sorting Group immediately.
        */
        public static UpdateAllSortingGroups () : void
        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : UnityEngine.Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : UnityEngine.Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<UnityEngine.Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : UnityEngine.Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component[]
        public GetComponentsInChildren ($t: System.Type) : UnityEngine.Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : UnityEngine.Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component[]
        public GetComponentsInParent ($t: System.Type) : UnityEngine.Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : UnityEngine.Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<UnityEngine.Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
    }

    interface CommandBuffer {

        /**
        * Adds a command to put a given render target into fast GPU memory.
        * @param rid The render target to put into fast GPU memory.
        * @param fastMemoryFlags The memory layout to use if only part of the render target is put into fast GPU memory, either because of the residency parameter or because of fast GPU memory availability.
        * @param residency The amount of the render target to put into fast GPU memory. Valid values are 0.0f - 1.0f inclusive.
        A value of 0.0f is equal to none of the render target, and a value of 1.0f is equal to the whole render target.
        
        * @param copyContents When this value is true, Unity copies the existing contents of the render target into fast memory.
        When this value is false, Unity does not copy the existing contents of the render target into fast memory.
        Set this value to true if you plan to add to the existing contents, and set it to false if you plan to overwrite or clear the existing contents.
        Where possible, set this value to false for better performance.
        
        * @extension UnityEngine.Rendering.CommandBufferExtensions.SwitchIntoFastMemory
        */
        SwitchIntoFastMemory ($rid: RenderTargetIdentifier, $fastMemoryFlags: FastMemoryFlags, $residency: float, $copyContents: boolean) : void
        /**
        * Adds a command to remove a given render target from fast GPU memory.
        * @param rid The render target to remove from fast GPU memory.
        * @param copyContents When this value is true, Unity copies the existing contents of the render target when it removes it from fast GPU memory. When this value is false, Unity does not copy the existing contents of the render target when it removes it from fast GPU memory. Set this value to true if you plan to add to the existing contents, and set it to false if you plan to overwrite or clear the existing contents. Where possible, set this value to false for better performance.
        * @extension UnityEngine.Rendering.CommandBufferExtensions.SwitchOutOfFastMemory
        */
        SwitchOutOfFastMemory ($rid: RenderTargetIdentifier, $copyContents: boolean) : void
    }

}

declare module 'UnityEngine.Experimental.Rendering' {
    import * as UnityEngine from 'UnityEngine'
    import * as System from 'System'

    /**
    * Use this format to create either Textures or RenderTextures from scripts.
    */
    enum GraphicsFormat {
        None = 0,
        R8_SRGB = 1,
        R8G8_SRGB = 2,
        R8G8B8_SRGB = 3,
        R8G8B8A8_SRGB = 4,
        R8_UNorm = 5,
        R8G8_UNorm = 6,
        R8G8B8_UNorm = 7,
        R8G8B8A8_UNorm = 8,
        R8_SNorm = 9,
        R8G8_SNorm = 10,
        R8G8B8_SNorm = 11,
        R8G8B8A8_SNorm = 12,
        R8_UInt = 13,
        R8G8_UInt = 14,
        R8G8B8_UInt = 15,
        R8G8B8A8_UInt = 16,
        R8_SInt = 17,
        R8G8_SInt = 18,
        R8G8B8_SInt = 19,
        R8G8B8A8_SInt = 20,
        R16_UNorm = 21,
        R16G16_UNorm = 22,
        R16G16B16_UNorm = 23,
        R16G16B16A16_UNorm = 24,
        R16_SNorm = 25,
        R16G16_SNorm = 26,
        R16G16B16_SNorm = 27,
        R16G16B16A16_SNorm = 28,
        R16_UInt = 29,
        R16G16_UInt = 30,
        R16G16B16_UInt = 31,
        R16G16B16A16_UInt = 32,
        R16_SInt = 33,
        R16G16_SInt = 34,
        R16G16B16_SInt = 35,
        R16G16B16A16_SInt = 36,
        R32_UInt = 37,
        R32G32_UInt = 38,
        R32G32B32_UInt = 39,
        R32G32B32A32_UInt = 40,
        R32_SInt = 41,
        R32G32_SInt = 42,
        R32G32B32_SInt = 43,
        R32G32B32A32_SInt = 44,
        R16_SFloat = 45,
        R16G16_SFloat = 46,
        R16G16B16_SFloat = 47,
        R16G16B16A16_SFloat = 48,
        R32_SFloat = 49,
        R32G32_SFloat = 50,
        R32G32B32_SFloat = 51,
        R32G32B32A32_SFloat = 52,
        B8G8R8_SRGB = 56,
        B8G8R8A8_SRGB = 57,
        B8G8R8_UNorm = 58,
        B8G8R8A8_UNorm = 59,
        B8G8R8_SNorm = 60,
        B8G8R8A8_SNorm = 61,
        B8G8R8_UInt = 62,
        B8G8R8A8_UInt = 63,
        B8G8R8_SInt = 64,
        B8G8R8A8_SInt = 65,
        R4G4B4A4_UNormPack16 = 66,
        B4G4R4A4_UNormPack16 = 67,
        R5G6B5_UNormPack16 = 68,
        B5G6R5_UNormPack16 = 69,
        R5G5B5A1_UNormPack16 = 70,
        B5G5R5A1_UNormPack16 = 71,
        A1R5G5B5_UNormPack16 = 72,
        E5B9G9R9_UFloatPack32 = 73,
        B10G11R11_UFloatPack32 = 74,
        A2B10G10R10_UNormPack32 = 75,
        A2B10G10R10_UIntPack32 = 76,
        A2B10G10R10_SIntPack32 = 77,
        A2R10G10B10_UNormPack32 = 78,
        A2R10G10B10_UIntPack32 = 79,
        A2R10G10B10_SIntPack32 = 80,
        A2R10G10B10_XRSRGBPack32 = 81,
        A2R10G10B10_XRUNormPack32 = 82,
        R10G10B10_XRSRGBPack32 = 83,
        R10G10B10_XRUNormPack32 = 84,
        A10R10G10B10_XRSRGBPack32 = 85,
        A10R10G10B10_XRUNormPack32 = 86,
        D16_UNorm = 90,
        D24_UNorm = 91,
        D24_UNorm_S8_UInt = 92,
        D32_SFloat = 93,
        D32_SFloat_S8_UInt = 94,
        S8_UInt = 95,
        RGB_DXT1_SRGB = 96,
        RGBA_DXT1_SRGB = 96,
        RGB_DXT1_UNorm = 97,
        RGBA_DXT1_UNorm = 97,
        RGBA_DXT3_SRGB = 98,
        RGBA_DXT3_UNorm = 99,
        RGBA_DXT5_SRGB = 100,
        RGBA_DXT5_UNorm = 101,
        R_BC4_UNorm = 102,
        R_BC4_SNorm = 103,
        RG_BC5_UNorm = 104,
        RG_BC5_SNorm = 105,
        RGB_BC6H_UFloat = 106,
        RGB_BC6H_SFloat = 107,
        RGBA_BC7_SRGB = 108,
        RGBA_BC7_UNorm = 109,
        RGB_PVRTC_2Bpp_SRGB = 110,
        RGB_PVRTC_2Bpp_UNorm = 111,
        RGB_PVRTC_4Bpp_SRGB = 112,
        RGB_PVRTC_4Bpp_UNorm = 113,
        RGBA_PVRTC_2Bpp_SRGB = 114,
        RGBA_PVRTC_2Bpp_UNorm = 115,
        RGBA_PVRTC_4Bpp_SRGB = 116,
        RGBA_PVRTC_4Bpp_UNorm = 117,
        RGB_ETC_UNorm = 118,
        RGB_ETC2_SRGB = 119,
        RGB_ETC2_UNorm = 120,
        RGB_A1_ETC2_SRGB = 121,
        RGB_A1_ETC2_UNorm = 122,
        RGBA_ETC2_SRGB = 123,
        RGBA_ETC2_UNorm = 124,
        R_EAC_UNorm = 125,
        R_EAC_SNorm = 126,
        RG_EAC_UNorm = 127,
        RG_EAC_SNorm = 128,
        RGBA_ASTC4X4_SRGB = 129,
        RGBA_ASTC4X4_UNorm = 130,
        RGBA_ASTC5X5_SRGB = 131,
        RGBA_ASTC5X5_UNorm = 132,
        RGBA_ASTC6X6_SRGB = 133,
        RGBA_ASTC6X6_UNorm = 134,
        RGBA_ASTC8X8_SRGB = 135,
        RGBA_ASTC8X8_UNorm = 136,
        RGBA_ASTC10X10_SRGB = 137,
        RGBA_ASTC10X10_UNorm = 138,
        RGBA_ASTC12X12_SRGB = 139,
        RGBA_ASTC12X12_UNorm = 140,
        YUV2 = 141,
        DepthAuto = 142,
        ShadowAuto = 143,
        VideoAuto = 144,
        RGBA_ASTC4X4_UFloat = 145,
        RGBA_ASTC5X5_UFloat = 146,
        RGBA_ASTC6X6_UFloat = 147,
        RGBA_ASTC8X8_UFloat = 148,
        RGBA_ASTC10X10_UFloat = 149,
        RGBA_ASTC12X12_UFloat = 150,
        D16_UNorm_S8_UInt = 151 
    }

    /**
    * Use a default format to create either Textures or RenderTextures from scripts based on platform specific capability.
    */
    enum DefaultFormat {
        LDR = 0,
        HDR = 1,
        DepthStencil = 2,
        Shadow = 3,
        Video = 4 
    }

    enum TextureCreationFlags {
        None = 0,
        MipChain = 1,
        DontInitializePixels = 4,
        Crunch = 64,
        DontUploadUponCreate = 1024,
        IgnoreMipmapLimit = 2048 
    }

    /**
    * A shader for GPU ray tracing.
    */
    interface RayTracingShader {

        /**
        * The name of the object.
        */
        name? : string
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        hideFlags? : HideFlags

    }

    /**
    * A data structure used to represent the geometry in the Scene for GPU ray tracing.
    */
    interface RayTracingAccelerationStructure extends System.IDisposable {

    }

    /**
    * Indicates how a Renderer is updated.
    */
    enum RayTracingMode {
        Off = 0,
        Static = 1,
        DynamicTransform = 2,
        DynamicGeometry = 3 
    }

    /**
    * Use this format usages to figure out the capabilities of specific GraphicsFormat
    */
    enum FormatUsage {
        Sample = 0,
        Linear = 1,
        Sparse = 2,
        Render = 4,
        Blend = 5,
        GetPixels = 6,
        SetPixels = 7,
        SetPixels32 = 8,
        ReadPixels = 9,
        LoadStore = 10,
        MSAA2x = 11,
        MSAA4x = 12,
        MSAA8x = 13,
        StencilSampling = 16 
    }

}

declare module 'UnityEngine.Camera' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'

    /**
    * A Camera eye corresponding to the left or right human eye for stereoscopic rendering, or neither for non-stereoscopic rendering.
    * A single Camera can render both left and right views in a single frame. Therefore, this enum describes which eye the Camera is currently rendering when returned by Camera.stereoActiveEye during a rendering callback (such as Camera.OnRenderImage), or which eye to act on when passed into a function.
    * The default value is Camera.MonoOrStereoscopicEye.Left, so Camera.MonoOrStereoscopicEye.Left may be returned by some methods or properties when called outside of rendering if stereoscopic rendering is enabled.
    */
    enum MonoOrStereoscopicEye {
        Left = 0,
        Right = 1,
        Mono = 2 
    }

    /**
    * Wrapper for gate fit parameters
    */
    class GateFitParameters extends System.ValueType {

        public get mode(): GateFitMode;
        public set mode(value: GateFitMode);
        public get aspect(): float;
        public set aspect(value: float);

        public constructor ($mode: GateFitMode, $aspect: float)
    }

    /**
    * Enum used to specify how the sensor gate (sensor frame) defined by Camera.sensorSize fits into the resolution gate (render frame).
    */
    enum GateFitMode {
        Vertical = 1,
        Horizontal = 2,
        Fill = 3,
        Overscan = 4,
        None = 0 
    }

    /**
    * Enum used to specify either the left or the right eye of a stereoscopic camera.
    */
    enum StereoscopicEye {
        Left = 0,
        Right = 1 
    }

    enum SceneViewFilterMode {
        Off = 0,
        ShowFiltered = 1 
    }

    /**
    * Delegate type for camera callbacks.
    */
    interface CameraCallback {
        (cam: UnityEngine.Camera) : void; 
        Invoke?: (cam: UnityEngine.Camera) => void;
    }
    var CameraCallback: { new (func: (cam: UnityEngine.Camera) => void): CameraCallback; }

    /**
    * Enumerates which axis to use when expressing the value for the field of view.
    * The default value is Camera.FieldOfViewAxis.Vertical.
    */
    enum FieldOfViewAxis {
        Vertical = 0,
        Horizontal = 1 
    }

}

declare module 'UnityEngine.GraphicsBuffer' {
    import * as System from 'System'

    /**
    * The intended targets for GraphicsBuffer.
    */
    enum Target {
        Vertex = 1,
        Index = 2,
        CopySource = 4,
        CopyDestination = 8,
        Structured = 16,
        Raw = 32,
        Append = 64,
        Counter = 128,
        IndirectArguments = 256,
        Constant = 512 
    }

    /**
    * The intended usage of a GraphicsBuffer.
    */
    enum UsageFlags {
        None = 0,
        LockBufferForWrite = 1 
    }

    /**
    * Defines the data layout for non-indexed indirect render calls.
    */
    class IndirectDrawArgs extends System.ValueType {

        public static size : int
        public get vertexCountPerInstance(): uint;
        public set vertexCountPerInstance(value: uint);
        public get instanceCount(): uint;
        public set instanceCount(value: uint);
        public get startVertex(): uint;
        public set startVertex(value: uint);
        public get startInstance(): uint;
        public set startInstance(value: uint);

    }

    /**
    * Defines the data layout for indexed indirect render calls.
    */
    class IndirectDrawIndexedArgs extends System.ValueType {

        public static size : int
        public get indexCountPerInstance(): uint;
        public set indexCountPerInstance(value: uint);
        public get instanceCount(): uint;
        public set instanceCount(value: uint);
        public get startIndex(): uint;
        public set startIndex(value: uint);
        public get baseVertexIndex(): uint;
        public set baseVertexIndex(value: uint);
        public get startInstance(): uint;
        public set startInstance(value: uint);

    }

}

declare module 'UnityEngine.Profiling' {
    import * as System from 'System'

    /**
    * Custom CPU Profiler label used for profiling arbitrary code blocks.
    */
    interface CustomSampler {

    }

    /**
    * Provides control over a CPU Profiler label.
    */
    interface Sampler {

    }

}

declare module 'Unity.Profiling' {
    import * as System from 'System'

    /**
    * Performance marker used for profiling arbitrary code blocks.
    */
    interface ProfilerMarker {

    }

}

declare module 'UnityEngine.Mesh' {
    import * as System from 'System'
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering'
    import * as UnityEngine from 'UnityEngine'
    import * as Unity_Collections from 'Unity.Collections'

    /**
    * An array of Mesh data snapshots for C# Job System access.
    */
    class MeshDataArray extends System.ValueType implements System.IDisposable {

        public get Length(): int;

        public Dispose () : void
        public get_Item ($index: int) : MeshData
    }

    /**
    * A struct containing Mesh data for C# Job System access.
    */
    class MeshData extends System.ValueType {

        public get vertexCount(): int;
        public get vertexBufferCount(): int;
        public get indexFormat(): UnityEngine_Rendering.IndexFormat;
        public get subMeshCount(): int;
        public set subMeshCount(value: int);

        public GetVertexBufferStride ($stream: int) : int
        public HasVertexAttribute ($attr: UnityEngine_Rendering.VertexAttribute) : boolean
        public GetVertexAttributeDimension ($attr: UnityEngine_Rendering.VertexAttribute) : int
        public GetVertexAttributeFormat ($attr: UnityEngine_Rendering.VertexAttribute) : UnityEngine_Rendering.VertexAttributeFormat
        public GetVertexAttributeStream ($attr: UnityEngine_Rendering.VertexAttribute) : int
        public GetVertexAttributeOffset ($attr: UnityEngine_Rendering.VertexAttribute) : int
        public GetVertices ($outVertices: Unity_Collections.NativeArray$1<UnityEngine.Vector3>) : void
        public GetNormals ($outNormals: Unity_Collections.NativeArray$1<UnityEngine.Vector3>) : void
        public GetTangents ($outTangents: Unity_Collections.NativeArray$1<UnityEngine.Vector4>) : void
        public GetColors ($outColors: Unity_Collections.NativeArray$1<UnityEngine.Color>) : void
        public GetColors ($outColors: Unity_Collections.NativeArray$1<UnityEngine.Color32>) : void
        /**
        * @methodSwap GetUVs_EBB7509C_H6E88884F
        */
        public GetUVs ($channel: int, $outUVs: Unity_Collections.NativeArray$1<UnityEngine.Vector2>) : void
        /**
        * @methodSwap GetUVs_EBB7509C_H6C864692
        */
        public GetUVs ($channel: int, $outUVs: Unity_Collections.NativeArray$1<UnityEngine.Vector3>) : void
        /**
        * @methodSwap GetUVs_EBB7509C_H6E9792D9
        */
        public GetUVs ($channel: int, $outUVs: Unity_Collections.NativeArray$1<UnityEngine.Vector4>) : void
        public GetVertexData<T> ($stream?: int) : Unity_Collections.NativeArray$1<T>
        /**
        * @methodSwap SetVertexBufferParams_EBB7509C_H271C9F3C
        */
        public SetVertexBufferParams ($vertexCount: int, ...attributes: UnityEngine_Rendering.VertexAttributeDescriptor[]) : void
        /**
        * @methodSwap SetVertexBufferParams_EBB7509C_H8491BD1
        */
        public SetVertexBufferParams ($vertexCount: int, $attributes: Unity_Collections.NativeArray$1<UnityEngine_Rendering.VertexAttributeDescriptor>) : void
        public SetIndexBufferParams ($indexCount: int, $format: UnityEngine_Rendering.IndexFormat) : void
        /**
        * @methodSwap GetIndices_EBB7509C_H33C4AFAC
        */
        public GetIndices ($outIndices: Unity_Collections.NativeArray$1<ushort>, $submesh: int, $applyBaseVertex?: boolean) : void
        /**
        * @methodSwap GetIndices_EBB7509C_H32FCE4D3
        */
        public GetIndices ($outIndices: Unity_Collections.NativeArray$1<int>, $submesh: int, $applyBaseVertex?: boolean) : void
        public GetIndexData<T> () : Unity_Collections.NativeArray$1<T>
        public GetSubMesh ($index: int) : UnityEngine_Rendering.SubMeshDescriptor
        public SetSubMesh ($index: int, $desc: UnityEngine_Rendering.SubMeshDescriptor, $flags?: UnityEngine_Rendering.MeshUpdateFlags) : void
    }

}

declare module 'UnityEngine.ReflectionProbe' {

    /**
    * Types of events that occur when ReflectionProbe components are used in a Scene.
    */
    enum ReflectionProbeEvent {
        ReflectionProbeAdded = 0,
        ReflectionProbeRemoved = 1 
    }

}

declare module 'UnityEngine.RectInt' {
    import * as System from 'System'
    import * as System_Collections_Generic from 'System.Collections.Generic'
    import * as UnityEngine from 'UnityEngine'

    /**
    * An iterator that allows you to iterate over all positions within the RectInt.
    */
    class PositionEnumerator extends System.ValueType implements System_Collections_Generic.IEnumerator$1<UnityEngine.Vector2Int> {

        public get Current(): UnityEngine.Vector2Int;

        public constructor ($min: UnityEngine.Vector2Int, $max: UnityEngine.Vector2Int)
        public GetEnumerator () : PositionEnumerator
        public MoveNext () : boolean
        public Reset () : void
    }

}

declare module 'UnityEngine.CullingGroup' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'

    /**
    * This delegate is used for recieving a callback when a sphere's distance or visibility state has changed.
    * @param sphere A CullingGroupEvent that provides information about the sphere that has changed.
    */
    interface StateChanged {
        (sphere: UnityEngine.CullingGroupEvent) : void; 
        Invoke?: (sphere: UnityEngine.CullingGroupEvent) => void;
    }
    var StateChanged: { new (func: (sphere: UnityEngine.CullingGroupEvent) => void): StateChanged; }

}

declare module 'UnityEngine.LightingSettings' {

    /**
    * Backends available for baking lighting.
    */
    enum Lightmapper {
        Enlighten = 0,
        ProgressiveCPU = 1,
        ProgressiveGPU = 2 
    }

    enum Sampling {
        Auto = 0,
        Fixed = 1 
    }

    /**
    * The available filtering modes for the Progressive Lightmapper.
    */
    enum FilterMode {
        None = 0,
        Auto = 1,
        Advanced = 2 
    }

    /**
    * The available denoisers for the Progressive Lightmapper.
    */
    enum DenoiserType {
        None = 0,
        Optix = 1,
        OpenImage = 2,
        RadeonPro = 3 
    }

    /**
    * The available filter kernels for the Progressive Lightmapper.
    */
    enum FilterType {
        Gaussian = 0,
        ATrous = 1,
        None = 2 
    }

}

declare module 'UnityEngine.BoundsInt' {
    import * as System from 'System'
    import * as System_Collections_Generic from 'System.Collections.Generic'
    import * as UnityEngine from 'UnityEngine'

    /**
    * An iterator that allows you to iterate over all positions within the BoundsInt.
    */
    class PositionEnumerator extends System.ValueType implements System_Collections_Generic.IEnumerator$1<UnityEngine.Vector3Int> {

        public get Current(): UnityEngine.Vector3Int;

        public constructor ($min: UnityEngine.Vector3Int, $max: UnityEngine.Vector3Int)
        public GetEnumerator () : PositionEnumerator
        public MoveNext () : boolean
        public Reset () : void
    }

}

declare module 'UnityEngine.Display' {
    import * as System from 'System'

    interface DisplaysUpdatedDelegate {
        () : void; 
        Invoke?: () => void;
    }
    var DisplaysUpdatedDelegate: { new (func: () => void): DisplaysUpdatedDelegate; }

}

declare module 'UnityEngine.LightProbeProxyVolume' {

    /**
    * The bounding box mode for generating a grid of interpolated Light Probes.
    */
    enum BoundingBoxMode {
        AutomaticLocal = 0,
        AutomaticWorld = 1,
        Custom = 2 
    }

    /**
    * The resolution mode for generating a grid of interpolated Light Probes.
    */
    enum ResolutionMode {
        Automatic = 0,
        Custom = 1 
    }

    /**
    * The mode in which the interpolated Light Probe positions are generated.
    */
    enum ProbePositionMode {
        CellCorner = 0,
        CellCenter = 1 
    }

    /**
    * An enum that describes how Unity refreshes a Light Probe Proxy Volume in the Player.
    */
    enum RefreshMode {
        Automatic = 0,
        EveryFrame = 1,
        ViaScripting = 2 
    }

    /**
    * An enum describing the Quality option used by the Light Probe Proxy Volume component.
    */
    enum QualityMode {
        Low = 0,
        Normal = 1 
    }

    /**
    * The texture data format used by the Light Probe Proxy Volume 3D texture.
    */
    enum DataFormat {
        HalfFloat = 0,
        Float = 1 
    }

}

declare module 'UnityEngine.Texture2D' {

    /**
    * Flags used to control the encoding to an EXR file.
    */
    enum EXRFlags {
        None = 0,
        OutputAsFloat = 1,
        CompressZIP = 2,
        CompressRLE = 4,
        CompressPIZ = 8 
    }

}

declare module 'UnityEngine.Random' {
    import * as System from 'System'

    /**
    * Serializable structure used to hold the full internal state of the random number generator. Additional resources: Random.state.
    */
    class State extends System.ValueType {

    }

}

declare module 'UnityEngine.ShaderVariantCollection' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering'

    /**
    * Identifies a specific variant of a shader.
    */
    class ShaderVariant extends System.ValueType {

        public shader : UnityEngine.Shader
        public passType : UnityEngine_Rendering.PassType
        public keywords : string[]

        public constructor ($shader: UnityEngine.Shader, $passType: UnityEngine_Rendering.PassType, ...keywords: string[])
    }

}

declare module 'UnityEngine.TouchScreenKeyboard' {

    /**
    * The status of the on-screen keyboard.
    */
    enum Status {
        Visible = 0,
        Done = 1,
        Canceled = 2,
        LostFocus = 3 
    }

}

declare module 'UnityEngine.ADBannerView' {
    import * as System from 'System'

    enum Layout {
        Top = 0,
        Bottom = 1,
        TopLeft = 0,
        TopRight = 4,
        TopCenter = 8,
        BottomLeft = 1,
        BottomRight = 5,
        BottomCenter = 9,
        CenterLeft = 2,
        CenterRight = 6,
        Center = 10,
        Manual = -1 
    }

    enum Type {
        Banner = 0,
        MediumRect = 1 
    }

    interface BannerWasClickedDelegate {
        () : void; 
        Invoke?: () => void;
    }
    var BannerWasClickedDelegate: { new (func: () => void): BannerWasClickedDelegate; }

    interface BannerWasLoadedDelegate {
        () : void; 
        Invoke?: () => void;
    }
    var BannerWasLoadedDelegate: { new (func: () => void): BannerWasLoadedDelegate; }

}

declare module 'UnityEngine.ADInterstitialAd' {
    import * as System from 'System'

    interface InterstitialWasLoadedDelegate {
        () : void; 
        Invoke?: () => void;
    }
    var InterstitialWasLoadedDelegate: { new (func: () => void): InterstitialWasLoadedDelegate; }

}

declare module 'UnityEngine.RectTransform' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'

    /**
    * Enum used to specify one edge of a rectangle.
    */
    enum Edge {
        Left = 0,
        Right = 1,
        Top = 2,
        Bottom = 3 
    }

    /**
    * An axis that can be horizontal or vertical.
    */
    enum Axis {
        Horizontal = 0,
        Vertical = 1 
    }

    /**
    * Delegate used for the reapplyDrivenProperties event.
    */
    interface ReapplyDrivenProperties {
        (driven: UnityEngine.RectTransform) : void; 
        Invoke?: (driven: UnityEngine.RectTransform) => void;
    }
    var ReapplyDrivenProperties: { new (func: (driven: UnityEngine.RectTransform) => void): ReapplyDrivenProperties; }

}

declare module 'UnityEngine.Sprites' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'

    /**
    * Helper utilities for accessing Sprite data.
    */
    class DataUtility extends System.Object {

        public constructor ()
        /**
        * Inner UV's of the Sprite.
        */
        public static GetInnerUV ($sprite: UnityEngine.Sprite) : UnityEngine.Vector4
        /**
        * Outer UV's of the Sprite.
        */
        public static GetOuterUV ($sprite: UnityEngine.Sprite) : UnityEngine.Vector4
        /**
        * Return the padding on the sprite.
        */
        public static GetPadding ($sprite: UnityEngine.Sprite) : UnityEngine.Vector4
        /**
        * Minimum width and height of the Sprite.
        */
        public static GetMinSize ($sprite: UnityEngine.Sprite) : UnityEngine.Vector2
    }

}

declare module 'UnityEngine.U2D' {
    import * as UnityEngine from 'UnityEngine'
    import * as System from 'System'
    import * as System_Collections_Generic from 'System.Collections.Generic'
    import * as System_Threading from 'System.Threading'
    import * as Unity_Collections from 'Unity.Collections'
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering'

    /**
    * Provides a base class for 2D lights.
    */
    class Light2DBase extends UnityEngine.MonoBehaviour {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The Transform attached to this GameObject.
        */
        public get transform(): Transform;
        /**
        * The game object this component is attached to. A component is always attached to a game object.
        */
        public get gameObject(): GameObject;
        /**
        * The tag of this game object.
        */
        public get tag(): string;
        public set tag(value: string);
        /**
        * Enabled Behaviours are Updated, disabled Behaviours are not.
        */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
        * Reports whether a GameObject and its associated Behaviour is active and enabled.
        */
        public get isActiveAndEnabled(): boolean;
        /**
        * Cancellation token raised when the MonoBehaviour is destroyed (Read Only).
        */
        public get destroyCancellationToken(): System_Threading.CancellationToken;
        /**
        * Disabling this lets you skip the GUI layout phase.
        */
        public get useGUILayout(): boolean;
        public set useGUILayout(value: boolean);

        /**
        * The non-generic version of this method.
        * @param type The type of Component to retrieve.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: System.Type) : UnityEngine.Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified.
        * @returns A reference to a component of the type T if one is found, otherwise null.
        */
        public GetComponent<T> () : T
        /**
        * The string-based version of this method.
        * @param type The name of the type of Component to get.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponent ($type: string) : UnityEngine.Component
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @param component The output argument that will contain the component or null.
        * @returns Returns true if the component is found, false otherwise.
        */
        public TryGetComponent ($type: System.Type, $component: $Ref<UnityEngine.Component>) : boolean
        public TryGetComponent<T> ($component: $Ref<T>) : boolean
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component
        /**
        * This is the non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInChildren ($t: System.Type) : UnityEngine.Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInChildren<T> ($includeInactive: boolean) : T
        public GetComponentInChildren<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component[]
        public GetComponentsInChildren ($t: System.Type) : UnityEngine.Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any child of the GameObject.
        * @param includeInactive Whether to include inactive child GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInChildren<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type, otherwise null if no Component is found.
        */
        public GetComponentInParent ($t: System.Type) : UnityEngine.Component
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> ($includeInactive: boolean) : T
        /**
        * Gets a reference to a component of type T on the same GameObject as the component specified, or any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns A Component of the matching type T, otherwise null if no Component is found.
        */
        public GetComponentInParent<T> () : T
        /**
        * The non-generic version of this method.
        * @param t The type of component to search for.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array of all found components matching the specified type.
        */
        public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component[]
        public GetComponentsInParent ($t: System.Type) : UnityEngine.Component[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> ($includeInactive: boolean) : T[]
        /**
        * Gets references to all components of type T on the same GameObject as the component specified, and any parent of the GameObject.
        * @param includeInactive Whether to include inactive parent GameObjects in the search.
        * @returns An array containing all matching components of type T.
        */
        public GetComponentsInParent<T> () : T[]
        /**
        * The non-generic version of this method.
        * @param type The type of component to search for.
        * @returns An array containing all matching components of type type.
        */
        public GetComponents ($type: System.Type) : UnityEngine.Component[]
        public GetComponents ($type: System.Type, $results: System_Collections_Generic.List$1<UnityEngine.Component>) : void
        /**
        * Gets references to all components of type T on the same GameObject as the component specified.
        * @returns An array containing all matching components of type T.
        */
        public GetComponents<T> () : T[]
        private constructor ()
    }

    /**
    * A collection of APIs that facilitate pixel perfect rendering of sprite-based renderers.
    */
    class PixelPerfectRendering {

        /**
        * To achieve a pixel perfect render, Sprites must be displaced to discrete positions at render time. This value defines the minimum distance between these positions. This doesn’t affect the GameObject's transform position.
        */
        public static get pixelSnapSpacing(): float;
        public static set pixelSnapSpacing(value: float);

    }

    /**
    * Stores a set of information that describes the bind pose of this Sprite.
    */
    class SpriteBone extends System.ValueType {

        /**
        * The name of the bone. This is useful when recreating bone hierarchy at editor or runtime. You can also use this as a way of resolving the bone path when a Sprite is bound to a more complex or richer hierarchy.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * The Unique GUID of this bone.
        */
        public get guid(): string;
        public set guid(value: string);
        /**
        * The position in local space of this bone.
        */
        public get position(): UnityEngine.Vector3;
        public set position(value: UnityEngine.Vector3);
        /**
        * The rotation of this bone in local space.
        */
        public get rotation(): UnityEngine.Quaternion;
        public set rotation(value: UnityEngine.Quaternion);
        /**
        * The length of the bone. This is important for the leaf bones to describe their length without needing another bone as the terminal bone.
        */
        public get length(): float;
        public set length(value: float);
        /**
        * The ID of the parent of this bone.
        */
        public get parentId(): int;
        public set parentId(value: int);
        /**
        * Shows the color set for the bone in the Editor.
        */
        public get color(): UnityEngine.Color32;
        public set color(value: UnityEngine.Color32);

    }

    /**
    * A list of methods designed for reading and writing to the rich internal data of a Sprite.
    */
    class SpriteDataAccessExtensions {

        /**
        * Retrieves a strided accessor to the internal vertex attributes.
        * @returns A read-only list of.
        */
        public static GetVertexAttribute<T> ($sprite: UnityEngine.Sprite, $channel: UnityEngine_Rendering.VertexAttribute) : Unity_Collections.NativeSlice$1<T>
        public static SetVertexAttribute<T> ($sprite: UnityEngine.Sprite, $channel: UnityEngine_Rendering.VertexAttribute, $src: Unity_Collections.NativeArray$1<T>) : void
        /**
        * Returns an array of BindPoses.
        * @param sprite The sprite to retrieve the bind pose from.
        * @returns A list of bind poses for this sprite. There is no need to dispose the returned NativeArray.
        */
        public static GetBindPoses ($sprite: UnityEngine.Sprite) : Unity_Collections.NativeArray$1<UnityEngine.Matrix4x4>
        public static SetBindPoses ($sprite: UnityEngine.Sprite, $src: Unity_Collections.NativeArray$1<UnityEngine.Matrix4x4>) : void
        /**
        * Returns a list of indices. This is the same as Sprite.triangle.
        * @returns A read-only list of indices indicating how the triangles are formed between the vertices. The array is marked as undisposable.
        */
        public static GetIndices ($sprite: UnityEngine.Sprite) : Unity_Collections.NativeArray$1<ushort>
        public static SetIndices ($sprite: UnityEngine.Sprite, $src: Unity_Collections.NativeArray$1<ushort>) : void
        /**
        * Returns a list of SpriteBone in this Sprite.
        * @param sprite The sprite to get the list of SpriteBone from.
        * @returns An array of SpriteBone that belongs to this Sprite.
        */
        public static GetBones ($sprite: UnityEngine.Sprite) : SpriteBone[]
        /**
        * Sets the SpriteBones for this Sprite.
        */
        public static SetBones ($sprite: UnityEngine.Sprite, $src: SpriteBone[]) : void
        /**
        * Checks if a specific channel exists for this Sprite.
        * @returns True if the channel exists.
        */
        public static HasVertexAttribute ($sprite: UnityEngine.Sprite, $channel: UnityEngine_Rendering.VertexAttribute) : boolean
        /**
        * Sets the vertex count. This resizes the internal buffer. It also preserves any configurations of VertexAttributes.
        * @methodSwap SetVertexCount_EBB7509C_H4AA321CC
        */
        public static SetVertexCount ($sprite: UnityEngine.Sprite, $count: int) : void
        /**
        * Returns the number of vertices in this Sprite.
        */
        public static GetVertexCount ($sprite: UnityEngine.Sprite) : int
    }

    /**
    * A list of methods that allow the caller to override what the SpriteRenderer renders.
    */
    class SpriteRendererDataAccessExtensions {

        /**
        * Stop using the deformable buffer to render the Sprite and use the original mesh instead.
        */
        public static DeactivateDeformableBuffer ($renderer: UnityEngine.SpriteRenderer) : void
    }

    /**
    * Manages SpriteAtlas during runtime.
    */
    class SpriteAtlasManager extends System.Object {

        public constructor ()
        public static add_atlasRequested ($value: System.Action$2<string, System.Action$1<SpriteAtlas>>) : void
        public static add_atlasRegistered ($value: System.Action$1<SpriteAtlas>) : void
        public static remove_atlasRequested ($value: System.Action$2<string, System.Action$1<SpriteAtlas>>) : void
        public static remove_atlasRegistered ($value: System.Action$1<SpriteAtlas>) : void
    }

    /**
    * Sprite Atlas is an asset created within Unity. It is part of the built-in sprite packing solution.
    */
    class SpriteAtlas extends UnityEngine.Object {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * Return true if this SpriteAtlas is a variant.
        */
        public get isVariant(): boolean;
        /**
        * Get the tag of this SpriteAtlas.
        */
        public get tag(): string;
        /**
        * Get the total number of Sprite packed into this atlas.
        */
        public get spriteCount(): int;

        public constructor ()
        /**
        * Return true if Sprite is packed into this SpriteAtlas.
        */
        public CanBindTo ($sprite: UnityEngine.Sprite) : boolean
        /**
        * Clone the first Sprite in this atlas that matches the name packed in this atlas and return it.
        * @param name The name of the Sprite.
        */
        public GetSprite ($name: string) : UnityEngine.Sprite
        /**
        * Clone all the Sprite in this atlas and fill them into the supplied array.
        * @param sprites Array of Sprite that will be filled.
        * @returns The size of the returned array.
        */
        public GetSprites ($sprites: UnityEngine.Sprite[]) : int
        /**
        * Clone all the Sprite matching the name in this atlas and fill them into the supplied array.
        * @param sprites Array of Sprite that will be filled.
        * @param name The name of the Sprite.
        */
        public GetSprites ($sprites: UnityEngine.Sprite[], $name: string) : int
    }

}

declare module 'UnityEngine.Scripting' {
    import * as System from 'System'
    import * as UnityEngine_Scripting_GarbageCollector from 'UnityEngine.Scripting.GarbageCollector'

    /**
    * API to control the garbage collector on the Mono and IL2CPP scripting backends.
    */
    class GarbageCollector {

        /**
        * Set and get global garbage collector operation mode.
        */
        public static get GCMode(): UnityEngine_Scripting_GarbageCollector.Mode;
        public static set GCMode(value: UnityEngine_Scripting_GarbageCollector.Mode);
        /**
        * Reports whether incremental garbage collection is enabled.
        */
        public static get isIncremental(): boolean;
        /**
        * The target duration of a collection step when performing incremental garbage collection.
        */
        public static get incrementalTimeSliceNanoseconds(): bigint;
        public static set incrementalTimeSliceNanoseconds(value: bigint);

        /**
        * Perform incremental garbage collection for the duration specified by the nanoseconds parameter.
        * @param nanoseconds The maximum number of nanoseconds to spend in garbage collection.
        * @returns Returns true if additional garbage collection work remains when the method returns and false if garbage collection is complete. Also returns false if incremental garbage collection is not enabled or is not supported on the current platform.
        */
        public static CollectIncremental ($nanoseconds?: bigint) : boolean
        public static add_GCModeChanged ($value: System.Action$1<UnityEngine_Scripting_GarbageCollector.Mode>) : void
        public static remove_GCModeChanged ($value: System.Action$1<UnityEngine_Scripting_GarbageCollector.Mode>) : void
    }

}

declare module 'UnityEngine.Scripting.GarbageCollector' {

    /**
    * Garbage collector operation mode.
    */
    enum Mode {
        Disabled = 0,
        Enabled = 1,
        Manual = 2 
    }

}

declare module 'UnityEngine.Pool' {
    import * as System from 'System'

    /**
    * A Collection such as List, HashSet, Dictionary etc can be pooled and reused by using a CollectionPool.
    */
    class CollectionPool$2<TCollection,TItem> extends System.Object {

        public constructor ()
        public static Get () : any
        public static Get ($value: $Ref<TCollection>) : PooledObject$1<TCollection>
        public static Release ($toRelease: any) : void
    }

    /**
    * A pooled object wraps a reference to an instance returned to the pool when the pooled object is disposed of.
    */
    class PooledObject$1<T> extends System.ValueType implements System.IDisposable {

        public constructor ($value: T, $pool: IObjectPool$1<T>)
    }

    interface IObjectPool$1<T> {

        readonly CountInactive? : int

        Get? () : T
        Get? ($v: $Ref<T>) : PooledObject$1<T>
        Release? ($element: T) : void
        Clear? () : void
    }

    /**
    * A version of Pool.CollectionPool_2 for Lists.
    */
    class ListPool$1<T> extends CollectionPool$2<System_Collections_Generic.List$1<T>,T> {

        public constructor ()
    }

    /**
    * A version of Pool.CollectionPool_2 for HashSets.
    */
    class HashSetPool$1<T> extends CollectionPool$2<System_Collections_Generic.HashSet$1<T>,T> {

        public constructor ()
    }

    /**
    * A version of Pool.CollectionPool_2 for Dictionaries.
    */
    class DictionaryPool$2<TKey,TValue> extends CollectionPool$2<System_Collections_Generic.Dictionary$2<TKey, TValue>,System_Collections_Generic.KeyValuePair$2<TKey, TValue>> {

        public constructor ()
    }

    /**
    * Provides a static implementation of Pool.ObjectPool_1.
    */
    class GenericPool$1<T> extends System.Object {

        public constructor ()
        public static Get () : any
        public static Get ($value: $Ref<T>) : PooledObject$1<T>
        public static Release ($toRelease: any) : void
    }

    /**
    * A linked list version of Pool.IObjectPool_1.
    */
    class LinkedPool$1<T> extends System.Object implements System.IDisposable, IObjectPool$1<T> {

        public get CountInactive(): int;

        public constructor ($createFunc: System.Func$1<T>, $actionOnGet?: System.Action$1<T>, $actionOnRelease?: System.Action$1<T>, $actionOnDestroy?: System.Action$1<T>, $collectionCheck?: boolean, $maxSize?: int)
        public Get () : T
        public Get ($v: $Ref<T>) : PooledObject$1<T>
        public Release ($item: T) : void
        public Clear () : void
        public Dispose () : void
    }

    /**
    * A stack based Pool.IObjectPool_1.
    */
    class ObjectPool$1<T> extends System.Object implements System.IDisposable, IObjectPool$1<T> {

        public get CountAll(): int;
        public get CountActive(): int;
        public get CountInactive(): int;

        public constructor ($createFunc: System.Func$1<T>, $actionOnGet?: System.Action$1<T>, $actionOnRelease?: System.Action$1<T>, $actionOnDestroy?: System.Action$1<T>, $collectionCheck?: boolean, $defaultCapacity?: int, $maxSize?: int)
        public Get () : T
        public Get ($v: $Ref<T>) : PooledObject$1<T>
        public Release ($element: T) : void
        public Clear () : void
        public Dispose () : void
    }

    /**
    * Provides a static implementation of Pool.ObjectPool_1.
    */
    class UnsafeGenericPool$1<T> {

        public static Get () : any
        public static Get ($value: $Ref<T>) : PooledObject$1<T>
        public static Release ($toRelease: any) : void
    }

}

declare module 'UnityEngine.Rendering.SplashScreen' {

    /**
    * The behavior to apply when calling ParticleSystem.Stop|Stop.
    */
    enum StopBehavior {
        StopImmediate = 0,
        FadeOut = 1 
    }

}

declare module 'UnityEngine.Rendering.RenderPipeline' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'

    /**
    * Standard request type for RenderPipeline.SubmitRenderRequest.
    */
    class StandardRequest extends System.Object {

        public destination : UnityEngine.RenderTexture
        public mipLevel : int
        public face : UnityEngine.CubemapFace
        public slice : int

        public constructor ()
    }

}

declare module 'UnityEngine.Rendering.RendererUtils' {
    import * as System from 'System'
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering'
    import * as UnityEngine from 'UnityEngine'

    /**
    * Represents the set of GameObjects that a RendererList contains.
    */
    class RendererListDesc extends System.ValueType {

        /**
        * The method Unity uses to sort the GameObjects in the RendererList. For more information, see Rendering.SortingCriteria.
        */
        public sortingCriteria : UnityEngine_Rendering.SortingCriteria
        /**
        * The renderer configuration for the RendererList. For more information, see Rendering.PerObjectData.
        */
        public rendererConfiguration : UnityEngine_Rendering.PerObjectData
        /**
        * The material render queue range to use for the RendererList. For more information, see Rendering.RenderQueueRange.
        */
        public renderQueueRange : UnityEngine_Rendering.RenderQueueRange
        /**
        * An optional set of values to override the RendererLists render state. For more information, see Rendering.RenderStateBlock.
        */
        public stateBlock : System.Nullable$1<UnityEngine_Rendering.RenderStateBlock>
        /**
        * The shader to render the RendererList's GameObjects with. This overrides the shader for each GameObject. Override shaders do not override existing material properties.
        */
        public overrideShader : UnityEngine.Shader
        /**
        * The material to render the RendererList's GameObjects with. This overrides the material for each GameObject.
        */
        public overrideMaterial : UnityEngine.Material
        /**
        * Indicates whether to exclude dynamic GameObjects from the RendererList.
        */
        public excludeObjectMotionVectors : boolean
        /**
        * The layer mask to use for filtering this RendererList.
        */
        public layerMask : int
        /**
        * The rendering layer mask to use for filtering this RendererList.
        */
        public renderingLayerMask : uint
        /**
        * Pass index for the override material.
        */
        public overrideMaterialPassIndex : int
        /**
        * Selects which pass of the override shader to use.
        */
        public overrideShaderPassIndex : int

        /**
        * Initializes and returns an instance of RendererListDesc.
        * @param passName The pass name to use for the RendererList.
        * @param cullingResult The culling result used to create the RendererList.
        * @param camera The camera Unity uses to determine the current view and sorting properties.
        * @param passNames The list of passes to use for the RendererList.
        */
        public constructor ($passName: UnityEngine_Rendering.ShaderTagId, $cullingResult: UnityEngine_Rendering.CullingResults, $camera: UnityEngine.Camera)
        /**
        * Initializes and returns an instance of RendererListDesc.
        * @param passName The pass name to use for the RendererList.
        * @param cullingResult The culling result used to create the RendererList.
        * @param camera The camera Unity uses to determine the current view and sorting properties.
        * @param passNames The list of passes to use for the RendererList.
        */
        public constructor ($passNames: UnityEngine_Rendering.ShaderTagId[], $cullingResult: UnityEngine_Rendering.CullingResults, $camera: UnityEngine.Camera)
        /**
        * Checks whether the RendererListDesc is valid.
        * @returns If the RendererListDesc is valid, this returns true. Otherwise, this returns false.
        */
        public IsValid () : boolean
        /**
        * Convert a given RendererListDesc to a RendererListParams struct with equivalent parameters.
        * @returns If the RendererListDesc is valid, this returns a RendererListParams struct. Otherwise, this returns RendererListParams.Invalid.
        */
        public static ConvertToParameters ($desc: $Ref<RendererListDesc>) : UnityEngine_Rendering.RendererListParams
    }

}

declare module 'UnityEngine.Rendering.SupportedRenderingFeatures' {

    /**
    * Supported modes for ReflectionProbes.
    */
    enum ReflectionProbeModes {
        None = 0,
        Rotation = 1 
    }

    /**
    * Same as MixedLightingMode for baking, but is used to determine what is supported by the pipeline.
    */
    enum LightmapMixedBakeModes {
        None = 0,
        IndirectOnly = 1,
        Subtractive = 2,
        Shadowmask = 4 
    }

}

declare module 'UnityEngine.Rendering.BatchRendererGroup' {
    import * as System from 'System'
    import * as Unity_Jobs from 'Unity.Jobs'
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering'

    /**
    * Culling callback function.
    * @param rendererGroup The Rendering.BatchRendererGroup to cull.
    * @param cullingContext Provides read-only information about the culling request (like visibility culling planes) that the callback can use to determine visible instances.
    * @param cullingOutput The target that the callback should write resulting draw commands.
    * @param userContext An optional pointer to custom data that you can associate with the BatchRendererGroup.
    */
    interface OnPerformCulling {
        (rendererGroup: UnityEngine_Rendering.BatchRendererGroup, cullingContext: UnityEngine_Rendering.BatchCullingContext, cullingOutput: UnityEngine_Rendering.BatchCullingOutput, userContext: System.IntPtr) : Unity_Jobs.JobHandle; 
        Invoke?: (rendererGroup: UnityEngine_Rendering.BatchRendererGroup, cullingContext: UnityEngine_Rendering.BatchCullingContext, cullingOutput: UnityEngine_Rendering.BatchCullingOutput, userContext: System.IntPtr) => Unity_Jobs.JobHandle;
    }
    var OnPerformCulling: { new (func: (rendererGroup: UnityEngine_Rendering.BatchRendererGroup, cullingContext: UnityEngine_Rendering.BatchCullingContext, cullingOutput: UnityEngine_Rendering.BatchCullingOutput, userContext: System.IntPtr) => Unity_Jobs.JobHandle): OnPerformCulling; }

}

declare module 'UnityEngine.Playables' {
    import * as System from 'System'
    import * as UnityEngine_Playables_FrameData from 'UnityEngine.Playables.FrameData'
    import * as UnityEngine from 'UnityEngine'
    import * as System_Collections_Generic from 'System.Collections.Generic'

    /**
    * This structure contains the frame information a Playable receives in Playable.PrepareFrame.
    */
    class FrameData extends System.ValueType {

        /**
        * The current frame identifier.
        */
        public get frameId(): bigint;
        /**
        * The interval between this frame and the preceding frame. The interval is unscaled and expressed in seconds.
        */
        public get deltaTime(): float;
        /**
        * The weight of the current Playable.
        */
        public get weight(): float;
        /**
        * The accumulated weight of the Playable during the PlayableGraph traversal.
        */
        public get effectiveWeight(): float;
        /**
        * The accumulated speed of the parent Playable during the PlayableGraph traversal.
        */
        public get effectiveParentSpeed(): float;
        /**
        * The accumulated speed of the Playable during the PlayableGraph traversal.
        */
        public get effectiveSpeed(): float;
        /**
        * Indicates the type of evaluation that caused PlayableGraph.PrepareFrame to be called.
        */
        public get evaluationType(): UnityEngine_Playables_FrameData.EvaluationType;
        /**
        * Indicates that the local time was explicitly set.
        */
        public get seekOccurred(): boolean;
        /**
        * Indicates the local time wrapped because it has reached the duration and the extrapolation mode is set to Loop.
        */
        public get timeLooped(): boolean;
        /**
        * Indicates the local time did not advance because it has reached the duration and the extrapolation mode is set to Hold.
        */
        public get timeHeld(): boolean;
        /**
        * The PlayableOutput that initiated this graph traversal.
        */
        public get output(): PlayableOutput;
        /**
        * The accumulated play state of this playable.
        */
        public get effectivePlayState(): PlayState;

    }

    /**
    * See: Playables.IPlayableOutput.
    */
    class PlayableOutput extends System.ValueType implements IPlayableOutput, System.IEquatable$1<PlayableOutput> {

        /**
        * Returns an invalid PlayableOutput.
        */
        public static get Null(): PlayableOutput;

        public GetHandle () : PlayableOutputHandle
        public IsPlayableOutputOfType<T extends IPlayableOutput> () : boolean
        public GetPlayableOutputType () : System.Type
        public Equals ($other: PlayableOutput) : boolean
    }

    /**
    * Interface implemented by all C# Playable output implementations.
    */
    interface IPlayableOutput {

        GetHandle? () : PlayableOutputHandle
    }

    class PlayableOutputHandle extends System.ValueType implements System.IEquatable$1<PlayableOutputHandle> {

        public static get Null(): PlayableOutputHandle;

        public GetHashCode () : int
        public Equals ($p: any) : boolean
        public Equals ($other: PlayableOutputHandle) : boolean
        public static op_Equality ($lhs: PlayableOutputHandle, $rhs: PlayableOutputHandle) : boolean
        public static op_Inequality ($lhs: PlayableOutputHandle, $rhs: PlayableOutputHandle) : boolean
    }

    /**
    * Status of a Playable.
    */
    enum PlayState {
        Paused = 0,
        Playing = 1,
        Delayed = 2 
    }

    /**
    * The base interface for all notifications sent through the playable system.
    */
    interface INotification {

        /**
        * The identifier is a name that identifies this notifications, or class of notifications.
        */
        readonly id? : UnityEngine.PropertyName

    }

    /**
    * Implement this interface to create a class that will receives notifications from PlayableOutput.
    */
    interface INotificationReceiver {

        /**
        * The method called when a notification is raised.
        * @param origin The playable that sent the notification.
        * @param notification The received notification.
        * @param context User defined data that depends on the type of notification. Uses this to pass necessary information that can change with each invocation.
        */
        OnNotify? ($origin: Playable, $notification: INotification, $context: any) : void
    }

    /**
    * Playables are customizable runtime objects that can be connected together and are contained in a PlayableGraph to create complex behaviours.
    */
    class Playable extends System.ValueType implements System.IEquatable$1<Playable>, IPlayable {

        /**
        * Returns an invalid Playable.
        */
        public static get Null(): Playable;

        public static Create ($graph: PlayableGraph, $inputCount?: int) : Playable
        public GetHandle () : PlayableHandle
        public IsPlayableOfType<T extends IPlayable> () : boolean
        public GetPlayableType () : System.Type
        public Equals ($other: Playable) : boolean
    }

    /**
    * Interface implemented by all C# Playable implementations.
    */
    interface IPlayable {

        GetHandle? () : PlayableHandle
    }

    class PlayableHandle extends System.ValueType implements System.IEquatable$1<PlayableHandle> {

        public static get Null(): PlayableHandle;

        public Equals ($p: any) : boolean
        public Equals ($other: PlayableHandle) : boolean
        public GetHashCode () : int
        public static op_Equality ($x: PlayableHandle, $y: PlayableHandle) : boolean
        public static op_Inequality ($x: PlayableHandle, $y: PlayableHandle) : boolean
    }

    /**
    * Use the PlayableGraph to manage Playable creations and destructions.
    */
    class PlayableGraph extends System.ValueType {

        /**
        * Returns the Playable with no output connections at the given index.
        * @param index The index of the root Playable.
        */
        public GetRootPlayable ($index: int) : Playable
        public Connect<U extends IPlayable,V extends IPlayable> ($source: U, $sourceOutputPort: int, $destination: V, $destinationInputPort: int) : boolean
        public Disconnect<U extends IPlayable> ($input: U, $inputPort: int) : void
        public DestroyPlayable<U extends IPlayable> ($playable: U) : void
        public DestroySubgraph<U extends IPlayable> ($playable: U) : void
        public DestroyOutput<U extends IPlayableOutput> ($output: U) : void
        /**
        * Get the number of PlayableOutput of the requested type in the graph.
        * @returns The number of PlayableOutput of the same type T in the graph.
        */
        public GetOutputCountByType<T extends IPlayableOutput> () : int
        /**
        * Get PlayableOutput at the given index in the graph.
        * @param index The output index.
        * @returns The PlayableOutput at this given index, otherwise null.
        */
        public GetOutput ($index: int) : PlayableOutput
        /**
        * Get PlayableOutput of the requested type at the given index in the graph.
        * @param index The output index.
        * @returns The PlayableOutput at the given index among all the PlayableOutput of the same type T.
        */
        public GetOutputByType<T extends IPlayableOutput> ($index: int) : PlayableOutput
        /**
        * Evaluates all the PlayableOutputs in the graph, and updates all the connected Playables in the graph.
        * @param deltaTime The time in seconds by which to advance each Playable in the graph.
        */
        public Evaluate () : void
        /**
        * Creates a PlayableGraph.
        * @param name The name of the graph.
        * @returns The newly created PlayableGraph.
        */
        public static Create () : PlayableGraph
        /**
        * Creates a PlayableGraph.
        * @param name The name of the graph.
        * @returns The newly created PlayableGraph.
        */
        public static Create ($name: string) : PlayableGraph
        /**
        * Destroys the graph.
        */
        public Destroy () : void
        /**
        * Returns true if the PlayableGraph has been properly constructed using PlayableGraph.CreateGraph and is not deleted.
        * @returns A boolean indicating if the graph is invalid or not.
        */
        public IsValid () : boolean
        /**
        * Indicates that a graph is presently running.
        * @returns A boolean indicating if the graph is playing or not.
        */
        public IsPlaying () : boolean
        /**
        * Indicates that a graph has completed its operations.
        * @returns A boolean indicating if the graph is done playing or not.
        */
        public IsDone () : boolean
        /**
        * Plays the graph.
        */
        public Play () : void
        /**
        * Stops the graph, if it is playing.
        */
        public Stop () : void
        /**
        * Evaluates all the PlayableOutputs in the graph, and updates all the connected Playables in the graph.
        * @param deltaTime The time in seconds by which to advance each Playable in the graph.
        * @methodSwap Evaluate_EBB7509C_H82424F3E
        */
        public Evaluate ($deltaTime: float) : void
        /**
        * Returns how time is incremented when playing back.
        */
        public GetTimeUpdateMode () : DirectorUpdateMode
        /**
        * Changes how time is incremented when playing back.
        * @param value The new DirectorUpdateMode.
        */
        public SetTimeUpdateMode ($value: DirectorUpdateMode) : void
        /**
        * Returns the table used by the graph to resolve ExposedReferences.
        */
        public GetResolver () : UnityEngine.IExposedPropertyTable
        /**
        * Changes the table used by the graph to resolve ExposedReferences.
        */
        public SetResolver ($value: UnityEngine.IExposedPropertyTable) : void
        /**
        * Returns the number of Playable owned by the Graph.
        */
        public GetPlayableCount () : int
        /**
        * Returns the number of Playable owned by the Graph that have no connected outputs.
        */
        public GetRootPlayableCount () : int
        /**
        * Returns the number of PlayableOutput in the graph.
        * @returns The number of PlayableOutput in the graph.
        */
        public GetOutputCount () : int
    }

    /**
    * Defines what time source is used to update a Director graph.
    */
    enum DirectorUpdateMode {
        DSPClock = 0,
        GameTime = 1,
        UnscaledGameTime = 2,
        Manual = 3 
    }

    /**
    * Interface implemented by all C# Playable Behaviour implementations.
    */
    interface IPlayableBehaviour {

        OnGraphStart? ($playable: Playable) : void
        OnGraphStop? ($playable: Playable) : void
        OnPlayableCreate? ($playable: Playable) : void
        OnPlayableDestroy? ($playable: Playable) : void
        OnBehaviourPlay? ($playable: Playable, $info: FrameData) : void
        OnBehaviourPause? ($playable: Playable, $info: FrameData) : void
        PrepareFrame? ($playable: Playable, $info: FrameData) : void
        ProcessFrame? ($playable: Playable, $info: FrameData, $playerData: any) : void
    }

    /**
    * Default implementation for Playable notifications.
    */
    class Notification extends System.Object implements INotification {

        /**
        * The name that identifies this notification.
        */
        public get id(): UnityEngine.PropertyName;

        /**
        * Creates a new notification with the name specified in the argument.
        * @param name The name that identifies this notifications.
        */
        public constructor ($name: string)
    }

    /**
    * Wrap mode for Playables.
    */
    enum DirectorWrapMode {
        Hold = 0,
        Loop = 1,
        None = 2 
    }

    /**
    * Interface that permits a class to inject playables into a graph.
    */
    interface IPlayableAsset {

        /**
        * Duration in seconds.
        */
        readonly duration? : double
        /**
        * A description of the PlayableOutputs generated by this asset.
        */
        readonly outputs? : System_Collections_Generic.IEnumerable$1<PlayableBinding>

        /**
        * Implement this method to have your asset inject playables into the given graph.
        * @param graph The graph to inject playables into.
        * @param owner The game object which initiated the build.
        * @returns The playable injected into the graph, or the root playable if multiple playables are injected.
        */
        CreatePlayable? ($graph: PlayableGraph, $owner: UnityEngine.GameObject) : Playable
    }

    /**
    * Struct that holds information regarding an output of a PlayableAsset.
    */
    class PlayableBinding extends System.ValueType {

        /**
        * A constant to represent a PlayableAsset has no bindings.
        */
        public static None : PlayableBinding[]
        /**
        * The default duration used when a PlayableOutput has no fixed duration.
        */
        public static DefaultDuration : double
        /**
        * The name of the output or input stream.
        */
        public get streamName(): string;
        public set streamName(value: string);
        /**
        * A reference to a UnityEngine.Object that acts a key for this binding.
        */
        public get sourceObject(): UnityEngine.Object;
        public set sourceObject(value: UnityEngine.Object);
        /**
        * The type of target required by the PlayableOutput for this PlayableBinding.
        */
        public get outputTargetType(): System.Type;

    }

    /**
    * A base class for assets that can be used to instantiate a Playable at runtime.
    */
    class PlayableAsset extends UnityEngine.ScriptableObject implements IPlayableAsset {

        /**
        * The name of the object.
        */
        public get name(): string;
        public set name(value: string);
        /**
        * Should the object be hidden, saved with the Scene or modifiable by the user?
        */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        /**
        * The playback duration in seconds of the instantiated Playable.
        */
        public get duration(): double;
        /**
        * A description of the outputs of the instantiated Playable.
        */
        public get outputs(): System_Collections_Generic.IEnumerable$1<PlayableBinding>;

        /**
        * Implement this method to have your asset inject playables into the given graph.
        * @param graph The graph to inject playables into.
        * @param owner The game object which initiated the build.
        * @returns The playable injected into the graph, or the root playable if multiple playables are injected.
        */
        public CreatePlayable ($graph: PlayableGraph, $owner: UnityEngine.GameObject) : Playable
        private constructor ()
    }

    /**
    * PlayableBehaviour is the base class from which every custom playable script derives.
    */
    class PlayableBehaviour extends System.Object implements System.ICloneable, IPlayableBehaviour {

        /**
        * This function is called when the PlayableGraph that owns this PlayableBehaviour starts.
        * @param playable The Playable that owns the current PlayableBehaviour.
        */
        public OnGraphStart ($playable: Playable) : void
        /**
        * This function is called when the PlayableGraph that owns this PlayableBehaviour stops.
        * @param playable The Playable that owns the current PlayableBehaviour.
        */
        public OnGraphStop ($playable: Playable) : void
        /**
        * This function is called when the Playable that owns the PlayableBehaviour is created.
        * @param playable The Playable that owns the current PlayableBehaviour.
        */
        public OnPlayableCreate ($playable: Playable) : void
        /**
        * This function is called when the Playable that owns the PlayableBehaviour is destroyed.
        * @param playable The Playable that owns the current PlayableBehaviour.
        */
        public OnPlayableDestroy ($playable: Playable) : void
        /**
        * This function is called when the Playable play state is changed to Playables.PlayState.Playing.
        * @param playable The Playable that owns the current PlayableBehaviour.
        * @param info A FrameData structure that contains information about the current frame context.
        */
        public OnBehaviourPlay ($playable: Playable, $info: FrameData) : void
        /**
        * This method is invoked when one of the following situations occurs:
        * <br><br>
        * The effective play state during traversal is changed to Playables.PlayState.Paused. This state is indicated by FrameData.effectivePlayState.<br><br>
        * The PlayableGraph is stopped while the playable play state is Playing. This state is indicated by PlayableGraph.IsPlaying returning true.
        * @param playable The Playable that owns the current PlayableBehaviour.
        * @param info A FrameData structure that contains information about the current frame context.
        */
        public OnBehaviourPause ($playable: Playable, $info: FrameData) : void
        /**
        * This function is called during the PrepareData phase of the PlayableGraph.
        * @param playable The Playable that owns the current PlayableBehaviour.
        * @param info A FrameData structure that contains information about the current frame context.
        */
        public PrepareData ($playable: Playable, $info: FrameData) : void
        /**
        * This function is called during the PrepareFrame phase of the PlayableGraph.
        * @param playable The Playable that owns the current PlayableBehaviour.
        * @param info A FrameData structure that contains information about the current frame context.
        */
        public PrepareFrame ($playable: Playable, $info: FrameData) : void
        /**
        * This function is called during the ProcessFrame phase of the PlayableGraph.
        * @param playable The Playable that owns the current PlayableBehaviour.
        * @param info A FrameData structure that contains information about the current frame context.
        * @param playerData The user data of the ScriptPlayableOutput that initiated the process pass.
        */
        public ProcessFrame ($playable: Playable, $info: FrameData, $playerData: any) : void
        public Clone () : any
    }

    /**
    * Traversal mode for Playables.
    */
    enum PlayableTraversalMode {
        Mix = 0,
        Passthrough = 1 
    }

    /**
    * Extensions for all the types that implements IPlayable.
    */
    class PlayableExtensions {

        public static IsNull<U extends IPlayable> ($playable: U) : boolean
        public static IsValid<U extends IPlayable> ($playable: U) : boolean
        public static Destroy<U extends IPlayable> ($playable: U) : void
        public static GetGraph<U extends IPlayable> ($playable: U) : PlayableGraph
        public static GetPlayState<U extends IPlayable> ($playable: U) : PlayState
        public static Play<U extends IPlayable> ($playable: U) : void
        public static Pause<U extends IPlayable> ($playable: U) : void
        /**
        * @methodSwap SetSpeed_EBB7509C_E07DEEC7
        */
        public static SetSpeed<U extends IPlayable> ($playable: U, $value: double) : void
        public static GetSpeed<U extends IPlayable> ($playable: U) : double
        /**
        * @methodSwap SetDuration_EBB7509C_E07DEEC7
        */
        public static SetDuration<U extends IPlayable> ($playable: U, $value: double) : void
        public static GetDuration<U extends IPlayable> ($playable: U) : double
        /**
        * @methodSwap SetTime_EBB7509C_E07DEEC7
        */
        public static SetTime<U extends IPlayable> ($playable: U, $value: double) : void
        public static GetTime<U extends IPlayable> ($playable: U) : double
        public static GetPreviousTime<U extends IPlayable> ($playable: U) : double
        public static SetDone<U extends IPlayable> ($playable: U, $value: boolean) : void
        public static IsDone<U extends IPlayable> ($playable: U) : boolean
        public static SetPropagateSetTime<U extends IPlayable> ($playable: U, $value: boolean) : void
        public static GetPropagateSetTime<U extends IPlayable> ($playable: U) : boolean
        public static CanChangeInputs<U extends IPlayable> ($playable: U) : boolean
        public static CanSetWeights<U extends IPlayable> ($playable: U) : boolean
        public static CanDestroy<U extends IPlayable> ($playable: U) : boolean
        /**
        * @methodSwap SetInputCount_EBB7509C_H6D080506
        */
        public static SetInputCount<U extends IPlayable> ($playable: U, $value: int) : void
        public static GetInputCount<U extends IPlayable> ($playable: U) : int
        /**
        * @methodSwap SetOutputCount_EBB7509C_H6D080506
        */
        public static SetOutputCount<U extends IPlayable> ($playable: U, $value: int) : void
        public static GetOutputCount<U extends IPlayable> ($playable: U) : int
        /**
        * @methodSwap GetInput_EBB7509C_H6D080506
        */
        public static GetInput<U extends IPlayable> ($playable: U, $inputPort: int) : Playable
        /**
        * @methodSwap GetOutput_EBB7509C_H6D080506
        */
        public static GetOutput<U extends IPlayable> ($playable: U, $outputPort: int) : Playable
        /**
        * @methodSwap SetInputWeight_EBB7509C_H4FB0A21F
        */
        public static SetInputWeight<U extends IPlayable> ($playable: U, $inputIndex: int, $weight: float) : void
        /**
        * @methodSwap SetInputWeight_EBB7509C_AC5CF4BE
        */
        public static SetInputWeight<U extends IPlayable,V extends IPlayable> ($playable: U, $input: V, $weight: float) : void
        /**
        * @methodSwap GetInputWeight_EBB7509C_H6D080506
        */
        public static GetInputWeight<U extends IPlayable> ($playable: U, $inputIndex: int) : float
        /**
        * @methodSwap ConnectInput_EBB7509C_H378FD045
        */
        public static ConnectInput<U extends IPlayable,V extends IPlayable> ($playable: U, $inputIndex: int, $sourcePlayable: V, $sourceOutputIndex: int) : void
        /**
        * @methodSwap ConnectInput_EBB7509C_H9893B462
        */
        public static ConnectInput<U extends IPlayable,V extends IPlayable> ($playable: U, $inputIndex: int, $sourcePlayable: V, $sourceOutputIndex: int, $weight: float) : void
        /**
        * @methodSwap DisconnectInput_EBB7509C_H6D080506
        */
        public static DisconnectInput<U extends IPlayable> ($playable: U, $inputPort: int) : void
        /**
        * @methodSwap AddInput_EBB7509C_DF16FF33
        */
        public static AddInput<U extends IPlayable,V extends IPlayable> ($playable: U, $sourcePlayable: V, $sourceOutputIndex: int, $weight?: float) : int
        /**
        * @methodSwap SetLeadTime_EBB7509C_EB9E40E2
        */
        public static SetLeadTime<U extends IPlayable> ($playable: U, $value: float) : void
        public static GetLeadTime<U extends IPlayable> ($playable: U) : float
        public static GetTraversalMode<U extends IPlayable> ($playable: U) : PlayableTraversalMode
        public static SetTraversalMode<U extends IPlayable> ($playable: U, $mode: PlayableTraversalMode) : void
    }

    /**
    * Extensions for all the types that implements IPlayableOutput.
    */
    class PlayableOutputExtensions {

        public static IsOutputNull<U extends IPlayableOutput> ($output: U) : boolean
        public static IsOutputValid<U extends IPlayableOutput> ($output: U) : boolean
        public static GetReferenceObject<U extends IPlayableOutput> ($output: U) : UnityEngine.Object
        public static SetReferenceObject<U extends IPlayableOutput> ($output: U, $value: UnityEngine.Object) : void
        public static GetUserData<U extends IPlayableOutput> ($output: U) : UnityEngine.Object
        public static SetUserData<U extends IPlayableOutput> ($output: U, $value: UnityEngine.Object) : void
        public static GetSourcePlayable<U extends IPlayableOutput> ($output: U) : Playable
        public static SetSourcePlayable<U extends IPlayableOutput,V extends IPlayable> ($output: U, $value: V) : void
        /**
        * @methodSwap SetSourcePlayable_EBB7509C_E54536BA
        */
        public static SetSourcePlayable<U extends IPlayableOutput,V extends IPlayable> ($output: U, $value: V, $port: int) : void
        public static GetSourceOutputPort<U extends IPlayableOutput> ($output: U) : int
        public static GetWeight<U extends IPlayableOutput> ($output: U) : float
        /**
        * @methodSwap SetWeight_EBB7509C_EB9E40E2
        */
        public static SetWeight<U extends IPlayableOutput> ($output: U, $value: float) : void
        public static PushNotification<U extends IPlayableOutput> ($output: U, $origin: Playable, $notification: INotification, $context?: any) : void
        public static GetNotificationReceivers<U extends IPlayableOutput> ($output: U) : INotificationReceiver[]
        public static AddNotificationReceiver<U extends IPlayableOutput> ($output: U, $receiver: INotificationReceiver) : void
        public static RemoveNotificationReceiver<U extends IPlayableOutput> ($output: U, $receiver: INotificationReceiver) : void
    }

    /**
    * A IPlayable implementation that contains a PlayableBehaviour for the PlayableGraph. PlayableBehaviour can be used to write custom Playable that implement their own PrepareFrame callback.
    */
    class ScriptPlayable$1<T> extends System.ValueType implements System.IEquatable$1<ScriptPlayable$1<T>>, IPlayable {

        public static get Null(): ScriptPlayable$1<T>;

        /**
        * @methodSwap Create_EBB7509C_F7D21B32
        */
        public static Create ($graph: PlayableGraph, $inputCount?: int) : ScriptPlayable$1<T>
        /**
        * @methodSwap Create_EBB7509C_EEEA050E
        */
        public static Create ($graph: PlayableGraph, $template: any, $inputCount?: int) : ScriptPlayable$1<T>
        public GetHandle () : PlayableHandle
        public GetBehaviour () : T
        public Equals ($other: ScriptPlayable$1<T>) : boolean
    }

    /**
    * A PlayableBinding that contains information representing a ScriptingPlayableOutput.
    */
    class ScriptPlayableBinding {

        /**
        * Creates a PlayableBinding that contains information representing a ScriptPlayableOutput.
        * @param key A reference to a UnityEngine.Object that acts as a key for this binding.
        * @param type The type of object that will be bound to the ScriptPlayableOutput.
        * @param name The name of the ScriptPlayableOutput.
        * @returns Returns a PlayableBinding that contains information that is used to create a ScriptPlayableOutput.
        */
        public static Create ($name: string, $key: UnityEngine.Object, $type: System.Type) : PlayableBinding
    }

    /**
    * A IPlayableOutput implementation that contains a script output for the a PlayableGraph.
    */
    class ScriptPlayableOutput extends System.ValueType implements IPlayableOutput {

        /**
        * Returns an invalid ScriptPlayableOutput.
        */
        public static get Null(): ScriptPlayableOutput;

        /**
        * Creates a new ScriptPlayableOutput in the associated PlayableGraph.
        * @param graph The PlayableGraph that will contain the ScriptPlayableOutput.
        * @param name The name of this ScriptPlayableOutput.
        * @returns The created ScriptPlayableOutput.
        */
        public static Create ($graph: PlayableGraph, $name: string) : ScriptPlayableOutput
        public GetHandle () : PlayableOutputHandle
        public static op_Implicit ($output: ScriptPlayableOutput) : PlayableOutput
        public static op_Explicit ($output: PlayableOutput) : ScriptPlayableOutput
    }

}

declare module 'UnityEngine.Playables.FrameData' {

    /**
    * Describes the cause for the evaluation of a PlayableGraph.
    */
    enum EvaluationType {
        Evaluate = 0,
        Playback = 1 
    }

}

declare module 'UnityEngine.Device' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'
    import * as System_Collections_Generic from 'System.Collections.Generic'

    /**
    * Access platform-specific display information.
    */
    class Screen {

        /**
        * This has the same functionality as Screen.autorotateToLandscapeLeft and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get autorotateToLandscapeLeft(): boolean;
        public static set autorotateToLandscapeLeft(value: boolean);
        /**
        * This has the same functionality as Screen.autorotateToLandscapeRight and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get autorotateToLandscapeRight(): boolean;
        public static set autorotateToLandscapeRight(value: boolean);
        /**
        * This has the same functionality as Screen.autorotateToPortrait and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get autorotateToPortrait(): boolean;
        public static set autorotateToPortrait(value: boolean);
        /**
        * This has the same functionality as Screen.autorotateToPortraitUpsideDown and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get autorotateToPortraitUpsideDown(): boolean;
        public static set autorotateToPortraitUpsideDown(value: boolean);
        /**
        * This has the same functionality as Screen.currentResolution and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get currentResolution(): UnityEngine.Resolution;
        /**
        * This has the same functionality as Screen.cutouts and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get cutouts(): UnityEngine.Rect[];
        /**
        * This has the same functionality as Screen.dpi and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get dpi(): float;
        /**
        * This has the same functionality as Screen.fullScreen and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get fullScreen(): boolean;
        public static set fullScreen(value: boolean);
        /**
        * This has the same functionality as Screen.fullScreenMode and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get fullScreenMode(): UnityEngine.FullScreenMode;
        public static set fullScreenMode(value: UnityEngine.FullScreenMode);
        /**
        * This has the same functionality as Screen.height and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get height(): int;
        /**
        * This has the same functionality as Screen.width and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get width(): int;
        /**
        * This has the same functionality as Screen.orientation and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get orientation(): UnityEngine.ScreenOrientation;
        public static set orientation(value: UnityEngine.ScreenOrientation);
        /**
        * This has the same functionality as Screen.resolutions and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get resolutions(): UnityEngine.Resolution[];
        /**
        * This has the same functionality as Screen.safeArea and also mimics platform-specific behavior in the Unity Editor.
        */
        public static get safeArea(): UnityEngine.Rect;
        /**
        * This has the same functionality as Screen.sleepTimeout. At the moment, the Device Simulator doesn't support simulation of this property.
        */
        public static get sleepTimeout(): int;
        public static set sleepTimeout(value: int);
        /**
        * This has the same functionality as Screen.brightness. At the moment, the Device Simulator doesn't support simulation of this property.
        */
        public static get brightness(): float;
        public static set brightness(value: float);
        /**
        * The Device Simulator doesn't simulate this property.
        */
        public static get mainWindowPosition(): UnityEngine.Vector2Int;
        /**
        * The Device Simulator doesn't simulate this property.
        */
        public static get mainWindowDisplayInfo(): UnityEngine.DisplayInfo;

        /**
        * This has the same functionality as Screen.SetResolution and also mimics platform-specific behavior in the Unity Editor.
        * @methodSwap SetResolution_EBB7509C_H19C6E178
        */
        public static SetResolution ($width: int, $height: int, $fullscreenMode: UnityEngine.FullScreenMode, $preferredRefreshRate: UnityEngine.RefreshRate) : void
        /**
        * This has the same functionality as Screen.SetResolution and also mimics platform-specific behavior in the Unity Editor.
        * @methodSwap SetResolution_EBB7509C_FE5F9494
        */
        public static SetResolution ($width: int, $height: int, $fullscreenMode: UnityEngine.FullScreenMode) : void
        /**
        * This has the same functionality as Screen.SetResolution and also mimics platform-specific behavior in the Unity Editor.
        * @methodSwap SetResolution_EBB7509C_H9B170F22
        */
        public static SetResolution ($width: int, $height: int, $fullscreen: boolean) : void
        public static GetDisplayLayout ($displayLayout: System_Collections_Generic.List$1<UnityEngine.DisplayInfo>) : void
        /**
        * The Device Simulator doesn't simulate this method.
        * @param display The target display where the window should move to.
        * @param position The position the window moves to. Relative to the top left corner of the specified display in pixels.
        * @returns Returns AsyncOperation that represents moving the window.
        */
        public static MoveMainWindowTo ($display: $Ref<UnityEngine.DisplayInfo>, $position: UnityEngine.Vector2Int) : UnityEngine.AsyncOperation
    }

}

declare module 'UnityEngine.TestTools' {
    import * as System from 'System'
    import * as System_Reflection from 'System.Reflection'

    /**
    * Describes a covered sequence point used by TestTools.Coverage. For an example of typical usage, see TestTools.Coverage.GetSequencePointsFor.
    */
    class CoveredSequencePoint extends System.ValueType {

        /**
        * The method covered by the sequence point.
        */
        public method : System_Reflection.MethodBase
        /**
        * The offset in bytes from the start of the method to the first Intermediate Language instruction of this sequence point.
        */
        public ilOffset : uint
        /**
        * The number of times the sequence point has been visited.
        */
        public hitCount : uint
        /**
        * The name of the file that contains the sequence point.
        */
        public filename : string
        /**
        * The line number of the file that contains the sequence point.
        */
        public line : uint
        /**
        * The column number of the line of the file that contains the sequence point.
        */
        public column : uint

    }

    /**
    * Describes the summary of the code coverage for the specified method used by TestTools.Coverage. For an example of typical usage, see TestTools.Coverage.GetStatsFor.
    */
    class CoveredMethodStats extends System.ValueType {

        /**
        * The covered method.
        */
        public method : System_Reflection.MethodBase
        /**
        * The total number of sequence points in the method.
        */
        public totalSequencePoints : int
        /**
        * The total number of uncovered sequence points in the method.
        */
        public uncoveredSequencePoints : int

        public ToString () : string
    }

    /**
    * Describes the interface for the code coverage data exposed by mono.
    */
    class Coverage {

        /**
        * Enables or disables code coverage. Note that Code Coverage can affect the performance.
        * @returns Returns true if code coverage is enabled; otherwise, returns false.
        */
        public static get enabled(): boolean;
        public static set enabled(value: boolean);

        /**
        * Returns the coverage sequence points for the method you specify. See CoveredSequencePoint for more information about the coverage data this method returns.
        * @param method The method to get the sequence points for.
        * @returns Array of sequence points.
        */
        public static GetSequencePointsFor ($method: System_Reflection.MethodBase) : CoveredSequencePoint[]
        /**
        * Returns the coverage summary for the specified method. See CoveredMethodStats for more information about the coverage statistics returned by this method.
        * @param method The method to get coverage statistics for.
        * @returns Coverage summary.
        */
        public static GetStatsFor ($method: System_Reflection.MethodBase) : CoveredMethodStats
        /**
        * Returns an array of coverage summaries for the specified array of methods.
        * @param methods The array of methods.
        * @returns Array of coverage summaries.
        */
        public static GetStatsFor ($methods: System_Reflection.MethodBase[]) : CoveredMethodStats[]
        /**
        * Returns an array of coverage summaries for the specified type.
        * @param type The type.
        * @returns Array of coverage summaries.
        */
        public static GetStatsFor ($type: System.Type) : CoveredMethodStats[]
        /**
        * Returns the coverage summary for all methods that have been called since either the Unity process was started or Coverage.ResetAll() has been called.
        * @returns Array of coverage summaries.
        */
        public static GetStatsForAllCoveredMethods () : CoveredMethodStats[]
        /**
        * Resets the coverage data for the specified method.
        * @param method The method.
        */
        public static ResetFor ($method: System_Reflection.MethodBase) : void
        /**
        * Resets all coverage data.
        */
        public static ResetAll () : void
    }

}

declare module 'UnityEngine.Experimental.GlobalIllumination' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'
    import * as UnityEngine_Experimental_GlobalIllumination_Lightmapping from 'UnityEngine.Experimental.GlobalIllumination.Lightmapping'

    /**
    * The light type.
    */
    enum LightType {
        Directional = 0,
        Point = 1,
        Spot = 2,
        Rectangle = 3,
        Disc = 4,
        SpotPyramidShape = 5,
        SpotBoxShape = 6 
    }

    /**
    * The lightmode. A light can be real-time, mixed, baked or unknown. Unknown lights will be ignored by the baking backends.
    */
    enum LightMode {
        Realtime = 0,
        Mixed = 1,
        Baked = 2,
        Unknown = 3 
    }

    /**
    * Available falloff models for baking.
    */
    enum FalloffType {
        InverseSquared = 0,
        InverseSquaredNoRangeAttenuation = 1,
        Linear = 2,
        Legacy = 3,
        Undefined = 4 
    }

    /**
    * Sets the method to use to compute the angular attenuation of spot lights.
    */
    enum AngularFalloffType {
        LUT = 0,
        AnalyticAndInnerAngle = 1 
    }

    /**
    * Contains normalized linear color values for red, green, blue in the range of 0 to 1, and an additional intensity value.
    */
    class LinearColor extends System.ValueType {

        /**
        * The red color value in the range of 0.0 to 1.0.
        */
        public get red(): float;
        public set red(value: float);
        /**
        * The green color value in the range of 0.0 to 1.0.
        */
        public get green(): float;
        public set green(value: float);
        /**
        * The blue color value in the range of 0.0 to 1.0.
        */
        public get blue(): float;
        public set blue(value: float);
        /**
        * The intensity value used to scale the red, green and blue values.
        */
        public get intensity(): float;
        public set intensity(value: float);

        /**
        * Converts a Light's color value to a normalized linear color value, automatically handling gamma conversion if necessary.
        * @param color Light color.
        * @param intensity Light intensity.
        * @returns Returns the normalized linear color value.
        */
        public static Convert ($color: UnityEngine.Color, $intensity: float) : LinearColor
        /**
        * Returns a black color.
        * @returns Returns a black color.
        */
        public static Black () : LinearColor
    }

    /**
    * A helper structure used to initialize a LightDataGI structure as a directional light.
    */
    class DirectionalLight extends System.ValueType {

        /**
        * The light's instanceID.
        */
        public instanceID : int
        /**
        * True if the light casts shadows, otherwise False.
        */
        public shadow : boolean
        /**
        * The lightmode.
        */
        public mode : LightMode
        /**
        * The light's position. Only relevant for cookie placement.
        */
        public position : UnityEngine.Vector3
        /**
        * The light's orientation. Only relevant for cookie placement.
        */
        public orientation : UnityEngine.Quaternion
        /**
        * The direct light color.
        */
        public color : LinearColor
        /**
        * The indirect light color.
        */
        public indirectColor : LinearColor
        /**
        * The penumbra width for soft shadows in radians.
        */
        public penumbraWidthRadian : float

    }

    /**
    * A helper structure used to initialize a LightDataGI structure as a point light.
    */
    class PointLight extends System.ValueType {

        /**
        * The light's instanceID.
        */
        public instanceID : int
        /**
        * True if the light casts shadows, otherwise False.
        */
        public shadow : boolean
        /**
        * The lightmode.
        */
        public mode : LightMode
        /**
        * The light's position.
        */
        public position : UnityEngine.Vector3
        /**
        * The light's orientation.
        */
        public orientation : UnityEngine.Quaternion
        /**
        * The direct light color.
        */
        public color : LinearColor
        /**
        * The indirect light color.
        */
        public indirectColor : LinearColor
        /**
        * The light's range.
        */
        public range : float
        /**
        * The light's sphere radius, influencing soft shadows.
        */
        public sphereRadius : float
        /**
        * The falloff model to use for baking the point light.
        */
        public falloff : FalloffType

    }

    /**
    * A helper structure used to initialize a LightDataGI structure as a spot light.
    */
    class SpotLight extends System.ValueType {

        /**
        * The light's instanceID.
        */
        public instanceID : int
        /**
        * True if the light casts shadows, otherwise False.
        */
        public shadow : boolean
        /**
        * The lightmode.
        */
        public mode : LightMode
        /**
        * The light's position.
        */
        public position : UnityEngine.Vector3
        /**
        * The light's orientation.
        */
        public orientation : UnityEngine.Quaternion
        /**
        * The direct light color.
        */
        public color : LinearColor
        /**
        * The indirect light color.
        */
        public indirectColor : LinearColor
        /**
        * The light's range.
        */
        public range : float
        /**
        * The light's sphere radius, influencing soft shadows.
        */
        public sphereRadius : float
        /**
        * The outer angle for the spot light.
        */
        public coneAngle : float
        /**
        * The inner angle for the spot light.
        */
        public innerConeAngle : float
        /**
        * The falloff model to use for baking the spot light.
        */
        public falloff : FalloffType
        /**
        * The angular falloff model to use for baking the spot light.
        */
        public angularFalloff : AngularFalloffType

    }

    /**
    * A helper structure used to initialize a LightDataGI structure as a rectangle light.
    */
    class RectangleLight extends System.ValueType {

        /**
        * The light's instanceID.
        */
        public instanceID : int
        /**
        * True if the light casts shadows, otherwise False.
        */
        public shadow : boolean
        /**
        * The lightmode.
        */
        public mode : LightMode
        /**
        * The light's position.
        */
        public position : UnityEngine.Vector3
        /**
        * The light's orientation.
        */
        public orientation : UnityEngine.Quaternion
        /**
        * The direct light color.
        */
        public color : LinearColor
        /**
        * The indirect light color.
        */
        public indirectColor : LinearColor
        /**
        * The light's range.
        */
        public range : float
        /**
        * The width of the rectangle light.
        */
        public width : float
        /**
        * The height of the rectangle light.
        */
        public height : float
        /**
        * The falloff model to use for baking the rectangular light.
        */
        public falloff : FalloffType

    }

    /**
    * A helper structure used to initialize a LightDataGI structure as a disc light.
    */
    class DiscLight extends System.ValueType {

        /**
        * The light's instanceID.
        */
        public instanceID : int
        /**
        * True if the light casts shadows, otherwise False.
        */
        public shadow : boolean
        /**
        * The lightmode.
        */
        public mode : LightMode
        /**
        * The light's position.
        */
        public position : UnityEngine.Vector3
        /**
        * The light's orientation.
        */
        public orientation : UnityEngine.Quaternion
        /**
        * The direct light color.
        */
        public color : LinearColor
        /**
        * The indirect light color.
        */
        public indirectColor : LinearColor
        /**
        * The light's range.
        */
        public range : float
        /**
        * The radius of the disc light.
        */
        public radius : float
        /**
        * The falloff model to use for baking the disc light.
        */
        public falloff : FalloffType

    }

    /**
    * Use this Struct to help initialize a LightDataGI structure as a box-shaped spot light.
    */
    class SpotLightBoxShape extends System.ValueType {

        /**
        * The light's instanceID.
        */
        public instanceID : int
        /**
        * Specifies whether the light casts shadows or not. This is true if the light does cast shadows and false otherwise.
        */
        public shadow : boolean
        /**
        * The lightmode.
        */
        public mode : LightMode
        /**
        * The light's position.
        */
        public position : UnityEngine.Vector3
        /**
        * The light's orientation.
        */
        public orientation : UnityEngine.Quaternion
        /**
        * The direct light color.
        */
        public color : LinearColor
        /**
        * The indirect light color.
        */
        public indirectColor : LinearColor
        /**
        * The light's range.
        */
        public range : float
        /**
        * The width of the box light.
        */
        public width : float
        /**
        * The height of the box light.
        */
        public height : float

    }

    /**
    * Use this Struct to help initialize a LightDataGI structure as a pyramid-shaped spot light.
    */
    class SpotLightPyramidShape extends System.ValueType {

        /**
        * The light's instanceID.
        */
        public instanceID : int
        /**
        * Specifies whether the light casts shadows or not. This is true if the light does cast shadows and false otherwise.
        */
        public shadow : boolean
        /**
        * The lightmode.
        */
        public mode : LightMode
        /**
        * The light's position.
        */
        public position : UnityEngine.Vector3
        /**
        * The light's orientation.
        */
        public orientation : UnityEngine.Quaternion
        /**
        * The direct light color.
        */
        public color : LinearColor
        /**
        * The indirect light color.
        */
        public indirectColor : LinearColor
        /**
        * The light's range.
        */
        public range : float
        /**
        * The opening angle of the shorter side of the pyramid light.
        */
        public angle : float
        /**
        * The aspect ratio for the pyramid shape. Values larger than 1 extend the width and values between 0 and 1 extend the height.
        */
        public aspectRatio : float
        /**
        * The falloff model to use for baking the pyramid light.
        */
        public falloff : FalloffType

    }

    /**
    * A helper structure used to initialize a LightDataGI structure with cookie information.
    */
    class Cookie extends System.ValueType {

        /**
        * The cookie texture's instance id projected by the light.
        */
        public instanceID : int
        /**
        * The uniform scale factor for downscaling cookies during lightmapping. Can be used as an optimization when full resolution cookies are not needed for indirect lighting.
        */
        public scale : float
        /**
        * The scale factors controlling how the directional light's cookie is projected into the scene. This parameter should be set to 1 for all other light types.
        */
        public sizes : UnityEngine.Vector2

        /**
        * Returns a default initialized cookie helper struct.
        */
        public static Defaults () : Cookie
    }

    /**
    * The interop structure to pass light information to the light baking backends. There are helper structures for Directional, Point, Spot and Rectangle lights to correctly initialize this structure.
    */
    class LightDataGI extends System.ValueType {

        /**
        * The light's instanceID.
        */
        public instanceID : int
        /**
        * The cookie texture's instance id projected by the light.
        */
        public cookieID : int
        /**
        * The uniform scale factor for downscaling cookies during lightmapping. Can be used as an optimization when full resolution cookies are not needed for indirect lighting.
        */
        public cookieScale : float
        /**
        * The color of the light.
        */
        public color : LinearColor
        /**
        * The indirect color of the light.
        */
        public indirectColor : LinearColor
        /**
        * The orientation of the light.
        */
        public orientation : UnityEngine.Quaternion
        /**
        * The position of the light.
        */
        public position : UnityEngine.Vector3
        /**
        * The range of the light. Unused for directional lights.
        */
        public range : float
        /**
        * The cone angle for spot lights.
        */
        public coneAngle : float
        /**
        * The inner cone angle for spot lights.
        */
        public innerConeAngle : float
        /**
        * The light's sphere radius for point and spot lights, or the width for rectangle lights.
        */
        public shape0 : float
        /**
        * The height for rectangle lights.
        */
        public shape1 : float
        /**
        * The type of the light.
        */
        public type : LightType
        /**
        * The lightmap mode for the light.
        */
        public mode : LightMode
        /**
        * Set to 1 for shadow casting lights, 0 otherwise.
        */
        public shadow : byte
        /**
        * The falloff model to use for baking point and spot lights.
        */
        public falloff : FalloffType

        public Init ($light: $Ref<DirectionalLight>, $cookie: $Ref<Cookie>) : void
        public Init ($light: $Ref<PointLight>, $cookie: $Ref<Cookie>) : void
        public Init ($light: $Ref<SpotLight>, $cookie: $Ref<Cookie>) : void
        public Init ($light: $Ref<RectangleLight>, $cookie: $Ref<Cookie>) : void
        public Init ($light: $Ref<DiscLight>, $cookie: $Ref<Cookie>) : void
        public Init ($light: $Ref<SpotLightBoxShape>, $cookie: $Ref<Cookie>) : void
        public Init ($light: $Ref<SpotLightPyramidShape>, $cookie: $Ref<Cookie>) : void
        /**
        * Initialize the struct with the parameters from the given light type.
        */
        public Init ($light: $Ref<DirectionalLight>) : void
        /**
        * Initialize the struct with the parameters from the given light type.
        */
        public Init ($light: $Ref<PointLight>) : void
        /**
        * Initialize the struct with the parameters from the given light type.
        */
        public Init ($light: $Ref<SpotLight>) : void
        /**
        * Initialize the struct with the parameters from the given light type.
        */
        public Init ($light: $Ref<RectangleLight>) : void
        public Init ($light: $Ref<DiscLight>) : void
        /**
        * Initialize the struct with the parameters from the given light type.
        */
        public Init ($light: $Ref<SpotLightBoxShape>) : void
        /**
        * Initialize the struct with the parameters from the given light type.
        */
        public Init ($light: $Ref<SpotLightPyramidShape>) : void
        /**
        * Initialize a light so that the baking backends ignore it.
        */
        public InitNoBake ($lightInstanceID: int) : void
    }

    /**
    * Utility class for converting Unity Lights to light types recognized by the baking backends.
    */
    class LightmapperUtils {

        /**
        * Extracts informations from Lights.
        * @param baketype The lights baketype.
        * @returns Returns the light's light mode.
        */
        public static Extract ($baketype: UnityEngine.LightmapBakeType) : LightMode
        /**
        * Extracts the indirect color from a light.
        */
        public static ExtractIndirect ($l: UnityEngine.Light) : LinearColor
        /**
        * Extracts the inner cone angle of spot lights.
        */
        public static ExtractInnerCone ($l: UnityEngine.Light) : float
        /**
        * Extract type specific information from Lights.
        * @param l The input light.
        * @param dir Extracts directional light information.
        * @param point Extracts point light information.
        * @param spot Extracts spot light information.
        * @param rect Extracts rectangle light information.
        */
        public static Extract ($l: UnityEngine.Light, $dir: $Ref<DirectionalLight>) : void
        /**
        * Extract type specific information from Lights.
        * @param l The input light.
        * @param dir Extracts directional light information.
        * @param point Extracts point light information.
        * @param spot Extracts spot light information.
        * @param rect Extracts rectangle light information.
        */
        public static Extract ($l: UnityEngine.Light, $point: $Ref<PointLight>) : void
        /**
        * Extract type specific information from Lights.
        * @param l The input light.
        * @param dir Extracts directional light information.
        * @param point Extracts point light information.
        * @param spot Extracts spot light information.
        * @param rect Extracts rectangle light information.
        */
        public static Extract ($l: UnityEngine.Light, $spot: $Ref<SpotLight>) : void
        /**
        * Extract type specific information from Lights.
        * @param l The input light.
        * @param dir Extracts directional light information.
        * @param point Extracts point light information.
        * @param spot Extracts spot light information.
        * @param rect Extracts rectangle light information.
        */
        public static Extract ($l: UnityEngine.Light, $rect: $Ref<RectangleLight>) : void
        public static Extract ($l: UnityEngine.Light, $disc: $Ref<DiscLight>) : void
        public static Extract ($l: UnityEngine.Light, $cookie: $Ref<Cookie>) : void
    }

    /**
    * Interface to the light baking backends.
    */
    class Lightmapping {

        /**
        * Set a delegate that converts a list of lights to a list of LightDataGI structures that are passed to the baking backends. Must be reset by calling ResetDelegate again.
        */
        public static SetDelegate ($del: UnityEngine_Experimental_GlobalIllumination_Lightmapping.RequestLightsDelegate) : void
        /**
        * Get the currently set conversion delegate.
        * @returns Returns the currently set conversion delegate.
        */
        public static GetDelegate () : UnityEngine_Experimental_GlobalIllumination_Lightmapping.RequestLightsDelegate
        /**
        * Resets the light conversion delegate to Unity's default conversion function.
        */
        public static ResetDelegate () : void
    }

    /**
    * Experimental render settings features.
    */
    class RenderSettings extends System.Object {

        /**
        * If enabled, ambient trilight will be sampled using the old radiance sampling method.
        */
        public static get useRadianceAmbientProbe(): boolean;
        public static set useRadianceAmbientProbe(value: boolean);

        public constructor ()
    }

}

declare module 'UnityEngine.Experimental.GlobalIllumination.Lightmapping' {
    import * as System from 'System'
    import * as UnityEngine from 'UnityEngine'
    import * as UnityEngine_Experimental_GlobalIllumination from 'UnityEngine.Experimental.GlobalIllumination'
    import * as Unity_Collections from 'Unity.Collections'

    /**
    * Delegate called when converting lights into a form that the baking backends understand.
    * @param requests The list of lights to be converted.
    * @param lightsOutput The output generated by the delegate function. Lights that should be skipped must be added to the output, initialized with InitNoBake on the LightDataGI structure.
    */
    interface RequestLightsDelegate {
        (requests: UnityEngine.Light[], lightsOutput: Unity_Collections.NativeArray$1<UnityEngine_Experimental_GlobalIllumination.LightDataGI>) : void; 
        Invoke?: (requests: UnityEngine.Light[], lightsOutput: Unity_Collections.NativeArray$1<UnityEngine_Experimental_GlobalIllumination.LightDataGI>) => void;
    }
    var RequestLightsDelegate: { new (func: (requests: UnityEngine.Light[], lightsOutput: Unity_Collections.NativeArray$1<UnityEngine_Experimental_GlobalIllumination.LightDataGI>) => void): RequestLightsDelegate; }

}

declare module 'UnityEngine.Experimental.Playables' {
    import * as System from 'System'
    import * as UnityEngine_Playables from 'UnityEngine.Playables'
    import * as UnityEngine from 'UnityEngine'

    /**
    * An implementation of IPlayable that produces a Camera texture.
    */
    class CameraPlayable extends System.ValueType implements System.IEquatable$1<CameraPlayable>, UnityEngine_Playables.IPlayable {

        /**
        * Creates a CameraPlayable in the PlayableGraph.
        * @param graph The PlayableGraph object that will own the CameraPlayable.
        * @param camera Camera used to produce a texture in the PlayableGraph.
        * @returns A CameraPlayable linked to the PlayableGraph.
        */
        public static Create ($graph: UnityEngine_Playables.PlayableGraph, $camera: UnityEngine.Camera) : CameraPlayable
        public GetHandle () : UnityEngine_Playables.PlayableHandle
        public Equals ($other: CameraPlayable) : boolean
        public GetCamera () : UnityEngine.Camera
        public SetCamera ($value: UnityEngine.Camera) : void
        public static op_Implicit ($playable: CameraPlayable) : UnityEngine_Playables.Playable
        public static op_Explicit ($playable: UnityEngine_Playables.Playable) : CameraPlayable
    }

    /**
    * An implementation of IPlayable that allows application of a Material shader to one or many texture inputs to produce a texture output.
    */
    class MaterialEffectPlayable extends System.ValueType implements System.IEquatable$1<MaterialEffectPlayable>, UnityEngine_Playables.IPlayable {

        public static Create ($graph: UnityEngine_Playables.PlayableGraph, $material: UnityEngine.Material, $pass?: int) : MaterialEffectPlayable
        public GetHandle () : UnityEngine_Playables.PlayableHandle
        public Equals ($other: MaterialEffectPlayable) : boolean
        public GetMaterial () : UnityEngine.Material
        public SetMaterial ($value: UnityEngine.Material) : void
        public GetPass () : int
        public SetPass ($value: int) : void
        public static op_Implicit ($playable: MaterialEffectPlayable) : UnityEngine_Playables.Playable
        public static op_Explicit ($playable: UnityEngine_Playables.Playable) : MaterialEffectPlayable
    }

    /**
    * An implementation of IPlayable that allows mixing two textures.
    */
    class TextureMixerPlayable extends System.ValueType implements System.IEquatable$1<TextureMixerPlayable>, UnityEngine_Playables.IPlayable {

        /**
        * Creates a TextureMixerPlayable in the PlayableGraph.
        * @param graph The PlayableGraph object that will own the TextureMixerPlayable.
        * @returns A TextureMixerPlayable linked to the PlayableGraph.
        */
        public static Create ($graph: UnityEngine_Playables.PlayableGraph) : TextureMixerPlayable
        public GetHandle () : UnityEngine_Playables.PlayableHandle
        public Equals ($other: TextureMixerPlayable) : boolean
        public static op_Implicit ($playable: TextureMixerPlayable) : UnityEngine_Playables.Playable
        public static op_Explicit ($playable: UnityEngine_Playables.Playable) : TextureMixerPlayable
    }

    /**
    * A PlayableBinding that contains information representing a TexturePlayableOutput.
    */
    class TexturePlayableBinding {

        /**
        * Creates a PlayableBinding that contains information representing a TexturePlayableOutput.
        * @param key A reference to a UnityEngine.Object that acts as a key for this binding.
        * @param name The name of the TexturePlayableOutput.
        * @returns Returns a PlayableBinding that contains information that is used to create a TexturePlayableOutput.
        */
        public static Create ($name: string, $key: UnityEngine.Object) : UnityEngine_Playables.PlayableBinding
    }

    /**
    * An IPlayableOutput implementation that will be used to manipulate textures.
    */
    class TexturePlayableOutput extends System.ValueType implements UnityEngine_Playables.IPlayableOutput {

        /**
        * Returns an invalid TexturePlayableOutput.
        */
        public static get Null(): TexturePlayableOutput;

        public static Create ($graph: UnityEngine_Playables.PlayableGraph, $name: string, $target: UnityEngine.RenderTexture) : TexturePlayableOutput
        public GetHandle () : UnityEngine_Playables.PlayableOutputHandle
        public GetTarget () : UnityEngine.RenderTexture
        public SetTarget ($value: UnityEngine.RenderTexture) : void
        public static op_Implicit ($output: TexturePlayableOutput) : UnityEngine_Playables.PlayableOutput
        public static op_Explicit ($output: UnityEngine_Playables.PlayableOutput) : TexturePlayableOutput
    }

}

declare module 'UnityEngine.Assertions' {
    import * as System from 'System'
    import * as System_Collections_Generic from 'System.Collections.Generic'
    import * as UnityEngine from 'UnityEngine'

    /**
    * The Assert class contains assertion methods for setting invariants in the code.
    */
    class Assert {

        /**
        * Asserts that the condition is true.
        * @param message The string used to describe the Assert.
        * @param condition true or false.
        */
        public static IsTrue ($condition: boolean) : void
        /**
        * Asserts that the condition is true.
        * @param message The string used to describe the Assert.
        * @param condition true or false.
        */
        public static IsTrue ($condition: boolean, $message: string) : void
        /**
        * Return true when the condition is false.  Otherwise return false.
        * @param condition true or false.
        * @param message The string used to describe the result of the Assert.
        */
        public static IsFalse ($condition: boolean) : void
        /**
        * Return true when the condition is false.  Otherwise return false.
        * @param condition true or false.
        * @param message The string used to describe the result of the Assert.
        */
        public static IsFalse ($condition: boolean, $message: string) : void
        /**
        * Assert the values are approximately equal.
        * @param tolerance Tolerance of approximation.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @methodSwap AreApproximatelyEqual_EBB7509C_H1075CF37
        */
        public static AreApproximatelyEqual ($expected: float, $actual: float) : void
        /**
        * Assert the values are approximately equal.
        * @param tolerance Tolerance of approximation.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @methodSwap AreApproximatelyEqual_EBB7509C_H94E223DD
        */
        public static AreApproximatelyEqual ($expected: float, $actual: float, $message: string) : void
        /**
        * Assert the values are approximately equal.
        * @param tolerance Tolerance of approximation.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @methodSwap AreApproximatelyEqual_EBB7509C_E4172388
        */
        public static AreApproximatelyEqual ($expected: float, $actual: float, $tolerance: float) : void
        /**
        * Assert the values are approximately equal.
        * @param tolerance Tolerance of approximation.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @methodSwap AreApproximatelyEqual_EBB7509C_CE23B7C4
        */
        public static AreApproximatelyEqual ($expected: float, $actual: float, $tolerance: float, $message: string) : void
        /**
        * Asserts that the values are approximately not equal.
        * @param tolerance Tolerance of approximation.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @methodSwap AreNotApproximatelyEqual_EBB7509C_H1075CF37
        */
        public static AreNotApproximatelyEqual ($expected: float, $actual: float) : void
        /**
        * Asserts that the values are approximately not equal.
        * @param tolerance Tolerance of approximation.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @methodSwap AreNotApproximatelyEqual_EBB7509C_H94E223DD
        */
        public static AreNotApproximatelyEqual ($expected: float, $actual: float, $message: string) : void
        /**
        * Asserts that the values are approximately not equal.
        * @param tolerance Tolerance of approximation.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @methodSwap AreNotApproximatelyEqual_EBB7509C_E4172388
        */
        public static AreNotApproximatelyEqual ($expected: float, $actual: float, $tolerance: float) : void
        /**
        * Asserts that the values are approximately not equal.
        * @param tolerance Tolerance of approximation.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @methodSwap AreNotApproximatelyEqual_EBB7509C_CE23B7C4
        */
        public static AreNotApproximatelyEqual ($expected: float, $actual: float, $tolerance: float, $message: string) : void
        public static AreEqual<T> ($expected: T, $actual: T) : void
        public static AreEqual<T> ($expected: T, $actual: T, $message: string) : void
        public static AreEqual<T> ($expected: T, $actual: T, $message: string, $comparer: System_Collections_Generic.IEqualityComparer$1<T>) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        */
        public static AreEqual ($expected: UnityEngine.Object, $actual: UnityEngine.Object, $message: string) : void
        public static AreNotEqual<T> ($expected: T, $actual: T) : void
        public static AreNotEqual<T> ($expected: T, $actual: T, $message: string) : void
        public static AreNotEqual<T> ($expected: T, $actual: T, $message: string, $comparer: System_Collections_Generic.IEqualityComparer$1<T>) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        */
        public static AreNotEqual ($expected: UnityEngine.Object, $actual: UnityEngine.Object, $message: string) : void
        public static IsNull<T> ($value: T) : void
        public static IsNull<T> ($value: T, $message: string) : void
        /**
        * Assert the value is null.
        * @param value The Object or type being checked for.
        * @param message The string used to describe the Assert.
        */
        public static IsNull ($value: UnityEngine.Object, $message: string) : void
        public static IsNotNull<T> ($value: T) : void
        public static IsNotNull<T> ($value: T, $message: string) : void
        /**
        * Assert that the value is not null.
        * @param value The Object or type being checked for.
        * @param message The string used to describe the Assert.
        */
        public static IsNotNull ($value: UnityEngine.Object, $message: string) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_E370C061
        */
        public static AreEqual ($expected: sbyte, $actual: sbyte) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_EB4B0AD7
        */
        public static AreEqual ($expected: sbyte, $actual: sbyte, $message: string) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_E370C061
        */
        public static AreNotEqual ($expected: sbyte, $actual: sbyte) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_EB4B0AD7
        */
        public static AreNotEqual ($expected: sbyte, $actual: sbyte, $message: string) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_F86FAAB7
        */
        public static AreEqual ($expected: byte, $actual: byte) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_DD7EAA5D
        */
        public static AreEqual ($expected: byte, $actual: byte, $message: string) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_F86FAAB7
        */
        public static AreNotEqual ($expected: byte, $actual: byte) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_DD7EAA5D
        */
        public static AreNotEqual ($expected: byte, $actual: byte, $message: string) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        */
        public static AreEqual ($expected: number, $actual: number) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        */
        public static AreEqual ($expected: number, $actual: number, $message: string) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        */
        public static AreNotEqual ($expected: number, $actual: number) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        */
        public static AreNotEqual ($expected: number, $actual: number, $message: string) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_A3880879
        */
        public static AreEqual ($expected: short, $actual: short) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_H4C86777F
        */
        public static AreEqual ($expected: short, $actual: short, $message: string) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_A3880879
        */
        public static AreNotEqual ($expected: short, $actual: short) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_H4C86777F
        */
        public static AreNotEqual ($expected: short, $actual: short, $message: string) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_H66932129
        */
        public static AreEqual ($expected: ushort, $actual: ushort) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_A4A1786F
        */
        public static AreEqual ($expected: ushort, $actual: ushort, $message: string) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_H66932129
        */
        public static AreNotEqual ($expected: ushort, $actual: ushort) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_A4A1786F
        */
        public static AreNotEqual ($expected: ushort, $actual: ushort, $message: string) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_H2CFB2EE5
        */
        public static AreEqual ($expected: int, $actual: int) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_H7955BF73
        */
        public static AreEqual ($expected: int, $actual: int, $message: string) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_H2CFB2EE5
        */
        public static AreNotEqual ($expected: int, $actual: int) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_H7955BF73
        */
        public static AreNotEqual ($expected: int, $actual: int, $message: string) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_DC598F91
        */
        public static AreEqual ($expected: uint, $actual: uint) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreEqual_EBB7509C_H86B941C7
        */
        public static AreEqual ($expected: uint, $actual: uint, $message: string) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_DC598F91
        */
        public static AreNotEqual ($expected: uint, $actual: uint) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        * @methodSwap AreNotEqual_EBB7509C_H86B941C7
        */
        public static AreNotEqual ($expected: uint, $actual: uint, $message: string) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        */
        public static AreEqual ($expected: bigint, $actual: bigint) : void
        /**
        * Assert that the values are equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        */
        public static AreEqual ($expected: bigint, $actual: bigint, $message: string) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        */
        public static AreNotEqual ($expected: bigint, $actual: bigint) : void
        /**
        * Assert that the values are not equal.
        * @param expected The assumed Assert value.
        * @param actual The exact Assert value.
        * @param message The string used to describe the Assert.
        * @param comparer Method to compare expected and actual arguments have the same value.
        */
        public static AreNotEqual ($expected: bigint, $actual: bigint, $message: string) : void
    }

    /**
    * An exception that is thrown when an assertion fails.
    */
    class AssertionException extends System.Exception {

        public get Message(): string;

        public constructor ($message: string, $userMessage: string)
    }

}

declare module 'UnityEngine.Assertions.Comparers' {
    import * as System from 'System'
    import * as System_Collections_Generic from 'System.Collections.Generic'

    /**
    * A float comparer used by Assertions.Assert performing approximate comparison.
    */
    class FloatComparer extends System.Object implements System_Collections_Generic.IEqualityComparer$1<float> {

        /**
        * Default instance of a comparer class with deafult error epsilon and absolute error check.
        */
        public static s_ComparerWithDefaultTolerance : FloatComparer
        /**
        * Default epsilon used by the comparer.
        */
        public static kEpsilon : float

        /**
        * Creates an instance of the comparer.
        * @param relative Should a relative check be used when comparing values? By default, an absolute check will be used.
        * @param error Allowed comparison error. By default, the FloatComparer.kEpsilon is used.
        */
        public constructor ()
        /**
        * Creates an instance of the comparer.
        * @param relative Should a relative check be used when comparing values? By default, an absolute check will be used.
        * @param error Allowed comparison error. By default, the FloatComparer.kEpsilon is used.
        */
        public constructor ($relative: boolean)
        /**
        * Creates an instance of the comparer.
        * @param relative Should a relative check be used when comparing values? By default, an absolute check will be used.
        * @param error Allowed comparison error. By default, the FloatComparer.kEpsilon is used.
        */
        public constructor ($error: float)
        /**
        * Creates an instance of the comparer.
        * @param relative Should a relative check be used when comparing values? By default, an absolute check will be used.
        * @param error Allowed comparison error. By default, the FloatComparer.kEpsilon is used.
        */
        public constructor ($error: float, $relative: boolean)
        public Equals ($a: float, $b: float) : boolean
        public GetHashCode ($obj: float) : int
        /**
        * Performs equality check with absolute error check.
        * @param expected Expected value.
        * @param actual Actual value.
        * @param error Comparison error.
        * @returns Result of the comparison.
        */
        public static AreEqual ($expected: float, $actual: float, $error: float) : boolean
        /**
        * Performs equality check with relative error check.
        * @param expected Expected value.
        * @param actual Actual value.
        * @param error Comparison error.
        * @returns Result of the comparison.
        */
        public static AreEqualRelative ($expected: float, $actual: float, $error: float) : boolean
    }

}

