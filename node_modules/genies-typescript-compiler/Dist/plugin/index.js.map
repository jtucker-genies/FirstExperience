{"version":3,"file":"index.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAQ,qCAAuCD,IAE/CD,EAAK,qCAAuCC,GAC7C,CATD,CASGK,MAAM,I,inDCTT,eAcA,YA4BA,IAAYC,EA8DAC,EA2CZ,SAAgBC,EAAqBC,GACjC,IAAIC,EAAYD,EAAUE,eAC1B,KAAOD,GAAW,CACd,GAA4B,kBAAxBA,EAAUE,UACV,OAAO,EAEXF,EAAYA,EAAUC,cAC1B,CACA,OAAO,CACX,CAEA,SAAgBE,EAAwBJ,GACpC,IAAIC,EAAYD,EAAUE,eAC1B,KAAOD,GAAW,CACd,GAA4B,qBAAxBA,EAAUE,UACV,OAAO,EAEXF,EAAYA,EAAUC,cAC1B,CACA,OAAO,CACX,CA6KA,SAASG,EAAaC,EAAYC,EAAqBC,G,MACnD,MAAMC,EAaV,SAAsBH,EAAYE,GAC9B,MAAMC,EAAoB,GACpBC,EAASJ,EAAKK,YACpB,IAAKD,EAAQ,OAAOD,EAEpB,MAAMG,EAAeF,EAAOG,kBAC5B,IAAKD,EAAc,OAAOH,EAE1B,IAAK,MAAMK,KAAeF,EACtB,GAAI,EAAAG,KAAKC,mBAAmBF,GAAc,CACtC,MAAMG,EAAkBH,EAAYI,qBACpC,IAAK,MAAMC,KAAkBF,EAAiB,CAC1C,MAAMG,EAAQD,EAAeE,eAC7B,IAAK,MAAMC,KAAYF,EAAO,CAC1B,MAAMG,EAAWf,EAAsBgB,YAAYC,kBAAkBH,GACjEC,GACAd,EAAUiB,KAAKH,EAEvB,CACJ,CACJ,CAEJ,OAAOd,CACX,CApCsBkB,CAAarB,EAAME,GACrC,IAAK,MAAMe,KAAYd,EAAW,CAC9B,MAAMmB,EAAmC,QAApB,EAAAL,EAASZ,mBAAW,eAAER,UAC3C,GAAIyB,GAAgBrB,EAAUsB,SAASD,GACnC,OAAO,EAEX,GAAIvB,EAAakB,EAAUhB,EAAWC,GAClC,OAAO,CAEf,CACA,OAAO,CACX,CAoJA,SAAgBsB,EAAgBxB,EAAYyB,GAAqB,EAAMC,GAA4B,GAC/F,IAAIC,EAAO,GAEX,MAAMC,EAAc5B,EAAK6B,iBAOzB,GALIF,EADAC,EACOA,EAAY/B,UAEZG,EAAK8B,UAGZ,CAAC,QAAS,MAAO,SAAU,OAAQ,OAAQ,UAAUP,SAASI,GAC9D,OAAQA,GACJ,IAAK,MACD,MAAO,eACX,IAAK,SACD,MAAO,gBACX,IAAK,OACD,MAAO,iBACX,IAAK,QACD,MAAO,gBACX,IAAK,OACD,MAAO,eACX,IAAK,SACD,MAAO,gBACX,QACI,OAAOA,EAInB,MAAMvB,EAASJ,EAAKK,YACpB,IAAKD,EACD,OAAOuB,EAGX,GAAKI,EAAkB/B,GAkCnB2B,EAAOvB,EAAO4B,wBAAwBC,QAAQ,QAAS,QAlC7B,CAC1B,MAAM3B,EAAeF,EAAOG,kBAC5B,IAAI2B,GAAa,EAQjB,GANA5B,EAAa6B,SAAQC,KACb,EAAA3B,KAAK4B,uBAAuBD,IAAS,EAAA3B,KAAKC,mBAAmB0B,MAC7DF,EAAaE,EAAKF,aACtB,KAGCA,GAAc5B,EAAagC,OAAS,EAAG,CACxC,MAAMC,EAAajC,EAAa,GAAGkC,gBAC7BC,EAAiBF,EAAWG,cAC5BC,EAAeC,EAA4BL,EAAWM,mBAAoBJ,GAC1EK,EAAaC,EAAKC,MAAML,GACxBM,EAAqBF,EAAKG,KAAKJ,EAAWK,IAAKL,EAAWM,MAEhEzB,EAAO,GAAGsB,KAAsB7C,EAAO4B,wBAAwBC,QAAQ,QAAS,KACpF,MACIN,EAAOvB,EAAO4B,wBAAwBC,QAAQ,QAAS,IAGvDN,EAAK0B,QAAQ,YAAc,IAC3B1B,EAAOA,EAAK2B,MAAM3B,EAAK0B,QAAQ,YAG/B1B,EAAK0B,QAAQ,kBAAoB,IACjC1B,EAAOA,EAAK2B,MAAM3B,EAAK0B,QAAQ,iBAAiBpB,QAAQ,eAAgB,aAGxEN,EAAK0B,QAAQ,0BAA4B,IACzC1B,EAAOA,EAAK2B,MAAM3B,EAAK0B,QAAQ,yBAAyBpB,QAAQ,uBAAwB,YAEhG,CAIA,MAAMsB,EAAQ,SACd,GAAI9B,GAAa8B,EAAMC,KAAK7B,KAExBA,EAAOA,EAAKM,QAAQsB,EAAO,IAEvB7B,GAAkB,CAClB,MAAM+B,EAAgBzD,EAAK0D,mBACvBD,EAAcnB,OAAS,IACvBX,GAAQ,IACR8B,EAActB,SAAQ,CAACwB,EAAKC,KACxB,IAAIC,EAAUrC,EAAgBmC,GAC9BhC,GAAQkC,EACJD,EAAQH,EAAcnB,OAAS,IAC/BX,GAAQ,KACZ,IAEJA,GAAQ,IAEhB,CAGJ,OAAOA,CACX,CAEA,SAAgBmC,EAAkBC,EAAuBC,EAAmB,GAAIC,EAAqC,IAAIC,KACrH,MAAMC,EAA6B,GAiFnC,OA/EAJ,EAAIK,gBAAgBjC,SAAQkC,IACxB,MAAMC,EAAaD,EAAKE,WAClBC,EAAaC,EAAkBJ,GAErC,GAAmB,YAAfC,IAA6BE,EAAWE,MAAKC,GAAKA,EAAEC,OAAS,EAAAC,0BAC7D,OAGJ,GAAmB,WAAfP,GAA2BE,EAAWE,MAAKC,GAAKA,EAAEC,OAAS,EAAAE,yBAC3D,OAGJ,MAAM9E,EAAO+E,EAAmBV,EAAKW,UAAWf,GAC1CgB,EAAUjF,EAAKiF,UAEfC,EAAeC,EAAwBnF,EAAMiE,GAC7CmB,EAAW5D,EAAgB0D,GAC3BG,EAAWhB,EAAKxE,UACtB,IAAIyF,EAAWtB,EAAW,GAAGA,KAAYqB,IAAaA,EAEtD,SAASE,EAAeC,GACpB,GAAIA,EAAWC,YAAc,EAAAC,WAAWC,cAAe,CACnD,MAAMC,EAAgBJ,EAMtB,MAAO,OAJchE,EADRoE,EAAcZ,cAIdY,EAAcC,eAAeC,KAAInC,GAAOA,EAAI7B,YAAWoB,KAAK,SAE7E,CACI,OAAOsC,EAAW1D,SAE1B,CAEA,MAAMiE,EAAmC,GACzC,GAAI1B,EAAK2B,iBAAkB,CACvB,MAAMC,EAAc5B,EAAKkB,iBACzB,GAAIU,EACA,GAAIA,EAAYR,YAAc,EAAAC,WAAWQ,uBAAwB,CAC7D,MAAMC,EAAeF,EACrB,IAAK,IAAIG,EAAI,EAAGA,EAAID,EAAaE,cAAc/D,OAAQ8D,IAAK,CACxD,MAAME,EAAUH,EAAaE,cAAcD,GAC3CL,EAAuB3E,KAAKmE,EAAee,GAC/C,CACJ,MACIP,EAAuB3E,KAAKmE,EAAeU,GAGvD,CAEA,MAAMM,EAA6B,CAC/BC,KAAMlB,EACNmB,KAAMpB,EACNqB,SAAUtB,EACVuB,gBAAiB,GACjBC,QAAS3B,EACT4B,QAAQ,EACRC,SAAU,GACVC,WAAY,GACZC,WAAYvC,EAAkBJ,GAC9B4C,sBAAsB,EACtBC,6BAA6B,EAC7BC,aAAcpB,EACdqB,6BAAyBC,EACzBC,gBAAiB,GAGrB,GAAIrC,EAAS,CACT,IAAIsC,EAAY,EAIhB,OAHAhB,EAAaa,wBAA0BI,EAA2BxH,EAAMoF,EAAUC,EAAUC,EAAUiC,EAAWtD,GACjHsC,EAAae,eAAiBC,OAC9BpD,EAAW/C,KAAKmF,EAEpB,CAEAkB,EAAsBvC,EAAcqB,EAActC,GAClDE,EAAW/C,KAAKmF,EAAa,IAG1BpC,CACX,CAEA,SAASsD,EAAsBvC,EAAoBqB,EAA4BtC,GAC3E,MAAMyD,EAASxC,EAAawC,SACtBtH,EAAS8E,EAAa7E,aAAe6E,EAAarD,iBAExD,IAAKzB,EACD,OAGJ,MACMI,EADeJ,EAAOG,kBACK,GAC3BoH,EAAcC,EAAyBpH,GACvCqH,EAAmBC,EAA4BtH,EAAamH,GAKlE,GAHApB,EAAaU,qBAAuBY,GAAoBrI,EAAiBuI,cACzExB,EAAaW,4BAA8BW,GAAoBrI,EAAiBwI,kBAE5EL,GAAeE,IAAqBrI,EAAiByI,OAIrDP,GAoCR,SAAsBnB,EAA4BrB,GAC9C,MAAM,KAACgD,EAAI,OAAEC,GA1UjB,SAA4BnI,GAIxB,MAAMI,EAASJ,EAAKK,YACdG,EAAcJ,aAAM,EAANA,EAAQG,kBAAkB6H,MAAKC,GAAOA,EAAI5C,YAAc,EAAAC,WAAW4C,kBACvF,OAAI9H,EACO,CACH0H,KAAM1H,EAAY+H,aAAazC,KAAI0C,GAAUA,EAAO3I,YACpDsI,OAAQ3H,EAAY+H,aAAazC,KAAI0C,GAAUA,EAAOC,cAGvD,CAACP,KAAM,GAAIC,OAAQ,GAC9B,CA6T2BO,CAAmBxD,GAC1CqB,EAAaO,SAAWoB,EACxB3B,EAAaQ,WAAaoB,EAAOrC,KAAI6C,QAAmBtB,IAAVsB,EAAsB,GAAKA,EAAMC,aAC/ErC,EAAaM,QAAS,CAC1B,CAxCQgC,CAAatC,EAAcrB,GAG3B9E,EAAOG,kBAAkBmE,MAAKlE,GAAe,EAAAC,KAAKC,mBAAmBF,MAAe,CACpF,MAAMd,EAAYU,EAAOG,kBAAkB6H,KAAK,EAAA3H,KAAKC,oBAC/CoI,EAAapJ,EAAUqJ,oBACvBC,EAAW9D,EAAaxB,mBACxBuF,EAAqB,IAAI/E,IAAID,GAEnC6E,EAAW3G,SAAQ,CAAC+G,EAAOtF,KACvB,MACMuF,EAAkB,GADND,EAAMrJ,aACgBH,EAAUG,YAClDoJ,EAAmBG,IAAID,EAAiBH,EAASpF,GAAO,IAI5D,MAAMyF,EAAkC,GACxC,IAAI1J,EAAYD,EAChB,KAAOC,GAAW,CACQA,EAAUE,UAEhCwJ,EAAgBC,WAAWxF,EAAkBnE,EAAW4G,EAAaC,KAAMyC,IAE3E,IAAIM,EAAU5J,EAAUC,eACxB,QAAgByH,IAAZkC,EAGA,MAFA5J,EAAY4J,CAIpB,CAEAhD,EAAaI,gBAAkB0C,CACnC,CACJ,CASA,SAAS7B,EAA2BxH,EAAYwJ,EAA4BnE,EAAkBoE,EAAkBlC,EAAmBtD,GAC/H,IAAIiB,EAAelF,EAAKiF,UAAYjF,EAAK0J,sBAAyB1J,EAG7DkF,EAAaD,YACdC,EAAeC,EAAwBD,EAAcjB,IAGzD,IAAI0F,EAAmBpC,EAEvB,MAAMhB,EAA6B,CAC/BC,KAAMiD,EAAW,KAAOlC,EACxBd,KAAMpB,EACNqB,SAAU8C,EACVlC,eAAgBC,EAChBZ,gBAAiB,GACjBC,QAAS1B,EAAaD,UACtB4B,OAAQ3B,EAAawC,SACrBZ,SAAU,GACVC,WAAY,GACZC,WAAY,GACZC,sBAAsB,EACtBC,6BAA6B,EAC7BC,aAAc,GACdC,6BAAyBC,GAS7B,OANKnC,EAAaD,UAGdsB,EAAaa,wBAA0BI,EAA2BtC,EAAcsE,EAAoBnE,EAAUoE,IAAYE,EAAkB1F,GAF5IwD,EAAsBvC,EAAcqB,EAActC,GAK/CsC,CACX,CAEA,SAASxB,EAAmB/E,EAAYiE,G,QACpC,IAAIiB,EAAelF,EAEnB,GAAIkF,EAAa0E,kBAAmB,CAChC,MAAMxE,EAAmC,QAAxB,EAAAF,EAAa7E,mBAAW,eAAER,UACrCgK,EAAqC,QAAxB,EAAA3E,EAAa7E,mBAAW,eAAEE,kBAAkB,GAAGuJ,YAE5DC,EAAiB,GAAG3E,KADCyE,GAAc,EAAApJ,KAAKC,mBAAmBmJ,GAAcA,EAAWhK,UAAY,KAElGkK,GAAkB9F,EAAgB+F,IAAID,KACtC7E,EAAejB,EAAgBgG,IAAIF,GAE3C,CAEA,OAAO7E,CACX,CAEA,SAASC,EAAwBnF,EAAYiE,GACzC,IAAIiB,EAAelF,EAEnB,KAAOkF,aAAY,EAAZA,EAAcD,WACjBC,EAAeA,EAAawE,sBAKhC,OAFAxE,EAAeH,EAAmBG,EAAcjB,GAEzCiB,CACX,CAEA,SAASgF,EAAwB3H,GAC7B,MAAM4H,EAAY5H,EAAW6H,gBAE7B,IAAKD,EAED,OADAE,QAAQC,IAAI,gCACL,EAGX,MAAMC,EAAkBJ,EAAUK,0BAClC,OAAOD,EAAgBjI,OAAS,GAAKiI,EAAgB,GAAGzI,YAAc,EAAA2I,+BAC1E,CAyBA,SAAgB1I,EAAkB/B,GAC9B,MAAMI,EAASJ,EAAKK,YAEpB,GAAKD,EAML,OAAO8J,EAFY9J,EAAOG,kBAAkB,GAAGiC,gBAGnD,CAEA,SAAgBoF,EAAyBpH,GAErC,OAAO0J,EADY1J,EAAYgC,gBAEnC,CAEA,SAASsF,EAA4BtH,EAAmBmH,GACpD,GAAInH,EAAYiF,YAAc,EAAAC,WAAWgF,kBAAoB/C,EACzD,OAAOnI,EAAiByI,KAG5B,MAAMlE,EAAMvD,EACNmK,EAAkBlL,EAAqBsE,GACvC6G,EAAqB9K,EAAwBiE,GAEnD,OAAI4G,EACOnL,EAAiBuI,cAGxB6C,EACOpL,EAAiBwI,iBAGrBxI,EAAiByI,IAC5B,CAEA,SAAgB4C,EAA4B7K,GACxC,MAAMI,EAASJ,EAAKK,YAEpB,IAAKD,EACD,OAAOZ,EAAiByI,KAG5B,MAAM3H,EAAeF,EAAOG,kBAC5B,GAA4B,IAAxBD,EAAagC,OACb,OAAO9C,EAAiByI,KAG5B,MAAMzH,EAAcF,EAAa,GAEjC,OAAOwH,EAA4BtH,EADfoH,EAAyBpH,GAEjD,CA4BA,SAAgBoC,EAA4BoB,EAAkBrB,GAC1D,MAAMmI,EAAe/H,EAAKgI,QAAQ/G,EAAUrB,GACtCqI,EAAajI,EAAKgI,QAAQ,UAGhC,IAAIE,EAAmBlI,EAAKmI,SAASF,EAAYF,GAQjD,OALKG,EAAiBE,WAAW,SAAWpI,EAAKqI,OAC7CH,EAAmBlI,EAAKG,KAAK,SAAU+H,IAItBA,EAIZI,MAAMtI,EAAKqI,KAAKlI,KAAK,IAHlC,CAMA,SAASuB,EAAkBJ,GACvB,OAAOA,EAAKiH,gBAAgBxF,KAAInB,IACiB,CACzCC,KAAMD,EAAE9E,UACR0L,KAAM5G,EAAEkB,eAAeC,KAAI0F,GAAKA,EAAE1J,eAI9C,CAr6Ba,EAAA2I,gCAAkC,8BAClC,EAAAgB,uBAAyB,qBACzB,EAAAC,sBAAwB,gBACxB,EAAAC,yBAA2B,mBAC3B,EAAA7G,uBAAyB,gBACzB,EAAA8G,yBAA2B,kBAC3B,EAAA/G,wBAA0B,iBAC1B,EAAAgH,gBAAkB,SAClB,EAAAC,eAAiB,QACjB,EAAAC,iBAAmB,UAEnB,EAAAC,cAAgB,WAChB,EAAAC,cAAgB,WAEhB,EAAAC,iBAAmB,IAAIC,IAAI,CACpC,eACA,kBACA,yBACA,0BACA,uBACA,wBACA,gBACA,iBAGJ,SAAY5M,GACR,mBACA,mCACA,iCACA,mCACA,iCACA,8BACA,8BACA,4BACA,qBACA,qBACA,2BACA,4DACA,0BACA,0BACA,0BACA,2CACA,uBACA,0BACH,CAnBD,CAAYA,IAAoB,uBAApBA,EAAoB,KAqBnB,EAAA6M,oBAAsB,IAAID,IAAI,CACvC,gDACA,+CACA,gDACA,+CACA,6CACA,6CACA,4CACA,wCACA,wCACA,2CACA,2DACA,0CACA,0CACA,0CACA,kDACA,wCACA,4CAGS,EAAAE,qBAAuB,IAAInI,IAAI,CACxC,CAAC,gDAAiD3E,EAAqB+M,cACvE,CAAC,+CAAgD/M,EAAqBgN,aACtE,CAAC,gDAAiDhN,EAAqBiN,cACvE,CAAC,+CAAgDjN,EAAqBkN,aACtE,CAAC,6CAA8ClN,EAAqBmN,WACpE,CAAC,6CAA8CnN,EAAqBoN,WACpE,CAAC,4CAA6CpN,EAAqBqN,UACnE,CAAC,wCAAyCrN,EAAqBsN,MAC/D,CAAC,wCAAyCtN,EAAqBuN,MAC/D,CAAC,2CAA4CvN,EAAqBwN,SAClE,CAAC,2DAA4DxN,EAAqByN,yBAClF,CAAC,0CAA2CzN,EAAqB0N,QACjE,CAAC,0CAA2C1N,EAAqB2N,QACjE,CAAC,0CAA2C3N,EAAqB4N,QACjE,CAAC,kDAAmD5N,EAAqB6N,gBACzE,CAAC,wCAAyC7N,EAAqB8N,MAC/D,CAAC,0CAA2C9N,EAAqB+N,UAIrE,SAAY9N,GACR,mBACA,qCACA,0CACH,CAJD,CAAYA,IAAgB,mBAAhBA,EAAgB,KA2C5B,yBAWA,4BAWA,4BAAiCgF,EAAyB+I,GACtD/I,EAAWrC,SAAQqL,IACXD,EAAUC,IACVA,EAAUC,QACd,GAER,EAOA,kCAAuCC,GACnC,MAAMC,EAAyB,IAAIxB,IAEnC,IAAIyB,EAA6CF,EAEjD,KAAOE,GAAc,CAEjB,MAAMC,EAAgBrM,EAAgBoM,EAAa5I,WAC/C6I,GACAF,EAAUG,IAAID,GAIYD,EAAaG,gBAErB5L,SAAQ6L,IAC1B,MAGMC,EAAgB,CAHJD,EAAgBhJ,WAKlC,KAAOiJ,EAAM3L,OAAS,GAAG,CACrB,MAAM4L,EAAmBD,EAAME,QAC/B,IAAKD,EACD,SAGJ,MAAME,EAAY5M,EAAgB0M,GAC7BE,IAAaT,EAAU3D,IAAIoE,KAIhCT,EAAUG,IAAIM,GAGIF,EAAiB7M,eACzBc,SAAQlB,IACdgN,EAAM7M,KAAKH,EAAS,IAE5B,KAIJ2M,EAAeA,EAAahO,cAChC,CAEA,OAAOyO,MAAMC,KAAKX,EACtB,EAEA,iCAAsCY,GAClC,OAAQA,GACJ,KAAK,EAAA7I,WAAW8I,kBACZ,MAAO,cACX,KAAK,EAAA9I,WAAW+I,uBACZ,MAAO,gBACX,KAAK,EAAA/I,WAAWgJ,iBACZ,MAAO,iBACX,KAAK,EAAAhJ,WAAWiJ,cACZ,MAAO,cACX,KAAK,EAAAjJ,WAAWkJ,uBACZ,MAAO,wBACX,KAAK,EAAAlJ,WAAWmJ,oBACZ,MAAO,qBACX,KAAK,EAAAnJ,WAAWoJ,eACZ,MAAO,gBACX,KAAK,EAAApJ,WAAWqJ,SACZ,MAAO,eACX,KAAK,EAAArJ,WAAWsJ,UACZ,MAAO,cACX,KAAK,EAAAtJ,WAAWuJ,WACZ,MAAO,iBACX,KAAK,EAAAvJ,WAAWwJ,WACZ,MAAO,cACX,KAAK,EAAAxJ,WAAWyJ,aACZ,MAAO,aACX,KAAK,EAAAzJ,WAAW0J,cACZ,MAAO,cACX,KAAK,EAAA1J,WAAW2J,sBACZ,MAAO,eACX,KAAK,EAAA3J,WAAW4J,4BACZ,MAAO,gBACX,KAAK,EAAA5J,WAAW6J,WACZ,MAAO,iBACX,KAAK,EAAA7J,WAAW8J,iBACZ,MAAO,gBACX,KAAK,EAAA9J,WAAW+J,WACZ,MAAO,oBACX,KAAK,EAAA/J,WAAWgK,cACZ,MAAO,eACX,KAAK,EAAAhK,WAAWiK,gBACZ,MAAO,eACX,QACI,OAEZ,EAGA,2BAAgC3P,GAC5B,MAAMI,EAASJ,EAAKK,YACpB,QAAKD,GAEW,cADHA,EAAOP,SAExB,EAEA,6BAAkCG,GAC9B,MAAMI,EAASJ,EAAKK,YACpB,QAAKD,GAGW,gBAFHA,EAAOP,SAGxB,EAGA,uCAA4CG,EAAY4P,EAA4BC,GAChF,MAAMC,EAAa9P,EAAKK,YACxB,IAAKyP,EACD,OAAO,KAGX,IAAIC,EAAW/P,EAAK8B,UAChBkO,EAAYH,EAAc/N,UAE9B,MAAMxB,EAAewP,EAAWvP,kBAChC,IAAK,MAAMC,KAAeF,EACtB,GAAI,EAAAG,KAAKC,mBAAmBF,GAAc,CACtC,MACMyP,EADmBzP,EACQ0P,aAAaC,QAAOC,GAAKA,EAAEvQ,YAAc+P,GAAuD,IAAjCQ,EAAErH,oBAAoBzG,SAEtH,IAAK,MAAM+N,KAAUJ,EAAS,CAC1B,MAAMK,EAAaD,EAAOE,gBAC1B,GAA0B,IAAtBD,EAAWhO,OAAc,CACzB,MAAMkO,EAAoBF,EAAW,GAAGtL,UAClCyL,EAAqBH,EAAW,GAAGtL,UACzC,GAAIwL,EAAkB1O,YAAciO,GAAYU,EAAmB3O,YAAckO,EAC7E,OAAOK,EAAOK,eAEtB,CACJ,CACJ,CAGJ,OAAO,IACX,EAGA,iDAAsD1Q,EAAYE,GAC9D,IAAKF,EAAM,OAAO,EAElB,MAAMI,EAASJ,EAAKK,YACpB,QAAKD,MAED,CAAC,aAAc,YAAa,iBAAiBmB,SAASnB,EAAOP,YAI1DE,EAAaC,EAAM,CAAC,aAAc,YAAa,iBAAkBE,GAC5E,EA0CA,4CAAiDF,EAAY4P,GACzD,MAAME,EAAa9P,EAAKK,YACxB,IAAKyP,EACD,OAAO,KAGX,MAAMxP,EAAewP,EAAWvP,kBAChC,IAAK,MAAMC,KAAeF,EACtB,GAAI,EAAAG,KAAKC,mBAAmBF,GAAc,CACtC,MACMyP,EADmBzP,EACQ0P,aAAaC,QAAOC,GAAKA,EAAEvQ,YAAc+P,GAAuD,IAAjCQ,EAAErH,oBAAoBzG,SAEtH,IAAK,MAAM+N,KAAUJ,EAAS,CAC1B,MAAMK,EAAaD,EAAOE,gBAC1B,GAA0B,IAAtBD,EAAWhO,QACSgO,EAAW,GAAGtL,UAClBlD,YAAc9B,EAAK8B,UAC/B,OAAOuO,EAAOK,eAG1B,CACJ,CAGJ,OAAO,IACX,EAiBA,wCAA6C1Q,EAAYuC,GAErD,IAAI6C,EAAWpF,EAAK8B,aAAQuF,EAAW,EAAAsJ,gBAAgB1I,MACnD2I,EAAa,GAEjB,GAAI,CAAC,QAAS,MAAO,SAAU,OAAQ,OAAQ,SAAU,UAAUrP,SAAS6D,GAAW,CACnF,OAAQA,GACJ,IAAK,MACDA,EAAW,QACX,MACJ,IAAK,OACDA,EAAW,UACX,MACJ,IAAK,QACDA,EAAW,SACX,MACJ,IAAK,OACDA,EAAW,QACX,MACJ,IAAK,SAML,IAAK,SACDA,EAAW,SACX,MALJ,IAAK,SACDA,EAAW,SAOnBwL,EAAa,QACjB,KAAO,CACH,MAAMC,EAAahG,EAA4B7K,GAC/C,GAAI6Q,IAAerR,EAAiByI,KAChC,OAAQ4I,GACJ,KAAKrR,EAAiBuI,cAClB3C,EAAW,gBACXwL,EAAa,cACb,MACJ,KAAKpR,EAAiBwI,iBAClB5C,EAAW,mBACXwL,EAAa,kBAGlB,KAAK7O,EAAkB/B,GAC1B,MAAM,IAAI8Q,MAAM,8BACb,CACH,MAAMC,EAAyBvP,EAAgBxB,GACzCgR,EAAeD,EAAuBE,YAAY,KACxDL,EAAaG,EAAuBG,UAAU,EAAGF,EACrD,EACJ,CAGA,MAAMG,EAAiB5O,EAAW6O,wBAAwBhJ,MAAKiJ,GACpDA,EAAWC,4BAA8BV,IAGpD,GAAKO,EAUoBA,EAAeI,kBAClB7M,MAAK8M,GAAeA,EAAY3R,YAAcuF,KAC5D+L,EAAeM,eAAerM,OAZjB,CAEjB,MAAMsM,EAA8C,CAChDC,KAAM,EAAAC,cAAcC,kBACpBC,gBAAiBlB,EACjBmB,aAAc,CAAC,CAAC3O,KAAMgC,KAE1B7C,EAAWyP,qBAAqBN,EACpC,CASA,OAAOtM,CACX,EAEA,oBA+FA,sBAgOA,yCAA8C6M,GAE1C,IAAItQ,EAAO,GAEX,MAAMC,EAAcqQ,EAAQpQ,iBAO5B,OALIF,EADAC,EACOA,EAAY/B,UAEZoS,EAAQnQ,YAGf,CAAC,QAAS,MAAO,SAAU,OAAQ,OAAQ,SAAU,UAAUP,SAASI,IAIzDkJ,EAA4BoH,KAC5BzS,EAAiByI,MAI7BlG,EAAkBkQ,EAC7B,EAEA,sBAYA,6BAyBA,gCAiBA,8BAAmCjS,GAC/B,IAAIkS,EAAQrH,EAA4B7K,GACxC,OAAOkS,IAAU1S,EAAiBuI,eAAiBmK,IAAU1S,EAAiBwI,gBAClF,EAKA,wCAA6CzF,GACzC,MAAM4P,EAAgB5P,EAAWM,mBAGjCN,EAAW6O,wBAAwBjP,SAAQiQ,IACvC,MAAMN,EAAkBM,EAAkBd,0BAG1C,GAAIQ,EAAgB3G,WAAW,OAAS2G,EAAgB3G,WAAW,OAAQ,CAEvE,MAAMxI,EAAeC,EAA4BuP,EAAeL,GAGhEM,EAAkBC,mBAAmB1P,EACzC,IAER,EAEA,+B,iMC15BA,eAeA,YACA,QAOM2P,EACmB,MADnBA,EAEmB,MAFnBA,EAGqC,MAHrCA,EAIqC,MAJrCA,EAKoC,MALpCA,EAMoC,MAIpCC,EAA4B,IAAIpG,IAAI,CAAC,gBAAiB,qBAEtDqG,EAAoB,IAAIrG,IAAI,CAC9B,eACA,kBACA,yBACA,0BACA,uBACA,wBACA,gBACA,iBAidJ,SAASsG,EACLC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAQH,EAAKI,WACbzQ,EAASqQ,EAAKK,WACdC,EAA4B,CAC9BC,KAAMP,EAAKnQ,gBAAgB2Q,aAC3BL,MAAOA,EACPxQ,OAAQA,EACRsQ,YAAaA,EACbQ,SAAU,UAAGC,mBAAmBvC,MAChC+B,KAAMA,EACNS,OAAQ,UAEZZ,EAAYtR,KAAK6R,EACrB,CA/dA,wCAA6CC,EAAkBhS,GAC3D,IAAKgS,EACD,MAAO,GAGX,MAAMR,EAA+B,GASrC,OAsJJ,SAAiCQ,EAAkBR,GACzBQ,EAAKK,aAEbpR,SAAQ4B,IAClB,MAAMpE,EAAYoE,EAAInE,eAChB4T,EAAwBzP,EAAIgK,gBAC5B0F,EAAgB9T,aAAS,EAATA,EAAWE,UAEjC,GAAIF,IAAa,IAAAoC,mBAAkBpC,EAAUqF,YAAcyO,IAAkBlB,EAA0BvI,IAAIyJ,GAAgB,CACvH,MAAMX,EAAQnT,EAAUoT,WAClBzQ,EAAS3C,EAAUqT,WAEnBU,EAAoB,UAAU3P,EAAIlE,0CAA0CF,EAAUE,gEACtFoT,EAA4B,CAC9BC,KAAMA,EAAKC,aACXL,MAAOA,EACPxQ,OAAQA,EACRsQ,YAAac,EACbN,SAAU,UAAGC,mBAAmBvC,MAChC+B,KAAMP,EACNgB,OAAQ,UAEZZ,EAAYtR,KAAK6R,EACrB,CAEAO,EAAsBrR,SAAQwR,IAC1B,IAAI,IAAA5R,mBAAkB4R,EAAK3O,WAAY,CAEnC,MAAMI,GAAW,IAAA5D,iBAAgBmS,EAAK3O,WACtC,GAAI,EAAAoH,oBAAoBpC,IAAI5E,GACxB,OAGJ,MAAM0N,EAAQa,EAAKZ,WACbzQ,EAASqR,EAAKX,WAEdU,EAAoB,UAAU3P,EAAIlE,sDAAsD8T,EAAK7R,cAC7FmR,EAA4B,CAC9BC,KAAMA,EAAKC,aACXL,MAAOA,EACPxQ,OAAQA,EACRsQ,YAAac,EACbN,SAAU,UAAGC,mBAAmBvC,MAChC+B,KAAMP,EACNgB,OAAQ,UAEZZ,EAAYtR,KAAK6R,EACrB,IACF,GAEV,CA/MIW,CAAwBV,EAAMR,GA2RlC,SAA0CQ,EAAkBR,GAChCQ,EAAKW,qBAAqB,EAAAnO,WAAWoO,gBAE7C3R,SAAQ4R,KAK5B,SAAkCA,EAA0BrB,GACxD,MAAMlN,EAAauO,EAASC,gBAG5B,IAAIC,EAA0C,GAE9C,GAAI,EAAAxT,KAAKyT,2BAA2B1O,IAAe,EAAA/E,KAAK0T,aAAa3O,GAAa,CAC9E,MAAM4O,EAAe5O,EAAWnF,YAC5B+T,IAEAH,EADqBG,EAAa7T,kBACA4P,QAAO/N,GAAQ,EAAA3B,KAAK4T,oBAAoBjS,KAElF,CAEA,GAAkC,IAA9B6R,EAAmB3R,OACnB,OAOJ,KAJiC2R,EAAmB9D,QAAO/N,GAChDA,EAAK2G,oBAAoBzG,OAAS,IAC1CA,OAAS,GAGR,OAMJ,GAFA2R,EAAqBA,EAAmB9D,QAAO/N,IAAQ,IAAAwF,0BAAyBxF,KAE9C,IAA9B6R,EAAmB3R,OACnB,OAGJ,MAAMgS,EAwHV,SAAuB9O,GACnB,OAAI,EAAA/E,KAAKyT,2BAA2B1O,GACzBA,EAAW3F,UACX,EAAAY,KAAK0T,aAAa3O,GAClBA,EAAW1D,UAEX,EAEf,CAhIuByS,CAAc/O,GAGjC,GA0DJ,SACIyO,EACAF,GAEA,MAAMS,EAAeT,EAASlO,eAAeC,KAAInC,GAAOA,EAAIqB,YACtD9D,EAAc6S,EAASU,aAAaC,iBAE1C,OAAOT,EAAmBvP,MAAKtC,IAC3B,GAAIA,EAAK2G,oBAAoBzG,OAAS,EAClC,OAAO,EAGX,MAAMgO,EAAalO,EAAKmO,gBACxB,GAAID,EAAWhO,SAAWkS,EAAalS,OACnC,OAAO,EAIX,IAAK,IAAI8D,EAAI,EAAGA,EAAIkK,EAAWhO,OAAQ8D,IAAK,CACxC,MAAMuO,EAAYrE,EAAWlK,GAAGpB,UAC1BiN,EAAUuC,EAAapO,GAE7B,IAAKlF,EAAY0T,mBAAmB3C,EAAS0C,GACzC,OAAO,CAEf,CAEA,OAAO,CAAI,GAEnB,CAvFQE,CAA8BZ,EAAoBF,GAClD,OAIJ,MAAM/K,EAAW+K,EAASrQ,mBAE1B,GAAwB,IAApBsF,EAAS1G,OAQT,YANAmQ,EACIC,EACAqB,EACA,mBAAmBO,yCACnBhC,GAKR,IAAIwC,EAAYb,EAAmBnO,KAAIsK,GAAKA,EAAErH,oBAAoBzG,SAC7DwS,EAAUvT,SAASyH,EAAS1G,SAE7BmQ,EACIC,EACAqB,EACA,mBAAmBO,sEAA+EQ,EAAU5R,KAAK,SACjHoP,GAKJE,EAAkBxI,IAAIsK,GAEtBtL,EAAS7G,SAAQ4S,KAyDzB,SAAiCA,GAC7B,MAAMC,EAAcD,EAAY/P,UAEhC,IAAI,IAAAjD,mBAAkBiT,GAElB,OAAO,EAIX,IADyB,IAAAnK,6BAA4BmK,KAC5B,EAAAxV,iBAAiBuI,cAEtC,OAAO,EAGX,MAAM3H,EAAS4U,EAAY3U,YAC3B,GAAID,EAAQ,CACR,MAAME,EAAeF,EAAOG,kBAC5B,GAAID,GAAgBA,EAAagC,OAAS,GAClC,EAAA7B,KAAK4B,uBAAuB/B,EAAa,IAEzC,OAAO,CAGnB,CAEA,OAAO,CACX,EAlFiB2U,CAAwBF,IACzBtC,EACIC,EACAqC,EACA,8BAA8BT,mFAC9BhC,EAER,IAIJtJ,EAAS7G,SAAQ4S,IACb,MAAMC,EAAcD,EAAY/P,WAC3B,IAAAkQ,+BAA8BF,IAC/BvC,EACIC,EACAqC,EACA,8BAA8BT,8BAC9BhC,EAER,GAGZ,CAhGQ6C,CAAyBpB,EAAUrB,EAAY,GAEvD,CAhSI0C,CAAiClC,EAAMR,GAgN3C,SAAqCQ,EAAkBR,GAE5BQ,EAAKW,qBAAqB,EAAAnO,WAAWC,eAG7CxD,SAAQkT,IAEnB,MAAMvF,EAAauF,EAAQrQ,UAAU3E,YAErC,IAAKyP,EACD,OAIJ,MAAMxP,EAAewP,EAAWvP,kBAEhC,IAAKD,GAAwC,IAAxBA,EAAagC,OAC9B,OAIJ,MAAMgT,EAAoBhV,EAAa6P,QAAO/N,GAC1C,EAAA3B,KAAKC,mBAAmB0B,KAAS,IAAAwF,0BAAyBxF,IAASA,EAAK2G,oBAAoBzG,OAAS,IAGzG,GAAiC,IAA7BgT,EAAkBhT,OAClB,OAGJ,MAEMiT,EAFmBD,EAAkB,GACPvM,oBACKzG,OAGnC0G,EAAWqM,EAAQ3R,mBACnB8R,EAAwBxM,EAAS1G,OAET,IAA1BkT,EAEA/C,EACIC,EACA2C,EACA,mBAAkB,IAAA7T,iBAAgB6T,EAAQrQ,yCAAyCuQ,sBACnFjD,IAGAkD,IAA0BD,GAE1B9C,EACIC,EACA2C,EACA,mBAAkB,IAAA7T,iBAAgB6T,EAAQrQ,uBAAuBuQ,+BAAmDC,KACpHlD,GAKRtJ,EAAS7G,SAAQ4S,IACb,MAAMC,EAAcD,EAAY/P,WAC3B,IAAAkQ,+BAA8BF,IAC/BvC,EACIC,EACAqC,EACA,6BAA4B,IAAAvT,iBAAgB6T,EAAQrQ,uCACpDsN,EAER,IAGR,GAER,CAtRImD,CAA4BvC,EAAMR,GAK3BA,CACX,C,2GC5DA,eACA,QAMA,0CAKI,WAAAgD,CAAYC,GAJJ,KAAAC,MAAqC,IAAI1R,IACzC,KAAA2R,mBAAqB,IAAI3R,IAI7B5E,KAAKqW,QAAUA,CACnB,CAEA,UAAIG,GACA,OAAOxW,KAAKqW,QAAQG,MACxB,CAEA,YAAAC,CAAaC,GACT,MAAMC,EAAiCD,EAAME,uBAC7CF,EAAME,uBAA0BC,GACrB7W,KAAK4W,uBAAuBD,EAAgCE,EAE3E,CAEA,sBAAAD,CAAuBE,EAAwCD,G,QAC3D,MAAME,EAAmBD,EAAeD,GACxC,IAAI5T,EAAajD,KAAKqW,QAAQnT,cAAc2T,GAC5C,IAAK5T,EACD,OAAO8T,EAIX/W,KAAKgX,mBAAmB/T,GAExB,IAAImQ,EAAc2D,EAAiBlG,QAAO8C,I,UACtC,MAAMH,EAAwB,QAAhB,EAAAG,EAAWH,aAAK,QAAI,EAC5ByD,GAAuB,QAAhB,EAAAtD,EAAWH,aAAK,QAAI,IAAuB,QAAjB,EAAAG,EAAW3Q,cAAM,QAAI,GAG5D,IAAK,MAAOwQ,MAAO0D,EAAWD,IAAKE,EAAO,MAAEC,KAAUpX,KAAKuW,mBAAmB1N,SAC1E,IAAK2K,GAAS0D,GAAaD,GAAOE,IAAYC,EAC1C,OAAO,EAGf,OAAO,CAAI,IAKf,OAFuB,QAAvB,EAAApX,KAAKuW,0BAAkB,SAAEc,QACf,QAAV,EAAArX,KAAKsW,aAAK,SAAEe,QACLjE,CACX,CAEA,kBAAA4D,CAAmB/T,GACf,MAAMqU,EAAoBrU,EAAYsR,qBAAqB,EAAAnO,WAAWmR,kBAChEC,EAAyBvU,EAAYsR,qBAAqB,EAAAnO,WAAWqR,uBACrEC,EAA0BzU,EAAYsR,qBAAqB,EAAAnO,WAAWuR,wBACtEC,EAAsB3U,EAAYsR,qBAAqB,EAAAnO,WAAWmR,kBAAkB1G,QAAOwC,IAC7F,MAAMhB,EAAOgB,EAAKwE,mBAAmB1R,UACrC,OAAOkM,GAAQ,EAAAjM,WAAW0R,yBAA2BzF,GAAQ,EAAAjM,WAAW2R,sBAAsB,IAG5FC,EAAe3E,IACjB,MAAMG,EAAQH,EAAKI,WACnB,GAAIzT,KAAKuW,mBAAmB7L,IAAI8I,GAC5B,OAGJ,MAAMyE,EAAYjY,KAAKkY,aAAa7E,GAC9B4D,EAAM5D,EAAK8E,SACXf,OAAsBrP,IAAdkQ,EACdjY,KAAKuW,mBAAmBzM,IAAI0J,EAAO,CAACA,QAAOyD,MAAKG,SAAO,EAG3DE,EAAkBzU,QAAQmV,GAC1BR,EAAuB3U,QAAQmV,GAC/BN,EAAwB7U,QAAQmV,GAChCJ,EAAoB/U,QAAQmV,EAChC,CAEA,YAAAE,CAAa7E,GACT,GAAIrT,KAAKsW,MAAM5L,IAAI2I,GACf,OAAOrT,KAAKsW,MAAM3L,IAAI0I,GAG1B,IAAI4E,EAEJ,GAAI,EAAA9W,KAAKiX,mBAAmB/E,GAAO,CAC/B,MAAMgF,EAAoBhF,EAAKwE,mBAAmB1R,UAC5CmS,EAAWjF,EAAKkF,UAChBC,EAAYnF,EAAKoF,WACjBC,EAAW1Y,KAAKkY,aAAaI,GAC7BK,EAAY3Y,KAAKkY,aAAaM,GAC9BxD,GAAa,IAAA4D,uBAAsBP,GAEzC,GAAIrD,GAAc0D,GAAYC,EAAW,CACrC,MAAME,GAAiB,IAAAC,6BAA4BJ,EAAU1D,EAAY2D,GACnEI,GAAkB,IAAAD,6BAA4BH,EAAW3D,EAAY0D,GAGvET,EADAY,GAEOE,QAGKhR,CAEpB,MACIkQ,OAAYlQ,CAGpB,MAAO,GAAI,EAAA5G,KAAK6X,wBAAwB3F,IAAS,EAAAlS,KAAK8X,yBAAyB5F,GAAO,CAClF,MAAM6F,EAAU7F,EAAK8F,aACflK,EAAeoE,EAAKwE,mBACpBvH,GAAqB,IAAAsI,uBAAsB3J,GAC3CmK,EAAcpZ,KAAKqW,QAAQgD,YAAYxX,kBAAkBqX,GAE/D,GAAI5I,EAAoB,CAGhB2H,GAFsB,IAAAqB,kCAAiCF,EAAa9I,SAIxDvI,CAEpB,MACIkQ,OAAYlQ,CAGpB,MACIkQ,EAAYjY,KAAKqW,QAAQgD,YAAYxX,kBAAkBwR,IACnD4E,aAAS,EAATA,EAAWsB,eACXtB,EAAYjY,KAAKqW,QAAQgD,YAAYG,yBAAyBvB,IAKtE,OADAjY,KAAKsW,MAAMxM,IAAIuJ,EAAM4E,GACdA,CACX,E,oGCzIJ,eAEA,kCAGI,WAAA7B,CAAYC,GACRrW,KAAKqW,QAAUA,CACnB,CAEA,UAAIG,GACA,OAAOxW,KAAKqW,QAAQG,MACxB,CAEA,YAAAC,CAAaC,GACT,MAAMC,EAAiCD,EAAME,uBAC7CF,EAAME,uBAA0BC,IAC5B,IAAIzD,EAAcuD,EAA+BE,GAEjD,OADAzD,EAAcpT,KAAKyZ,6BAA6BrG,EAAayD,GACtDzD,CAAW,CAE1B,CAEQ,4BAAAqG,CAA6BC,EAAsC7C,GACvE,MAAM5T,EAAajD,KAAKqW,QAAQnT,cAAc2T,GAC9C,IAAK5T,EACD,OAAOyW,EAIX,MAAMC,GAAkC,IAAAF,8BAA6BxW,EAAYjD,KAAKqW,QAAQgD,aAW9F,MAAO,IAR2BK,EAAoB7I,QAAO+I,IACxDD,EAAevU,MAAKyU,GACjBA,EAAQvG,cAAgBsG,EAAatG,aACrCuG,EAAQrG,QAAUoG,EAAapG,OAC/BqG,EAAQ7W,SAAW4W,EAAa5W,cAIC2W,EAC7C,E,yFCzCJ,yBAII,WAAAvD,CAAY0D,EAAkBC,GAC1B/Z,KAAK8Z,QAAUA,EACf9Z,KAAK+Z,KAAOA,CAChB,CAEA,UAAIvD,GACA,OAAOxW,KAAK+Z,KAAKD,QAAQE,eAAeC,MAC5C,CAEA,eAAIZ,GAEA,OAAOrZ,KAAK8Z,QAAQ1E,gBACxB,CAEA,aAAAlS,CAAc2T,GACV,IAAI5T,EAAajD,KAAK8Z,QAAQ5W,cAAc2T,GAC5C,IAAK5T,IACDA,EAAajD,KAAK8Z,QAAQI,oBAAoBrD,IAE1C5T,GAGA,YADAjD,KAAKwW,OAAOuD,KAAK,0BAKzB,MAAMI,EAAWna,KAAKoa,uBAAuBvD,EAAU7W,KAAK+Z,KAAKM,qBAMjE,OALGF,GAEClX,EAAWqX,gBAAgBH,GAGxBlX,CACX,CAEQ,sBAAAmX,CAAuBvD,EAAkB0D,GAC7C,MAAMC,EAAiBD,EAAgBE,kBAAkB5D,GACzD,OAAO2D,EAAiBA,EAAehY,QAAQ,EAAGgY,EAAeE,kBAAe3S,CACpF,E,8HC3CS,EAAA4S,sBAAwB,CACjC,CAAE7W,KAAM,QAASkN,WAAY,GAAI4J,YAAa,mDAAoDC,QAAS,IAC3G,CAAE/W,KAAM,QAASkN,WAAY,GAAI4J,YAAa,wCAAyCC,QAAS,IAChG,CAAE/W,KAAM,WAAYkN,WAAY,GAAI4J,YAAa,qDAAsDC,QAAS,IAChH,CAAE/W,KAAM,YAAakN,WAAY,GAAI4J,YAAa,2CAA4CC,QAAS,IACvG,CAAE/W,KAAM,YAAakN,WAAY,GAAI4J,YAAa,mDAAoDC,QAAS,IAC/G,CAAE/W,KAAM,SAAUkN,WAAY,GAAI4J,YAAa,yBAA0BC,QAAS,IAClF,CAAE/W,KAAM,cAAekN,WAAY,GAAI4J,YAAa,uCAAwCC,QAAS,IACrG,CAAE/W,KAAM,aAAckN,WAAY,GAAI4J,YAAa,sCAAuCC,QAAS,IACnG,CAAE/W,KAAM,mBAAoBkN,WAAY,uBAAwB4J,YAAa,qFAAsFC,QAAS,CAAC,CAAEna,KAAM,YAAab,OAAQ,iBAC1M,CAAEiE,KAAM,kBAAmBkN,WAAY,uBAAwB4J,YAAa,uFAAwFC,QAAS,CAAC,CAAEna,KAAM,YAAab,OAAQ,iBAC3M,CAAEiE,KAAM,kBAAmBkN,WAAY,uBAAwB4J,YAAa,0FAA2FC,QAAS,CAAC,CAAEna,KAAM,YAAab,OAAQ,iBAC9M,CAAEiE,KAAM,qBAAsBkN,WAAY,yBAA0B4J,YAAa,2FAA4FC,QAAS,CAAC,CAAEna,KAAM,cAAeb,OAAQ,iBACtN,CAAEiE,KAAM,oBAAqBkN,WAAY,yBAA0B4J,YAAa,6FAA8FC,QAAS,CAAC,CAAEna,KAAM,cAAeb,OAAQ,iBACvN,CAAEiE,KAAM,oBAAqBkN,WAAY,yBAA0B4J,YAAa,gGAAiGC,QAAS,CAAC,CAAEna,KAAM,cAAeb,OAAQ,iBAC1N,CAAEiE,KAAM,iBAAkBkN,WAAY,kBAAmB4J,YAAa,qDAAsDC,QAAS,CAAC,CAAEna,KAAM,WAAYb,OAAQ,iBAClK,CAAEiE,KAAM,gBAAiBkN,WAAY,kBAAmB4J,YAAa,mEAAoEC,QAAS,CAAC,CAAEna,KAAM,WAAYb,OAAQ,iBAC/K,CAAEiE,KAAM,gBAAiBkN,WAAY,kBAAmB4J,YAAa,+EAAgFC,QAAS,CAAC,CAAEna,KAAM,WAAYb,OAAQ,iBAC3L,CAAEiE,KAAM,mBAAoBkN,WAAY,oBAAqB4J,YAAa,2DAA4DC,QAAS,CAAC,CAAEna,KAAM,aAAcb,OAAQ,iBAC9K,CAAEiE,KAAM,kBAAmBkN,WAAY,oBAAqB4J,YAAa,yEAA0EC,QAAS,CAAC,CAAEna,KAAM,aAAcb,OAAQ,iBAC3L,CAAEiE,KAAM,kBAAmBkN,WAAY,oBAAqB4J,YAAa,qFAAsFC,QAAS,CAAC,CAAEna,KAAM,aAAcb,OAAQ,iBACvM,CAAEiE,KAAM,0BAA2BkN,WAAY,6BAA8B4J,YAAa,gFAAiFC,QAAS,CAAC,CAAEna,KAAM,wBAAyBb,OAAQ,iBAC9N,CAAEiE,KAAM,QAASkN,WAAY,GAAI4J,YAAa,gDAAiDC,QAAS,IACxG,CAAE/W,KAAM,cAAekN,WAAY,GAAI4J,YAAa,2FAA4FC,QAAS,IACzJ,CAAE/W,KAAM,cAAekN,WAAY,GAAI4J,YAAa,oGAAqGC,QAAS,IAClK,CAAE/W,KAAM,YAAakN,WAAY,GAAI4J,YAAa,sDAAuDC,QAAS,IAClH,CAAE/W,KAAM,eAAgBkN,WAAY,GAAI4J,YAAa,2DAA4DC,QAAS,IAC1H,CAAE/W,KAAM,cAAekN,WAAY,GAAI4J,YAAa,2EAA4EC,QAAS,IACzI,CAAE/W,KAAM,cAAekN,WAAY,GAAI4J,YAAa,yEAA0EC,QAAS,IACvI,CAAE/W,KAAM,oBAAqBkN,WAAY,GAAI4J,YAAa,+HAAgIC,QAAS,IACnM,CAAE/W,KAAM,qBAAsBkN,WAAY,oBAAqB4J,YAAa,oDAAqDC,QAAS,IAC1I,CAAE/W,KAAM,qBAAsBkN,WAAY,uBAAwB4J,YAAa,oDAAqDC,QAAS,IAC7I,CAAE/W,KAAM,oBAAqBkN,WAAY,GAAI4J,YAAa,gDAAiDC,QAAS,IACpH,CAAE/W,KAAM,cAAekN,WAAY,GAAI4J,YAAa,qDAAsDC,QAAS,IACnH,CAAE/W,KAAM,eAAgBkN,WAAY,GAAI4J,YAAa,0DAA2DC,QAAS,IACzH,CAAE/W,KAAM,gBAAiBkN,WAAY,oDAAqD4J,YAAa,0DAA2DC,QAAS,CAAC,CAAEna,KAAM,gBAAiBb,OAAQ,iBAC7M,CAAEiE,KAAM,iBAAkBkN,WAAY,GAAI4J,YAAa,8CAA+CC,QAAS,IAC/G,CAAE/W,KAAM,qBAAsBkN,WAAY,GAAI4J,YAAa,wDAAyDC,QAAS,IAC7H,CAAE/W,KAAM,YAAakN,WAAY,GAAI4J,YAAa,4CAA6CC,QAAS,IACxG,CAAE/W,KAAM,eAAgBkN,WAAY,qBAAsB4J,YAAa,yDAA0DC,QAAS,IAC1I,CAAE/W,KAAM,iBAAkBkN,WAAY,GAAI4J,YAAa,2CAA4CC,QAAS,IAC5G,CAAE/W,KAAM,eAAgBkN,WAAY,GAAI4J,YAAa,uCAAwCC,QAAS,IACtG,CAAE/W,KAAM,aAAckN,WAAY,GAAI4J,YAAa,2EAA4EC,QAAS,IAExI,CAAE/W,KAAM,qBAAsBkN,WAAY,GAAI4J,YAAa,wCAAyCC,QAAS,IAC7G,CAAE/W,KAAM,sBAAuBkN,WAAY,GAAI4J,YAAa,yCAA0CC,QAAS,IAC/G,CAAE/W,KAAM,mBAAoBkN,WAAY,GAAI4J,YAAa,sCAAuCC,QAAS,KAGhG,EAAAC,+BAAiC,CAC1C,QACA,WACA,YACA,YACA,aACA,qBACA,qBACA,oBACA,qBACA,sBACA,mB,2GC9DJ,eACA,SAEA,QACA,QAMA,yCAGI,WAAA1E,CAAYC,GACRrW,KAAKqW,QAAUA,CACnB,CAEA,UAAIG,GACA,OAAOxW,KAAKqW,QAAQG,MACxB,CAEA,YAAAC,CAAaC,GACT,MAAMqE,EAAmCrE,EAAMsE,yBAC/CtE,EAAMsE,yBAA2B,CAACnE,EAAkBoE,EAAkBC,IAC3Dlb,KAAKgb,yBAAyBD,EAAkClE,EAAUoE,EAAUC,GAG/F,MAAMC,EAAoCzE,EAAM0E,0BAChD1E,EAAM0E,0BAA4B,CAACvE,EAAkBoE,EAAkBnX,EAAcuX,EAAyErH,EAA4BsH,EAA6CC,IAC5Nvb,KAAKob,0BAA0BD,EAAmCtE,EAAUoE,EAAUnX,EAAMuX,EAAerH,EAAQsH,EAAaC,EAE/I,CAEA,wBAAAP,CAAyBlE,EAA0CD,EAAkBoE,EAAkBC,G,YACnGlb,KAAKwW,OAAOuD,KAAK,oCAEjB,MAAMyB,EAAQ1E,EAAeD,EAAUoE,EAAUC,GAC3CO,EAAoC,GAEpCxY,EAAajD,KAAKqW,QAAQnT,cAAc2T,GACxC6E,EAA6G,QAAtF,EAAAF,aAAK,EAALA,EAAOG,QAAQ9K,QAAO+K,IAAU,EAAAjB,sBAAsB7R,MAAKoD,GAAKA,EAAEpI,MAAQ8X,EAAM9X,gBAAM,QAAI,GAEvH,GAAGb,EAAY,CACX,MAAM4Y,EAAkB7b,KAAK8b,mBAAmB7Y,EAAYgY,GACxDY,GACAJ,EAAY3Z,QAAQ+Z,EAAgBrV,KAAIuK,IAAU,CAE1CjN,KAAMiN,EAAOjN,KACbuO,KAAM,EAAA0J,kBAAkBC,sBACxBC,cAAe,UACfC,SAAU,IACVC,WAAY,WAAWpL,EAAOjN,QAAQiN,EAAOC,yBAAyBD,EAAO6J,iBAC7EwB,aAAc,CACVxB,YAAa7J,EAAO6J,aAExByB,WAAW,MAG3B,CAIA,OAFArc,KAAKwW,OAAOuD,KAAK,mDAEV,CACHuC,mBAA6C,QAAzB,EAAAd,aAAK,EAALA,EAAOc,0BAAkB,SAC7CC,mBAA6C,QAAzB,EAAAf,aAAK,EAALA,EAAOe,0BAAkB,SAC7CC,wBAAuD,QAA9B,EAAAhB,aAAK,EAALA,EAAOgB,+BAAuB,SACvDb,QAAS,IACDD,QAAAA,EAAwB,MACzBD,GAGf,CAEA,yBAAAL,CAA0BtE,EAA2CD,EAAkBoE,EAAkBnX,EAAcuX,EAAyErH,EAA4BsH,EAA6CC,GACrQ,MAAMC,EAAQ1E,EAAeD,EAAUoE,EAAUnX,EAAMuX,EAAerH,EAAQsH,EAAaC,GAC3F,GAAIC,EACA,OAAOA,EAGX,MAAMvY,EAAajD,KAAKqW,QAAQnT,cAAc2T,GAC9C,IAAK5T,EACD,OAAOuY,EAGX,MAAMK,EAAkB7b,KAAK8b,mBAAmB7Y,EAAYgY,GAC5D,IAAKY,EACD,OAAOL,EAGX,MAAMzK,EAAS8K,EAAgB/S,MAAKgI,GAAKA,EAAEhN,OAASA,IACpD,GAAIiN,EAAQ,CACR,MAAM0L,EAAuC,CACzC,CAACpa,KAAM,UAAWgQ,KAAM,WACxB,CAAChQ,KAAM,IAAKgQ,KAAM,SAClB,CAAChQ,KAAM0O,EAAOjN,KAAMuO,KAAM,cAC1B,CAAChQ,KAAM,IAAKgQ,KAAM,gBAGlBtB,EAAOC,YACPyL,EAAa3a,QACNiP,EAAOC,WAAWjF,MAAM,KAAK2Q,SAAQ9S,GAAS,CAC7C,CAACvH,KAAMuH,EAAMmC,MAAM,KAAK,GAAG4Q,OAAQtK,KAAM,iBACzC,CAAChQ,KAAM,KAAMgQ,KAAM,eACnB,CAAChQ,KAAMuH,EAAMmC,MAAM,KAAK,GAAG4Q,OAAQtK,KAAM,QACzC,CAAChQ,KAAM,KAAMgQ,KAAM,kBACpBrO,MAAM,GAAI,IAIrByY,EAAa3a,KACT,CAACO,KAAM,IAAKgQ,KAAM,eAClB,CAAChQ,KAAM,IAAKgQ,KAAM,UAGtB,MAAMuK,EAAU5c,KAAK6c,oBAAoBhG,EAAU9F,EAAO8J,SAE1D,MAAO,CACH/W,KAAMiN,EAAOjN,KACbuO,KAAM,EAAA0J,kBAAkBC,sBACxBC,cAAe,UACfQ,aAAcA,EACdK,cAAe,CAAC,CAACza,KAAM0O,EAAO6J,YAAavI,KAAM,SACjD0K,KAAM,GACNC,YAAa,CACT,CACIpC,YAAa,6BAA6B7J,EAAOjN,OACjD8Y,QAASA,IAIzB,CAGJ,CAEA,mBAAAC,CAAoBhG,EAAkBgE,GAClC,MAAM5X,EAAajD,KAAKqW,QAAQnT,cAAc2T,GAC9C,IAAK5T,EAAY,MAAO,GAExB,MAAM2Z,EAAgC,GAGhCK,EAAY,IAAIrY,IAgDtB,OA/CA3B,EAAW6O,wBAAwBjP,SAAQkP,IACvC,MAAMS,EAAkBT,EAAWC,0BAC7BS,EAAe,IAAI5F,IAAIkF,EAAWE,kBAAkBzL,KAAI0L,GAAeA,EAAY3R,aACzF0c,EAAUnT,IAAI0I,EAAiBC,EAAa,IAIhDoI,EAAQhY,SAAQqa,IACZ,MAAMC,EAAkBF,EAAUtS,IAAIuS,EAAIrd,QACtCsd,EACKA,EAAgBzS,IAAIwS,EAAIxc,OACzByc,EAAgB3O,IAAI0O,EAAIxc,MAG5Buc,EAAUnT,IAAIoT,EAAIrd,OAAQ,IAAIgN,IAAI,CAACqQ,EAAIxc,OAC3C,IAIJuc,EAAUpa,SAAQ,CAAC4P,EAAcD,KAC7B,MAAMX,EAAiB5O,EAAWma,qBAAqB5K,GACvD,GAAIX,EAAgB,CAChB,MAAMwL,EAAuBxL,EAAeI,kBAAkBzL,KAAI0L,GAAeA,EAAY3R,YACvF+c,EAAavO,MAAMC,KAAKyD,GAAc5B,QAAO/M,IAASuZ,EAAqBpb,SAAS6B,KAC1F,GAAIwZ,EAAWta,OAAS,EAAG,CACvB,MAAMua,EAAkB1L,EAAeI,kBAAkBuL,MACrDD,GACAX,EAAQ9a,KAAK,CACT+U,WACA4G,YAAa,CAAC,CACVC,QAAS,KAAKJ,EAAW1Z,KAAK,QAC9B+Z,KAAM,CAACnK,MAAO+J,EAAgBpF,SAAUnV,OAAQ,MAIhE,CACJ,MACI4Z,EAAQ9a,KAAK,CACT+U,WACA4G,YAAa,CAAC,CACVC,QAAS,YAAY3O,MAAMC,KAAKyD,GAAc7O,KAAK,iBAAiB4O,QACpEmL,KAAM,CAACnK,MAAO,EAAGxQ,OAAQ,MAGrC,IAGG4Z,CACX,CAEA,kBAAAd,CAAmB7Y,EAAwBgY,GASvC,IAAIY,EAFJ5Y,EAAW2a,4BAQX,MAAMvK,EAAOpQ,EAAW4a,mBAAmB5C,GAC3C,GAAI5H,EAAM,CACN,MAAMjF,EAAmBpO,KAAK8d,6BAA6BzK,EAAM4H,GAG3D8C,EAAS1K,EAAK7I,YACpB,IAAKuT,GAAUA,EAAO5X,YAAc,EAAAC,WAAWgF,iBAC3C,OAGJ,GAAIgD,EAAkB,CAClB,MAAM1N,EAAO0N,EAAiB1I,UACxB6C,GAAmB,IAAAgD,6BAA4B7K,GAErD,GAAG6H,IAAqB,EAAArI,iBAAiByI,KAGrC,YADA3I,KAAKwW,OAAOuD,KAAK,kDAIrB,MAAMiE,EAAkB5P,EAAiBwC,aAAapK,KAAIsK,GAAKA,EAAEvQ,YAC3D0d,EAAqB,EAAAtD,sBAAsB9J,QAAOqN,IAAOF,EAAgB/b,SAASic,EAAGpa,QAEvFyE,IAAqB,EAAArI,iBAAiBuI,cACtCoT,EAAkBoC,EACX1V,IAAqB,EAAArI,iBAAiBwI,mBAC7CmT,EAAkBoC,EAAmBpN,QAAOE,GAAU,EAAA+J,+BAA+B7Y,SAAS8O,EAAOjN,QAE7G,CACJ,CAEA,OAAO+X,CACX,CAEA,4BAAAiC,CAA6BzK,EAAY4H,GACrC,IAAIkD,EAA4B9K,EAChC,KAAO8K,GAAS,CACZ,GAAIA,EAAQhY,YAAc,EAAAC,WAAWgF,iBAAkB,CACnD,MAAMgD,EAAmB+P,EACnBC,EAAahQ,EAAiBqF,WAC9B4K,EAAWjQ,EAAiB+J,SAClC,GAAIiG,GAAcnD,GAAYA,GAAYoD,EACtC,OAAOjQ,CAEf,CACA+P,EAAUA,EAAQ3T,WACtB,CAEJ,E,2GC9PJ,cACA,QAGA,yCAGI,WAAA4L,CAAYC,GACRrW,KAAKqW,QAAUA,CACnB,CAEA,UAAIG,GACA,OAAOxW,KAAKqW,QAAQG,MACxB,CAEA,YAAAC,CAAaC,GACT,MAAM4H,EAAmC5H,EAAM6H,yBAC/C7H,EAAM6H,yBAA4B1H,IAC9B,MAAMzD,EAAckL,EAAiCzH,GACrD,OAAO7W,KAAKue,yBAAyBnL,EAAayD,EAAS,CAEnE,CAEQ,wBAAA0H,CAAyB7E,EAA+C7C,GAC5E,MAAM5T,EAAajD,KAAKqW,QAAQnT,cAAc2T,GAC9C,IAAI5T,EAEA,OAAOyW,EAGX,MAAM8E,EAAmB,IAAI3R,IAAI,EAAA8N,sBAAsBnU,KAAIuK,GAAUA,EAAOjN,QAkB5E,OAjBuBb,EAAWgR,aAC7BpD,QAAOpM,IAAO,IAAAga,oBAAmBha,EAAIiB,aACrCgX,SAAQjY,GAAOA,EAAImM,eACnBC,QAAOC,GAAK0N,EAAiB9T,IAAIoG,EAAEvQ,aAEzBsC,SAAQkO,IACS2I,EAAoB7I,QAAO8C,GACxB,OAApBA,EAAWJ,MAAiBI,EAAWH,QAAUzC,EAAO2N,cAAcjL,aAE7D5Q,SAAQ8Q,IACxB,MAAMrP,EAAQoV,EAAoB3V,QAAQ4P,GACtCrP,GAAS,GACToV,EAAoBiF,OAAOra,EAAO,EACtC,GACF,IAGCoV,CACX,E,sGCjDJ,cAGA,oCAGI,WAAAtD,CAAYC,GACRrW,KAAKqW,QAAUA,CACnB,CAEA,UAAIG,GACA,OAAOxW,KAAKqW,QAAQG,MACxB,CAEA,YAAAC,CAAaC,GACT,MAAM4H,EAAmC5H,EAAM6H,yBAC/C7H,EAAM6H,yBAA4B1H,IAC9B,MAAMzD,EAAckL,EAAiCzH,GACrD,OAAO7W,KAAKue,yBAAyBnL,EAAayD,EAAS,CAEnE,CAEQ,wBAAA0H,CAAyB7E,EAA+C7C,GAC5E,MAAM5T,EAAajD,KAAKqW,QAAQnT,cAAc2T,GAC9C,OAAK5T,GAIkBA,EAAWgR,aAC7BpD,QAAOpM,IAAO,IAAAga,oBAAmBha,EAAIiB,aAG3B7C,SAAQ4B,IACSiV,EAAoB7I,QAAO8C,IACnD3T,KAAKwW,OAAOuD,KAAK,eAAetV,EAAIlE,wBAAwBkE,EAAIgP,gBAAgBhP,EAAI0T,YACpFnY,KAAKwW,OAAOuD,KAAK,UAAUpG,EAAWJ,QACtCvT,KAAKwW,OAAOuD,KAAK,sBAAsBpG,EAAWH,SAClDxT,KAAKwW,OAAOuD,KAAK,wBAAwBpG,EAAWL,eAEzB,OAApBK,EAAWJ,MAAiBI,EAAWH,OAAS/O,EAAIgP,YAAcE,EAAWH,OAAS/O,EAAI0T,YAGjFtV,SAAQ8Q,IACxB,MAAMrP,EAAQoV,EAAoB3V,QAAQ4P,GACtCrP,GAAS,GACToV,EAAoBiF,OAAOra,EAAO,EACtC,GACF,IAGCoV,GAzBIA,CA0Bf,E,eCpDJ,eAGA,SACA,QACA,SACA,SACA,SACA,SAwCA,UAtCckF,IACV,IAAI9E,EACAzD,EAiCJ,MAAO,CAAEwI,OA/BT,SAAgB9E,GACZA,EAAKD,QAAQE,eAAeC,OAAOF,KAAK,2DAGxCD,EAAU,IAAI,EAAAgF,QAAQ,CAClBC,gBAAiBhF,EAAKD,QAAQkF,qBAC9BC,6BAA6B,IAGjC5I,EAAU,IAAI,EAAA6I,iBAAiBpF,EAASC,GAExC,MAAMoF,EAAsC,CACxC,IAAI,EAAAC,iCAAiC/I,GACrC,IAAI,EAAAgJ,kCAAkChJ,GACtC,IAAI,EAAAiJ,iCAAiCjJ,GACrC,IAAI,EAAAkJ,4BAA4BlJ,GAChC,IAAI,EAAAmJ,0BAA0BnJ,IAI5BK,EAA4B+I,OAAOZ,OAAO,MAChD,IAAK,MAAMa,KAAKD,OAAO7W,KAAKmR,EAAKQ,iBAAqD,CAClF,MAAMoF,EAAI5F,EAAKQ,gBAAgBmF,GAE/BhJ,EAAMgJ,GAAK,IAAIE,IAAoBD,EAAEE,MAAM9F,EAAKQ,gBAAiBqF,EACrE,CAGA,OADAT,EAAStc,SAAQid,GAAWA,EAAQrJ,aAAaC,KAC1CA,CACX,EAEiB,C,UC9CrB7W,EAAOD,QAAUmgB,QAAQ,W,UCAzBlgB,EAAOD,QAAUmgB,QAAQ,iC,UCAzBlgB,EAAOD,QAAUmgB,QAAQ,O,GCCrBC,EAA2B,CAAC,E,OAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBnY,IAAjBoY,EACH,OAAOA,EAAavgB,QAGrB,IAAIC,EAASmgB,EAAyBE,GAAY,CAGjDtgB,QAAS,CAAC,GAOX,OAHAwgB,EAAoBF,GAAUG,KAAKxgB,EAAOD,QAASC,EAAQA,EAAOD,QAASqgB,GAGpEpgB,EAAOD,OACf,CCnB0BqgB,CAAoB,G","sources":["file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/webpack/universalModuleDefinition","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/src/CompilerUtils.ts","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/src/GeniesDiagnosticsUtils.ts","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/src/plugins/CSharpOperatorOverloadingSupress.ts","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/src/plugins/GeniesInheritanceDiagnostics.ts","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/src/plugins/GeniesLSPContext.ts","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/src/plugins/GeniesLifecycleEvents.ts","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/src/plugins/GeniesLifecycleEventsCompletions.ts","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/src/plugins/GeniesLifecycleEventsDiagnostics.ts","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/src/plugins/GeniesScriptTypeDiagnostics.ts","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/src/plugins/index.ts","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/external commonjs \"ts-morph\"","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/external commonjs \"typescript/lib/tsserverlibrary\"","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/external node-commonjs \"path\"","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/webpack/bootstrap","file:///Users/rdalaq/Desktop/Projects/dev-kit-unity-sdk/GeniesSharedPackages/com.genies.components.sdk.scripting/Internal/TypeScript/Compiler/Project/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"genies-typescript-compiler-plugin\"] = factory();\n\telse\n\t\troot[\"genies-typescript-compiler-plugin\"] = factory();\n})(this, () => {\nreturn ","import {\n    ArrayLiteralExpression,\n    ClassDeclaration,\n    Decorator,\n    EnumDeclaration,\n    Expression, ImportDeclarationStructure,\n    MethodDeclaration,\n    NewExpression,\n    Node,\n    PropertyDeclaration,\n    SourceFile, StructureKind,\n    SyntaxKind,\n    Type, TypeFormatFlags\n} from \"ts-morph\";\nimport * as path from 'path';\nimport {TransformationContext} from \"./transformers/TransformationContext\";\n\nexport const GeniesDeclarationFileAnnotation = \"//@Genies-UnityApiInterface\";\nexport const GeniesInstancePropName = \"__geniesInstance__\";\nexport const MonobehaviourTypeName = \"MonoBehaviour\";\nexport const ScriptableObjectTypeName = \"ScriptableObject\";\nexport const NonSerializedDecorator = \"NonSerialized\";\nexport const HideInInspectorDecorator = \"HideInInspector\";\nexport const SerializeFieldDecorator = \"SerializeField\";\nexport const HeaderDecorator = \"Header\";\nexport const SpaceDecorator = \"Space\";\nexport const TooltipDecorator = \"Tooltip\";\n\nexport const GET_ITEM_NAME = \"get_Item\";\nexport const SET_ITEM_NAME = \"set_Item\";\n\nexport const componentMethods = new Set([\n    'GetComponent',\n    'TryGetComponent',\n    'GetComponentInChildren',\n    'GetComponentsInChildren',\n    'GetComponentInParent',\n    'GetComponentsInParent',\n    'GetComponents',\n    'AddComponent'\n]);\n\nexport enum GeniesScriptUiEvents {\n    None = 0,\n    PointerClick = 1 << 0, // 1\n    PointerDown = 1 << 1, // 2\n    PointerEnter = 1 << 2, // 4\n    PointerExit = 1 << 3, // 8\n    PointerUp = 1 << 4, // 16\n    BeginDrag = 1 << 5, // 32\n    Deselect = 1 << 6, // 64\n    Drag = 1 << 7, // 128\n    Drop = 1 << 8, // 256\n    EndDrag = 1 << 9, // 512\n    InitializePotentialDrag = 1 << 10, // 1024\n    Scroll = 1 << 11, // 2048\n    Select = 1 << 12, // 4096\n    Submit = 1 << 13, // 8192\n    UpdateSelected = 1 << 14, // 16384\n    Move = 1 << 15, // 32768\n    Cancel = 1 << 16 // 65536\n}\n\nexport const AllowedUiInterfaces = new Set([\n    'UnityEngine.EventSystems.IPointerClickHandler',\n    'UnityEngine.EventSystems.IPointerDownHandler',\n    'UnityEngine.EventSystems.IPointerEnterHandler',\n    'UnityEngine.EventSystems.IPointerExitHandler',\n    'UnityEngine.EventSystems.IPointerUpHandler',\n    'UnityEngine.EventSystems.IBeginDragHandler',\n    'UnityEngine.EventSystems.IDeselectHandler',\n    'UnityEngine.EventSystems.IDragHandler',\n    'UnityEngine.EventSystems.IDropHandler',\n    'UnityEngine.EventSystems.IEndDragHandler',\n    'UnityEngine.EventSystems.IInitializePotentialDragHandler',\n    'UnityEngine.EventSystems.IScrollHandler',\n    'UnityEngine.EventSystems.ISelectHandler',\n    'UnityEngine.EventSystems.ISubmitHandler',\n    'UnityEngine.EventSystems.IUpdateSelectedHandler',\n    'UnityEngine.EventSystems.IMoveHandler',\n    'UnityEngine.EventSystems.ICancelHandler',\n]);\n\nexport const UiInterfaceToEnumMap = new Map([\n    ['UnityEngine.EventSystems.IPointerClickHandler', GeniesScriptUiEvents.PointerClick],\n    ['UnityEngine.EventSystems.IPointerDownHandler', GeniesScriptUiEvents.PointerDown],\n    ['UnityEngine.EventSystems.IPointerEnterHandler', GeniesScriptUiEvents.PointerEnter],\n    ['UnityEngine.EventSystems.IPointerExitHandler', GeniesScriptUiEvents.PointerExit],\n    ['UnityEngine.EventSystems.IPointerUpHandler', GeniesScriptUiEvents.PointerUp],\n    ['UnityEngine.EventSystems.IBeginDragHandler', GeniesScriptUiEvents.BeginDrag],\n    ['UnityEngine.EventSystems.IDeselectHandler', GeniesScriptUiEvents.Deselect],\n    ['UnityEngine.EventSystems.IDragHandler', GeniesScriptUiEvents.Drag],\n    ['UnityEngine.EventSystems.IDropHandler', GeniesScriptUiEvents.Drop],\n    ['UnityEngine.EventSystems.IEndDragHandler', GeniesScriptUiEvents.EndDrag],\n    ['UnityEngine.EventSystems.IInitializePotentialDragHandler', GeniesScriptUiEvents.InitializePotentialDrag],\n    ['UnityEngine.EventSystems.IScrollHandler', GeniesScriptUiEvents.Scroll],\n    ['UnityEngine.EventSystems.ISelectHandler', GeniesScriptUiEvents.Select],\n    ['UnityEngine.EventSystems.ISubmitHandler', GeniesScriptUiEvents.Submit],\n    ['UnityEngine.EventSystems.IUpdateSelectedHandler', GeniesScriptUiEvents.UpdateSelected],\n    ['UnityEngine.EventSystems.IMoveHandler', GeniesScriptUiEvents.Move],\n    ['UnityEngine.EventSystems.ICancelHandler', GeniesScriptUiEvents.Cancel],\n]);\n\n\nexport enum GeniesScriptType {\n    None = 0,\n    Monobehaviour = 1,\n    ScriptableObject = 2\n}\n\nexport interface PropertyInfo {\n    Path: string;\n    Name: string;\n    TypeName: string;\n    ChildProperties: PropertyInfo[];\n    IsArray: boolean;\n    IsEnum: boolean;\n    EnumKeys: string[];\n    EnumValues: string[];\n    Decorators: PropertyDecoratorInfo[];\n    IsGeniesBehaviourRef: boolean;\n    IsGeniesScriptableObjectRef: boolean;\n    Initializers: string[];\n    ArrayElementInitializer: PropertyInfo | undefined;\n    ArrayDimension: number;\n}\n\nexport interface PropertyDecoratorInfo {\n    Type: string;\n    Args: string[];\n}\n\nexport interface FileCompileOutput {\n    FilePath: string;\n    IsSuccessful: boolean;\n    Errors?: string[];\n    BaseTypes?: string[];\n    JsSource: string;\n    IsScriptableObj: boolean;\n    IsMonobehaviour: boolean;\n    Properties: PropertyInfo[];\n    Id: string;\n    DefaultTypeName: string;\n    InheritanceChain: string[];\n    SupportedUiEvents: GeniesScriptUiEvents;\n}\n\nexport function extendsMonoBehaviour(classDecl: ClassDeclaration): boolean {\n    let baseClass = classDecl.getBaseClass();\n    while (baseClass) {\n        if (baseClass.getName() === \"MonoBehaviour\") {\n            return true;\n        }\n        baseClass = baseClass.getBaseClass();\n    }\n    return false;\n}\n\nexport function extendsScriptableObject(classDecl: ClassDeclaration): boolean {\n    let baseClass = classDecl.getBaseClass();\n    while (baseClass) {\n        if (baseClass.getName() === \"ScriptableObject\") {\n            return true;\n        }\n        baseClass = baseClass.getBaseClass();\n    }\n    return false;\n}\n\nexport function removeDecorators(decorators: Decorator[], condition: (decorator: Decorator) => boolean) {\n    decorators.forEach(decorator => {\n        if (condition(decorator)) {\n            decorator.remove();\n        }\n    });\n}\n\n/**\n * Traverses the full prototype chain of a class, including base classes and implemented interfaces.\n * @param classDeclaration The ClassDeclaration to traverse.\n * @returns The PrototypeChain containing all base classes and interfaces.\n */\nexport function traversePrototypeChain(classDeclaration: ClassDeclaration): string[] {\n    const resultSet: Set<string> = new Set(); // To store unique type names\n\n    let currentClass: ClassDeclaration | undefined = classDeclaration;\n\n    while (currentClass) {\n        // Add the current class's full type name\n        const classTypeName = getFullTypeName(currentClass.getType());\n        if (classTypeName) {\n            resultSet.add(classTypeName);\n        }\n\n        // Process all implemented interfaces\n        const implementedInterfaces = currentClass.getImplements();\n\n        implementedInterfaces.forEach(implementClause => {\n            const ifaceType = implementClause.getType();\n\n            // Initialize queue with the current interface type\n            const queue: Type[] = [ifaceType];\n\n            while (queue.length > 0) {\n                const currentIfaceType = queue.shift();\n                if (!currentIfaceType) {\n                    continue;\n                }\n\n                const ifaceName = getFullTypeName(currentIfaceType);\n                if (!ifaceName || resultSet.has(ifaceName)) {\n                    continue; // Skip if already processed or name is invalid\n                }\n\n                resultSet.add(ifaceName);\n\n                // Enqueue extended interfaces\n                const baseTypes = currentIfaceType.getBaseTypes();\n                baseTypes.forEach(baseType => {\n                    queue.push(baseType);\n                });\n            }\n        });\n\n        // Move to the base class, if any\n        currentClass = currentClass.getBaseClass();\n    }\n\n    return Array.from(resultSet);\n}\n\nexport function getOperatorMethodName(operatorKind: SyntaxKind): string | undefined {\n    switch (operatorKind) {\n        case SyntaxKind.EqualsEqualsToken:\n            return \"op_Equality\";\n        case SyntaxKind.ExclamationEqualsToken:\n            return \"op_Inequality\";\n        case SyntaxKind.GreaterThanToken:\n            return \"op_GreaterThan\";\n        case SyntaxKind.LessThanToken:\n            return \"op_LessThan\";\n        case SyntaxKind.GreaterThanEqualsToken:\n            return \"op_GreaterThanOrEqual\";\n        case SyntaxKind.LessThanEqualsToken:\n            return \"op_LessThanOrEqual\";\n        case SyntaxKind.AmpersandToken:\n            return \"op_BitwiseAnd\";\n        case SyntaxKind.BarToken:\n            return \"op_BitwiseOr\";\n        case SyntaxKind.PlusToken:\n            return \"op_Addition\";\n        case SyntaxKind.MinusToken:\n            return \"op_Subtraction\";\n        case SyntaxKind.SlashToken:\n            return \"op_Division\";\n        case SyntaxKind.PercentToken:\n            return \"op_Modulus\";\n        case SyntaxKind.AsteriskToken:\n            return \"op_Multiply\";\n        case SyntaxKind.LessThanLessThanToken:\n            return \"op_LeftShift\";\n        case SyntaxKind.GreaterThanGreaterThanToken:\n            return \"op_RightShift\";\n        case SyntaxKind.CaretToken:\n            return \"op_ExclusiveOr\";\n        case SyntaxKind.ExclamationToken:\n            return \"op_LogicalNot\";\n        case SyntaxKind.TildeToken:\n            return \"op_OnesComplement\";\n        case SyntaxKind.PlusPlusToken:\n            return \"op_Increment\";\n        case SyntaxKind.MinusMinusToken:\n            return \"op_Decrement\";\n        default:\n            return undefined;\n    }\n}\n\n\nexport function isSignalBusType(type: Type): boolean {\n    const symbol = type.getSymbol();\n    if (!symbol) return false;\n    const name = symbol.getName();\n    return name === \"SignalBus\";\n}\n\nexport function isGeniesEventType(type: Type): boolean {\n    const symbol = type.getSymbol();\n    if (!symbol) return false;\n    const name = symbol.getName();\n\n    return name === \"GeniesEvent\";\n}\n\n// Modify to return the type if the operator method exists\nexport function getOperatorMethodReturnType(type: Type, operatorMethodName: string, parameterType: Type): Type | null {\n    const typeSymbol = type.getSymbol();\n    if (!typeSymbol) {\n        return null;\n    }\n\n    let leftText = type.getText();\n    let rightText = parameterType.getText();\n\n    const declarations = typeSymbol.getDeclarations();\n    for (const declaration of declarations) {\n        if (Node.isClassDeclaration(declaration)) {\n            const classDeclaration = declaration as ClassDeclaration;\n            const methods = classDeclaration.getMethods().filter(m => m.getName() === operatorMethodName && m.getTypeParameters().length === 0);\n\n            for (const method of methods) {\n                const parameters = method.getParameters();\n                if (parameters.length === 2) {\n                    const leftParameterType = parameters[0].getType();\n                    const rightParameterType = parameters[1].getType();\n                    if (leftParameterType.getText() === leftText && rightParameterType.getText() === rightText) {\n                        return method.getReturnType();\n                    }\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\n\nexport function isOrInheritsFromGameObjectOrComponent(type: Type, transformationContext: TransformationContext): boolean {\n    if (!type) return false;\n\n    const symbol = type.getSymbol();\n    if (!symbol) return false;\n\n    if (['GameObject', 'Component', 'MonoBehaviour'].includes(symbol.getName())) {\n        return true;\n    }\n\n    return inheritsFrom(type, ['GameObject', 'Component', 'MonoBehaviour'], transformationContext);\n}\n\nfunction inheritsFrom(type: Type, baseNames: string[], transformationContext: TransformationContext): boolean {\n    const baseTypes = getBaseTypes(type, transformationContext);\n    for (const baseType of baseTypes) {\n        const baseTypeName = baseType.getSymbol()?.getName();\n        if (baseTypeName && baseNames.includes(baseTypeName)) {\n            return true;\n        }\n        if (inheritsFrom(baseType, baseNames, transformationContext)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction getBaseTypes(type: Type, transformationContext: TransformationContext): Type[] {\n    const baseTypes: Type[] = [];\n    const symbol = type.getSymbol();\n    if (!symbol) return baseTypes;\n\n    const declarations = symbol.getDeclarations();\n    if (!declarations) return baseTypes;\n\n    for (const declaration of declarations) {\n        if (Node.isClassDeclaration(declaration)) {\n            const heritageClauses = declaration.getHeritageClauses();\n            for (const heritageClause of heritageClauses) {\n                const types = heritageClause.getTypeNodes();\n                for (const typeNode of types) {\n                    const baseType = transformationContext.typeChecker.getTypeAtLocation(typeNode);\n                    if (baseType) {\n                        baseTypes.push(baseType);\n                    }\n                }\n            }\n        }\n    }\n    return baseTypes;\n}\n\n// Modify to return the type if the unary operator method exists\nexport function getUnaryOperatorMethodReturnType(type: Type, operatorMethodName: string): Type | null {\n    const typeSymbol = type.getSymbol();\n    if (!typeSymbol) {\n        return null;\n    }\n\n    const declarations = typeSymbol.getDeclarations();\n    for (const declaration of declarations) {\n        if (Node.isClassDeclaration(declaration)) {\n            const classDeclaration = declaration as ClassDeclaration;\n            const methods = classDeclaration.getMethods().filter(m => m.getName() === operatorMethodName && m.getTypeParameters().length === 0);\n\n            for (const method of methods) {\n                const parameters = method.getParameters();\n                if (parameters.length === 1) {\n                    const operandType = parameters[0].getType();\n                    if (operandType.getText() === type.getText()) {\n                        return method.getReturnType();\n                    }\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\nfunction extractEnumDetails(type: Type): {\n    keys: string[];\n    values: (string | number | undefined)[];\n} {\n    const symbol = type.getSymbol();\n    const declaration = symbol?.getDeclarations().find(dec => dec.getKind() === SyntaxKind.EnumDeclaration) as EnumDeclaration;\n    if (declaration) {\n        return {\n            keys: declaration.getMembers().map(member => member.getName()),\n            values: declaration.getMembers().map(member => member.getValue()) // assuming numeric or const enums\n        };\n    }\n    return {keys: [], values: []};\n}\n\nexport function getTypeNameAndEnsureImported(type: Type, sourceFile: SourceFile): string {\n\n    let typeName = type.getText(undefined, TypeFormatFlags.None);\n    let typeModule = \"\";\n\n    if ([\"float\", \"int\", \"double\", \"long\", \"bool\", \"string\", \"number\"].includes(typeName)) {\n        switch (typeName) {\n            case \"int\":\n                typeName = \"Int32\";\n                break;\n            case \"bool\":\n                typeName = \"Boolean\";\n                break;\n            case \"float\":\n                typeName = \"Single\";\n                break;\n            case \"long\":\n                typeName = \"Int64\";\n                break;\n            case \"double\":\n                typeName = \"Double\";\n                break;\n            case \"string\":\n                typeName = \"String\";\n                break;\n            case \"number\":\n                typeName = \"Double\";\n                break;\n        }\n\n        typeModule = \"System\";\n    } else {\n        const scriptType = getGeniesScriptTypeFromType(type);\n        if (scriptType !== GeniesScriptType.None) {\n            switch (scriptType) {\n                case GeniesScriptType.Monobehaviour:\n                    typeName = \"MonoBehaviour\";\n                    typeModule = \"UnityEngine\";\n                    break;\n                case GeniesScriptType.ScriptableObject:\n                    typeName = \"ScriptableObject\";\n                    typeModule = \"UnityEngine\";\n                    break;\n            }\n        } else if (!getIsUnityAPIType(type)) {\n            throw new Error(\"Can't use non CSharp types\");\n        } else {\n            const typeFullyQualifiedName = getFullTypeName(type);\n            const lastDotIndex = typeFullyQualifiedName.lastIndexOf(\".\");\n            typeModule = typeFullyQualifiedName.substring(0, lastDotIndex);\n        }\n    }\n\n    // Check if the type's module is already imported\n    const existingImport = sourceFile.getImportDeclarations().find(importDecl => {\n        return importDecl.getModuleSpecifierValue() === typeModule;\n    });\n\n    if (!existingImport) {\n        // Add the import if it's not already imported\n        const importStructure: ImportDeclarationStructure = {\n            kind: StructureKind.ImportDeclaration,\n            moduleSpecifier: typeModule,\n            namedImports: [{name: typeName}],\n        };\n        sourceFile.addImportDeclaration(importStructure);\n    } else {\n        // If the module is imported but the type is not included, add the named import\n        const namedImports = existingImport.getNamedImports();\n        if (!namedImports.some(namedImport => namedImport.getName() === typeName)) {\n            existingImport.addNamedImport(typeName);\n        }\n    }\n\n    // Return the $typeof conversion string\n    return typeName;\n}\n\nexport function getFullTypeName(type: Type, forCsharp: boolean = true, includeArguments: boolean = true): string {\n    let text = \"\";\n\n    const aliasSymbol = type.getAliasSymbol();\n    if (aliasSymbol) {\n        text = aliasSymbol.getName();\n    } else {\n        text = type.getText();\n    }\n\n    if ([\"float\", \"int\", \"double\", \"long\", \"bool\", \"string\"].includes(text)) {\n        switch (text) {\n            case \"int\":\n                return \"System.Int32\";\n            case \"string\":\n                return \"System.String\";\n            case \"bool\":\n                return \"System.Boolean\";\n            case \"float\":\n                return \"System.Single\";\n            case \"long\":\n                return \"System.Int64\";\n            case \"double\":\n                return \"System.Double\";\n            default:\n                return text;\n        }\n    }\n\n    const symbol = type.getSymbol();\n    if (!symbol) {\n        return text; // Return the simple type text if no symbol is available\n    }\n\n    if (!getIsUnityAPIType(type)) {\n        const declarations = symbol.getDeclarations();\n        let isExported = false;\n\n        declarations.forEach(decl => {\n            if (Node.isInterfaceDeclaration(decl) || Node.isClassDeclaration(decl)) {\n                isExported = decl.isExported();\n            }\n        });\n\n        if (!isExported && declarations.length > 0) {\n            const sourceFile = declarations[0].getSourceFile();\n            const sourceFilePath = sourceFile.getFilePath();\n            const relativePath = convertToAssetsRelativePath(sourceFile.getDirectoryPath(), sourceFilePath);\n            const parsedPath = path.parse(relativePath);\n            const filePathWithoutExt = path.join(parsedPath.dir, parsedPath.name);\n\n            text = `${filePathWithoutExt}.${symbol.getFullyQualifiedName().replace(/['\"]/g, \"\")}`;\n        } else {\n            text = symbol.getFullyQualifiedName().replace(/['\"]/g, \"\");\n        }\n\n        if (text.indexOf(\"Assets/\") >= 0) {\n            text = text.slice(text.indexOf(\"Assets\"));\n        }\n\n        if (text.indexOf(\"PackageCache/\") >= 0) {\n            text = text.slice(text.indexOf(\"PackageCache\")).replace(\"PackageCache\", \"Packages\");\n        }\n\n        if (text.indexOf(\"GeniesSharedPackages/\") >= 0) {\n            text = text.slice(text.indexOf(\"GeniesSharedPackages\")).replace(\"GeniesSharedPackages\", \"Packages\");\n        }\n    } else {\n        text = symbol.getFullyQualifiedName().replace(/['\"]/g, \"\");\n    }\n\n    const regex = /\\$\\d+$/;\n    if (forCsharp && regex.test(text)) {\n\n        text = text.replace(regex, \"\");\n\n        if (includeArguments) {\n            const typeArguments = type.getTypeArguments();\n            if (typeArguments.length > 0) {\n                text += '<';\n                typeArguments.forEach((arg, index) => {\n                    let argText = getFullTypeName(arg);\n                    text += argText;\n                    if (index < typeArguments.length - 1) {\n                        text += ', ';\n                    }\n                });\n                text += '>';\n            }\n        }\n    }\n\n    return text;\n}\n\nexport function extractProperties(cls: ClassDeclaration, basePath: string = '', typeArgumentMap: Map<string, Type> = new Map()): PropertyInfo[] {\n    const properties: PropertyInfo[] = [];\n\n    cls.getProperties().forEach(prop => {\n        const visibility = prop.getScope();\n        const decorators = extractDecorators(prop);\n\n        if (visibility === 'private' && !decorators.some(d => d.Type === SerializeFieldDecorator)) {\n            return;\n        }\n\n        if (visibility === 'public' && decorators.some(d => d.Type === NonSerializedDecorator)) {\n            return;\n        }\n\n        const type = resolveGenericType(prop.getType(), typeArgumentMap);\n        const isArray = type.isArray();\n\n        const resolvedType = resolveArrayElementType(type, typeArgumentMap);\n        const typeName = getFullTypeName(resolvedType);\n        const propName = prop.getName();\n        let fullPath = basePath ? `${basePath}.${propName}` : propName;\n\n        function getInitializer(expression: Expression): string {\n            if (expression.getKind() === SyntaxKind.NewExpression) {\n                const newExpression = expression as NewExpression;\n                const type = newExpression.getType();\n                const fullTypeName = getFullTypeName(type);\n\n                // Extract the arguments of the new expression\n                const args = newExpression.getArguments().map(arg => arg.getText()).join(\", \");\n                return `new ${fullTypeName}(${args});`;\n            } else {\n                return expression.getText();\n            }\n        }\n\n        const initializerExpressions: string[] = [];\n        if (prop.hasInitializer()) {\n            const initializer = prop.getInitializer();\n            if (initializer) {\n                if (initializer.getKind() === SyntaxKind.ArrayLiteralExpression) {\n                    const arrayLiteral = initializer as ArrayLiteralExpression;\n                    for (let i = 0; i < arrayLiteral.getElements().length; i++) {\n                        const element = arrayLiteral.getElements()[i];\n                        initializerExpressions.push(getInitializer(element));\n                    }\n                } else {\n                    initializerExpressions.push(getInitializer(initializer));\n                }\n            }\n        }\n\n        const propertyInfo: PropertyInfo = {\n            Path: fullPath,\n            Name: propName,\n            TypeName: typeName,\n            ChildProperties: [],\n            IsArray: isArray,\n            IsEnum: false,\n            EnumKeys: [],\n            EnumValues: [],\n            Decorators: extractDecorators(prop),\n            IsGeniesBehaviourRef: false,\n            IsGeniesScriptableObjectRef: false,\n            Initializers: initializerExpressions,\n            ArrayElementInitializer: undefined,\n            ArrayDimension: -1,\n        };\n\n        if (isArray) {\n            let dimension = 1;\n            propertyInfo.ArrayElementInitializer = getArrayElementInitializer(type, typeName, propName, fullPath, dimension, typeArgumentMap);\n            propertyInfo.ArrayDimension = dimension;\n            properties.push(propertyInfo);\n            return;\n        }\n\n        fillExtraPropertyInfo(resolvedType, propertyInfo, typeArgumentMap);\n        properties.push(propertyInfo);\n    });\n\n    return properties;\n}\n\nfunction fillExtraPropertyInfo(resolvedType: Type, propertyInfo: PropertyInfo, typeArgumentMap: Map<string, Type>) {\n    const isEnum = resolvedType.isEnum();\n    const symbol = resolvedType.getSymbol() || resolvedType.getAliasSymbol();\n\n    if (!symbol) {\n        return;\n    }\n\n    const declarations = symbol.getDeclarations();\n    const declaration = declarations[0];\n    const isUnityType = getIsUnityAPIDeclaration(declaration);\n    const geniesScriptType = getGeniesScriptTypeFromNode(declaration, isUnityType);\n\n    propertyInfo.IsGeniesBehaviourRef = geniesScriptType == GeniesScriptType.Monobehaviour;\n    propertyInfo.IsGeniesScriptableObjectRef = geniesScriptType == GeniesScriptType.ScriptableObject;\n\n    if (isUnityType || geniesScriptType !== GeniesScriptType.None) {\n        return;\n    }\n\n    if (isEnum) {\n        fillEnumInfo(propertyInfo, resolvedType);\n    }\n\n    if (symbol.getDeclarations().some(declaration => Node.isClassDeclaration(declaration))) {\n        const classDecl = symbol.getDeclarations().find(Node.isClassDeclaration) as ClassDeclaration;\n        const typeParams = classDecl.getTypeParameters();\n        const typeArgs = resolvedType.getTypeArguments();\n        const newTypeArgumentMap = new Map(typeArgumentMap);\n\n        typeParams.forEach((param, index) => {\n            const paramName = param.getName();\n            const uniqueParamName = `${paramName}_${classDecl.getName()}`; // Ensure uniqueness by appending the class name\n            newTypeArgumentMap.set(uniqueParamName, typeArgs[index]);\n        });\n\n        //Collect properties\n        const childProperties: PropertyInfo[] = [];\n        let baseClass = classDecl;\n        while (baseClass) {\n            const baseClassName = baseClass.getName();\n\n            childProperties.unshift(...extractProperties(baseClass, propertyInfo.Path, newTypeArgumentMap));\n\n            let newBase = baseClass.getBaseClass();\n            if (newBase !== undefined) {\n                baseClass = newBase;\n            } else {\n                break;\n            }\n        }\n\n        propertyInfo.ChildProperties = childProperties;\n    }\n}\n\nfunction fillEnumInfo(propertyInfo: PropertyInfo, resolvedType: Type) {\n    const {keys, values} = extractEnumDetails(resolvedType);\n    propertyInfo.EnumKeys = keys;\n    propertyInfo.EnumValues = values.map(value => value === undefined ? \"\" : value.toString());\n    propertyInfo.IsEnum = true;\n}\n\nfunction getArrayElementInitializer(type: Type, underlyingTypeName: string, propName: string, propPath: string, dimension: number, typeArgumentMap: Map<string, Type>): PropertyInfo {\n    let resolvedType = type.isArray() ? type.getArrayElementType()! : type;\n\n    // Ensure proper resolution of generic type arguments and array elements\n    if (!resolvedType.isArray()) {\n        resolvedType = resolveArrayElementType(resolvedType, typeArgumentMap);\n    }\n\n    let currentDimension = dimension;\n\n    const propertyInfo: PropertyInfo = {\n        Path: propPath + \"_D\" + dimension,\n        Name: propName,\n        TypeName: underlyingTypeName,\n        ArrayDimension: dimension,\n        ChildProperties: [],\n        IsArray: resolvedType.isArray(),\n        IsEnum: resolvedType.isEnum(),\n        EnumKeys: [],\n        EnumValues: [],\n        Decorators: [],\n        IsGeniesBehaviourRef: false,\n        IsGeniesScriptableObjectRef: false,\n        Initializers: [],\n        ArrayElementInitializer: undefined\n    };\n\n    if (!resolvedType.isArray()) {\n        fillExtraPropertyInfo(resolvedType, propertyInfo, typeArgumentMap);\n    } else {\n        propertyInfo.ArrayElementInitializer = getArrayElementInitializer(resolvedType, underlyingTypeName, propName, propPath, ++currentDimension, typeArgumentMap);\n    }\n\n    return propertyInfo;\n}\n\nfunction resolveGenericType(type: Type, typeArgumentMap: Map<string, Type>): Type {\n    let resolvedType = type;\n\n    if (resolvedType.isTypeParameter()) {\n        const typeName = resolvedType.getSymbol()?.getName();\n        const parentDecl = resolvedType.getSymbol()?.getDeclarations()[0].getParent();\n        const declaringClassName = parentDecl && Node.isClassDeclaration(parentDecl) ? parentDecl.getName() : '';\n        const uniqueTypeName = `${typeName}_${declaringClassName}`; // Ensure uniqueness by appending the class name\n        if (uniqueTypeName && typeArgumentMap.has(uniqueTypeName)) {\n            resolvedType = typeArgumentMap.get(uniqueTypeName)!;\n        }\n    }\n\n    return resolvedType;\n}\n\nfunction resolveArrayElementType(type: Type, typeArgumentMap: Map<string, Type>): Type {\n    let resolvedType = type;\n\n    while (resolvedType?.isArray()) {\n        resolvedType = resolvedType.getArrayElementType()!;\n    }\n\n    resolvedType = resolveGenericType(resolvedType, typeArgumentMap);\n\n    return resolvedType;\n}\n\nfunction getIsUnityAPISourceFile(sourceFile: SourceFile) {\n    const firstNode = sourceFile.getFirstChild();\n\n    if (!firstNode) {\n        console.log(\"No nodes found in the file.\");\n        return false;\n    }\n\n    const leadingComments = firstNode.getLeadingCommentRanges();\n    return leadingComments.length > 0 && leadingComments[0].getText() === GeniesDeclarationFileAnnotation;\n}\n\nexport function getIsValidUnityGenericTypeArg(argType : Type)\n{\n    let text = \"\";\n\n    const aliasSymbol = argType.getAliasSymbol();\n    if (aliasSymbol) {\n        text = aliasSymbol.getName();\n    } else {\n        text = argType.getText();\n    }\n    \n    if ([\"float\", \"int\", \"double\", \"long\", \"bool\", \"string\", \"number\"].includes(text)) {\n        return true;\n    }\n    \n    const scriptType = getGeniesScriptTypeFromType(argType);\n    if (scriptType !== GeniesScriptType.None) {\n        return true;\n    }\n    \n    return getIsUnityAPIType(argType);\n}\n\nexport function getIsUnityAPIType(type: Type) {\n    const symbol = type.getSymbol();\n\n    if (!symbol) {\n        return;\n    }\n\n    const sourceFile = symbol.getDeclarations()[0].getSourceFile();\n\n    return getIsUnityAPISourceFile(sourceFile);\n}\n\nexport function getIsUnityAPIDeclaration(declaration: Node): boolean {\n    const sourceFile = declaration.getSourceFile();\n    return getIsUnityAPISourceFile(sourceFile);\n}\n\nfunction getGeniesScriptTypeFromNode(declaration: Node, isUnityType: boolean): GeniesScriptType {\n    if (declaration.getKind() !== SyntaxKind.ClassDeclaration || isUnityType) {\n        return GeniesScriptType.None;\n    }\n\n    const cls = declaration as ClassDeclaration;\n    const isMonobehaviour = extendsMonoBehaviour(cls);\n    const isScriptableObject = extendsScriptableObject(cls);\n\n    if (isMonobehaviour) {\n        return GeniesScriptType.Monobehaviour;\n    }\n\n    if (isScriptableObject) {\n        return GeniesScriptType.ScriptableObject;\n    }\n\n    return GeniesScriptType.None;\n}\n\nexport function getGeniesScriptTypeFromType(type: Type): GeniesScriptType {\n    const symbol = type.getSymbol();\n\n    if (!symbol) {\n        return GeniesScriptType.None;\n    }\n\n    const declarations = symbol.getDeclarations();\n    if (declarations.length === 0) {\n        return GeniesScriptType.None;\n    }\n\n    const declaration = declarations[0];\n    const isUnityType = getIsUnityAPIDeclaration(declaration)\n    return getGeniesScriptTypeFromNode(declaration, isUnityType);\n}\n\nexport function isGeniesScriptType(type: Type): boolean {\n    let gType = getGeniesScriptTypeFromType(type);\n    return gType === GeniesScriptType.Monobehaviour || gType === GeniesScriptType.ScriptableObject;\n}\n\n/*\n* This ensures that specifiers match the keys/paths of the files in Unity.\n*/\nexport function updateImportsToRelativePaths(sourceFile: SourceFile) {\n    const directoryPath = sourceFile.getDirectoryPath();\n\n    // Ensure the path is always resolved to be the Assets/ name\n    sourceFile.getImportDeclarations().forEach(importDeclaration => {\n        const moduleSpecifier = importDeclaration.getModuleSpecifierValue();\n\n        // Check if the import path is relative\n        if (moduleSpecifier.startsWith('./') || moduleSpecifier.startsWith('../')) {\n            // Convert the relative path to an Assets-relative path\n            const relativePath = convertToAssetsRelativePath(directoryPath, moduleSpecifier);\n\n            // Update the module specifier\n            importDeclaration.setModuleSpecifier(relativePath);\n        }\n    });\n}\n\nexport function convertToAssetsRelativePath(basePath: string, relativePath: string): string {\n    const absolutePath = path.resolve(basePath, relativePath);\n    const assetsPath = path.resolve('Assets');\n\n    // Get the path relative to the Assets directory\n    let relativeToAssets = path.relative(assetsPath, absolutePath);\n\n    // Prepend 'Assets/' to ensure the path starts with 'Assets'\n    if (!relativeToAssets.startsWith('Assets' + path.sep)) {\n        relativeToAssets = path.join('Assets', relativeToAssets);\n    }\n\n    // Normalize the path to use forward slashes\n    return normalizePath(relativeToAssets);\n}\n\nfunction normalizePath(p: string): string {\n    return p.split(path.sep).join('/');\n}\n\nfunction extractDecorators(prop: PropertyDeclaration): PropertyDecoratorInfo[] {\n    return prop.getDecorators().map(d => {\n        const decoratorInfo: PropertyDecoratorInfo = {\n            Type: d.getName(),\n            Args: d.getArguments().map(a => a.getText())\n        };\n        return decoratorInfo;\n    });\n}\n","import {\n    SourceFile,\n    Node,\n    SyntaxKind,\n    CallExpression,\n    MethodDeclaration,\n    Type,\n    ClassDeclaration,\n    NewExpression,\n    TypeReferenceNode,\n    Identifier,\n    PropertyAccessExpression,\n    ElementAccessExpression,\n    InterfaceDeclaration, MethodSignature, TypeChecker\n} from \"ts-morph\";\nimport ts from \"typescript/lib/tsserverlibrary\";\nimport {\n    getIsUnityAPIType,\n    getIsUnityAPIDeclaration,\n    getGeniesScriptTypeFromType,\n    GeniesScriptType, getFullTypeName, AllowedUiInterfaces, getIsValidUnityGenericTypeArg, GET_ITEM_NAME, SET_ITEM_NAME\n} from \"./CompilerUtils\";\n\nconst CUSTOM_DIAGNOSTIC_CODES = {\n    INVALID_INHERITANCE: 10001,\n    FORBIDDEN_INTERFACE: 10002,\n    GENERIC_METHOD_MISSING_TYPE_ARGUMENTS: 10003,\n    GENERIC_METHOD_INVALID_TYPE_ARGUMENTS: 10004,\n    GENERIC_CLASS_MISSING_TYPE_ARGUMENTS: 10005,\n    GENERIC_CLASS_INVALID_TYPE_ARGUMENTS: 10006,\n    INVALID_GET_ITEM_ARGUMENTS: 10007,\n};\n\nconst ALLOWED_INHERITANCE_TYPES = new Set(['MonoBehaviour', 'ScriptableObject']);\n\nconst COMPONENT_METHODS = new Set([\n    'GetComponent',\n    'TryGetComponent',\n    'GetComponentInChildren',\n    'GetComponentsInChildren',\n    'GetComponentInParent',\n    'GetComponentsInParent',\n    'GetComponents',\n    'AddComponent',\n]);\n\n\nexport function getGeniesSemanticDiagnostics(file: SourceFile, typeChecker: TypeChecker): ts.Diagnostic[] {\n    if (!file) {\n        return [];\n    }\n\n    const diagnostics: ts.Diagnostic[] = [];\n\n    processClassDiagnostics(file, diagnostics);\n    processCallExpressionDiagnostics(file, diagnostics);\n    processTypeUsageDiagnostics(file, diagnostics);\n    \n    //TODO improve diagnostics for bracket access\n    //processBracketAccessDiagnostics(file, typeChecker, diagnostics);\n\n    return diagnostics;\n}\n\n//TODO improve diagnostics for bracket access\n// function processBracketAccessDiagnostics(file: SourceFile, typeChecker: TypeChecker, diagnostics: ts.Diagnostic[]) {\n//\n//     let expressions = file.getDescendantsOfKind(SyntaxKind.ElementAccessExpression);\n//\n//     if (expressions.length === 0) {\n//         return;\n//     }\n//\n//     expressions.forEach(node => {\n//         const elementAccess = node as ElementAccessExpression;\n//         const expression = elementAccess.getExpression();\n//         const argumentExpression = elementAccess.getArgumentExpression();\n//\n//         if (!argumentExpression) {\n//             // If there's no argument (e.g., obj[]), skip transformation\n//             return node;\n//         }\n//\n//         const type = expression.getType();\n//\n//         // Check if the type is a Unity API type\n//         if (!getIsUnityAPIType(type)) {\n//             return node;\n//         }\n//\n//         // Retrieve the symbol of the type\n//         const typeSymbol = type.getSymbol();\n//         if (!typeSymbol) {\n//             return;\n//         }\n//\n//         // Get all declarations (classes and interfaces) associated with the type\n//         const declarations = typeSymbol.getDeclarations().filter(\n//             decl => Node.isClassDeclaration(decl) || Node.isInterfaceDeclaration(decl)\n//         ) as (ClassDeclaration | InterfaceDeclaration)[];\n//\n//         if (declarations.length === 0) {\n//             return;\n//         }\n//\n//         // Collect all unique get_item and set_item methods across all declarations\n//         const getItemMethods: (MethodDeclaration | MethodSignature)[] = [];\n//         const setItemMethods: (MethodDeclaration | MethodSignature)[] = [];\n//\n//         const methodSignatures = new Set<string>();\n//\n//         declarations.forEach(decl => {\n//             const classOrInterface = decl as ClassDeclaration | InterfaceDeclaration;\n//\n//             // getMethods returns an array of MethodDeclaration or MethodSignature\n//             const methods = classOrInterface.getMethods();\n//\n//             methods.forEach(method => {\n//                 const methodName = method.getName();\n//                 if (methodName === GET_ITEM_NAME || methodName === SET_ITEM_NAME) {\n//                     // Generate a unique signature string for the method\n//                     const signature = method.getSignature().getDeclaration()?.getText();\n//                     if (signature && !methodSignatures.has(signature)) {\n//                         if (methodName === GET_ITEM_NAME) {\n//                             getItemMethods.push(method);\n//                         } else {\n//                             setItemMethods.push(method);\n//                         }\n//                         methodSignatures.add(signature);\n//                     }\n//                 }\n//             });\n//         });\n//\n//         if (getItemMethods.length === 0 && setItemMethods.length === 0) {\n//             return;\n//         }\n//\n//         const parent = elementAccess.getParent();\n//\n//         // Determine if this is a getter or setter\n//         if (\n//             Node.isBinaryExpression(parent) &&\n//             parent.getOperatorToken().getKind() === SyntaxKind.EqualsToken &&\n//             parent.getLeft() === elementAccess\n//         ) {\n//             // This is a setter: obj[index] = value\n//             if (setItemMethods.length === 0) {\n//                 return;\n//             }\n//\n//             const valueExpression = parent.getRight();\n//\n//             // Attempt to find a matching set_item method\n//             const matchingSetItem = setItemMethods.find(method => {\n//                 const params = method.getParameters();\n//                 if (params.length !== 2) {\n//                     return false;\n//                 }\n//\n//                 const indexParamType = params[0].getType();\n//                 const valueParamType = params[1].getType();\n//\n//                 const indexArgType = argumentExpression.getType();\n//                 const valueArgType = valueExpression.getType();\n//\n//                 return (\n//                     typeChecker.isTypeAssignableTo(indexArgType, indexParamType) &&\n//                     typeChecker.isTypeAssignableTo(valueArgType, valueParamType)\n//                 );\n//             });\n//\n//             if (!matchingSetItem) {\n//                 addDiagnostic(\n//                     diagnostics,\n//                     node,\n//                     `Invalid Assignment`,\n//                     CUSTOM_DIAGNOSTIC_CODES.INVALID_GET_ITEM_ARGUMENTS);\n//             }\n//         } else {\n//             // This is a getter: obj[index]\n//             if (getItemMethods.length === 0) {\n//                 return node;\n//             }\n//\n//             // Attempt to find a matching get_item method\n//             const matchingGetItem = getItemMethods.find(method => {\n//                 const params = method.getParameters();\n//                 if (params.length !== 1) {\n//                     return false;\n//                 }\n//\n//                 const indexParamType = params[0].getType();\n//                 const indexArgType = argumentExpression.getType();\n//\n//                 return typeChecker.isTypeAssignableTo(indexArgType, indexParamType);\n//             });\n//\n//             let validParams = getItemMethods.flatMap(g => g.getParameters().map(p => getFullTypeName(p.getType())));\n//\n//             if (!matchingGetItem) {\n//                 addDiagnostic(\n//                     diagnostics,\n//                     node,\n//                     `Invalid access, accepted types are '${validParams.join(\",\")}'`,\n//                     CUSTOM_DIAGNOSTIC_CODES.INVALID_GET_ITEM_ARGUMENTS);\n//             }\n//         }\n//     });\n// }\n\nfunction processClassDiagnostics(file: SourceFile, diagnostics: ts.Diagnostic[]) {\n    const geniesClasses = file.getClasses();\n\n    geniesClasses.forEach(cls => {\n        const baseClass = cls.getBaseClass();\n        const implementedInterfaces = cls.getImplements();\n        const baseClassName = baseClass?.getName();\n\n        if (baseClass && getIsUnityAPIType(baseClass.getType()) && baseClassName && !ALLOWED_INHERITANCE_TYPES.has(baseClassName)) {\n            const start = baseClass.getStart();\n            const length = baseClass.getWidth();\n\n            const diagnosticMessage = `Class '${cls.getName()}' inherits from a Unity type '${baseClass.getName()}' that is not 'MonoBehaviour' or 'ScriptableObject'.`;\n            const diagnostic: ts.Diagnostic = {\n                file: file.compilerNode,\n                start: start,\n                length: length,\n                messageText: diagnosticMessage,\n                category: ts.DiagnosticCategory.Error,\n                code: CUSTOM_DIAGNOSTIC_CODES.INVALID_INHERITANCE,\n                source: 'Genies',\n            };\n            diagnostics.push(diagnostic);\n        }\n\n        implementedInterfaces.forEach(intf => {\n            if (getIsUnityAPIType(intf.getType())) {\n\n                const typeName = getFullTypeName(intf.getType());\n                if (AllowedUiInterfaces.has(typeName)) {\n                    return;\n                }\n\n                const start = intf.getStart();\n                const length = intf.getWidth();\n\n                const diagnosticMessage = `Class '${cls.getName()}' implements a forbidden Unity interface '${intf.getText()}'.`;\n                const diagnostic: ts.Diagnostic = {\n                    file: file.compilerNode,\n                    start: start,\n                    length: length,\n                    messageText: diagnosticMessage,\n                    category: ts.DiagnosticCategory.Error,\n                    code: CUSTOM_DIAGNOSTIC_CODES.FORBIDDEN_INTERFACE,\n                    source: 'Genies',\n                };\n                diagnostics.push(diagnostic);\n            }\n        });\n    });\n}\n\nfunction processTypeUsageDiagnostics(file: SourceFile, diagnostics: ts.Diagnostic[]) {\n    // Gather all NewExpression and TypeReferenceNode instances\n    const newExpressions = file.getDescendantsOfKind(SyntaxKind.NewExpression);\n\n    // Process NewExpression nodes\n    newExpressions.forEach(newExpr => {\n        // Resolve the symbol of the class being instantiated\n        const typeSymbol = newExpr.getType().getSymbol();\n\n        if (!typeSymbol) {\n            return;\n        }\n\n        // Retrieve all declarations of the symbol\n        const declarations = typeSymbol.getDeclarations();\n\n        if (!declarations || declarations.length === 0) {\n            return;\n        }\n\n        // Filter for class declarations with type parameters (i.e., generic classes)\n        const classDeclarations = declarations.filter(decl =>\n            Node.isClassDeclaration(decl) && getIsUnityAPIDeclaration(decl) && decl.getTypeParameters().length > 0\n        ) as ClassDeclaration[];\n\n        if (classDeclarations.length === 0) {\n            return; // Not a generic class\n        }\n\n        const classDeclaration = classDeclarations[0];\n        const typeParams = classDeclaration.getTypeParameters();\n        const expectedTypeArgsCount = typeParams.length;\n\n        // Retrieve provided type arguments from the NewExpression\n        const typeArgs = newExpr.getTypeArguments();\n        const providedTypeArgsCount = typeArgs.length;\n\n        if (providedTypeArgsCount === 0) {\n            // Generic class used without type arguments\n            addDiagnostic(\n                diagnostics,\n                newExpr,\n                `Generic class '${getFullTypeName(newExpr.getType())}' must be instantiated with ${expectedTypeArgsCount} type argument(s).`,\n                CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_MISSING_TYPE_ARGUMENTS\n            );\n        } else {\n            if (providedTypeArgsCount !== expectedTypeArgsCount) {\n                // Incorrect number of type arguments provided\n                addDiagnostic(\n                    diagnostics,\n                    newExpr,\n                    `Generic class '${getFullTypeName(newExpr.getType())}' expects ${expectedTypeArgsCount} type argument(s), but got ${providedTypeArgsCount}.`,\n                    CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_INVALID_TYPE_ARGUMENTS\n                );\n            }\n\n            //Invalid args\n            typeArgs.forEach(typeArgNode => {\n                const typeArgType = typeArgNode.getType();\n                if (!getIsValidUnityGenericTypeArg(typeArgType)) {\n                    addDiagnostic(\n                        diagnostics,\n                        typeArgNode,\n                        `Type arguments for type '${getFullTypeName(newExpr.getType())}' must be Unity API types.`,\n                        CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_INVALID_TYPE_ARGUMENTS\n                    );\n                }\n            });\n\n        }\n    });\n}\n\n\nfunction processCallExpressionDiagnostics(file: SourceFile, diagnostics: ts.Diagnostic[]) {\n    const callExpressions = file.getDescendantsOfKind(SyntaxKind.CallExpression);\n\n    callExpressions.forEach(callExpr => {\n        processGenericMethodCall(callExpr, diagnostics);\n    });\n}\n\nfunction processGenericMethodCall(callExpr: CallExpression, diagnostics: ts.Diagnostic[]) {\n    const expression = callExpr.getExpression();\n\n    // Get the method symbol and all declarations\n    let methodDeclarations: MethodDeclaration[] = [];\n\n    if (Node.isPropertyAccessExpression(expression) || Node.isIdentifier(expression)) {\n        const methodSymbol = expression.getSymbol();\n        if (methodSymbol) {\n            const declarations = methodSymbol.getDeclarations();\n            methodDeclarations = declarations.filter(decl => Node.isMethodDeclaration(decl)) as MethodDeclaration[];\n        }\n    }\n\n    if (methodDeclarations.length === 0) {\n        return; // Cannot proceed without method declarations\n    }\n\n    let isGenericMethodDeclaration = methodDeclarations.filter(decl => {\n        return decl.getTypeParameters().length > 0\n    }).length > 0;\n\n    if (!isGenericMethodDeclaration) {\n        return;\n    }\n\n    // Filter to Unity API methods\n    methodDeclarations = methodDeclarations.filter(decl => getIsUnityAPIDeclaration(decl));\n\n    if (methodDeclarations.length === 0) {\n        return; // No Unity API methods\n    }\n\n    const methodName = getMethodName(expression);\n\n    // Check for non-generic overloads that accept the same parameters\n    if (hasMatchingNonGenericOverload(methodDeclarations, callExpr)) {\n        return; // Skip the check since a non-generic overload exists\n    }\n\n    // Now, ensure that the call provides type arguments\n    const typeArgs = callExpr.getTypeArguments();\n\n    if (typeArgs.length === 0) {\n        // Generic method called without specifying type arguments\n        addDiagnostic(\n            diagnostics,\n            callExpr,\n            `Generic method '${methodName}' must be called with type arguments.`,\n            CUSTOM_DIAGNOSTIC_CODES.GENERIC_METHOD_MISSING_TYPE_ARGUMENTS\n        );\n        return;\n    }\n\n    let validArgs = methodDeclarations.map(m => m.getTypeParameters().length);\n    if (!validArgs.includes(typeArgs.length)) {\n        // Incorrect number of type arguments provided\n        addDiagnostic(\n            diagnostics,\n            callExpr,\n            `Generic method '${methodName}' was provided the wrong number of arguments. Valid args counts: '${validArgs.join(\", \")}'`,\n            CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_INVALID_TYPE_ARGUMENTS\n        );\n    }\n\n    // Validate type arguments\n    if (COMPONENT_METHODS.has(methodName)) {\n        // Apply GetComponent rules\n        typeArgs.forEach(typeArgNode => {\n            if (!isValidComponentTypeArg(typeArgNode)) {\n                addDiagnostic(\n                    diagnostics,\n                    typeArgNode,\n                    `Type arguments for method '${methodName}' must be a Unity API type, an interface, or a type that extends MonoBehaviour.`,\n                    CUSTOM_DIAGNOSTIC_CODES.GENERIC_METHOD_INVALID_TYPE_ARGUMENTS\n                );\n            }\n        });\n    } else {\n        // For other methods, type arguments must be Unity API types\n        typeArgs.forEach(typeArgNode => {\n            const typeArgType = typeArgNode.getType();\n            if (!getIsValidUnityGenericTypeArg(typeArgType)) {\n                addDiagnostic(\n                    diagnostics,\n                    typeArgNode,\n                    `Type arguments for method '${methodName}' must be Unity API types.`,\n                    CUSTOM_DIAGNOSTIC_CODES.GENERIC_METHOD_INVALID_TYPE_ARGUMENTS\n                );\n            }\n        });\n    }\n}\n\nfunction hasMatchingNonGenericOverload(\n    methodDeclarations: MethodDeclaration[],\n    callExpr: CallExpression\n): boolean {\n    const callArgTypes = callExpr.getArguments().map(arg => arg.getType());\n    const typeChecker = callExpr.getProject().getTypeChecker();\n\n    return methodDeclarations.some(decl => {\n        if (decl.getTypeParameters().length > 0) {\n            return false; // It's a generic method\n        }\n\n        const parameters = decl.getParameters();\n        if (parameters.length !== callArgTypes.length) {\n            return false;\n        }\n\n        // Compare parameter types\n        for (let i = 0; i < parameters.length; i++) {\n            const paramType = parameters[i].getType();\n            const argType = callArgTypes[i];\n\n            if (!typeChecker.isTypeAssignableTo(argType, paramType)) {\n                return false;\n            }\n        }\n\n        return true; // Found a matching non-generic overload\n    });\n}\n\nfunction isValidComponentTypeArg(typeArgNode: Node): boolean {\n    const typeArgType = typeArgNode.getType();\n\n    if (getIsUnityAPIType(typeArgType)) {\n        // It's a Unity API type, acceptable\n        return true;\n    }\n\n    const geniesScriptType = getGeniesScriptTypeFromType(typeArgType);\n    if (geniesScriptType === GeniesScriptType.Monobehaviour) {\n        // It's a MonoBehaviour, acceptable\n        return true;\n    }\n\n    const symbol = typeArgType.getSymbol();\n    if (symbol) {\n        const declarations = symbol.getDeclarations();\n        if (declarations && declarations.length > 0) {\n            if (Node.isInterfaceDeclaration(declarations[0])) {\n                // It's an interface, acceptable\n                return true;\n            }\n        }\n    }\n\n    return false; // Invalid type argument\n}\n\nfunction getMethodName(expression: Node): string {\n    if (Node.isPropertyAccessExpression(expression)) {\n        return expression.getName();\n    } else if (Node.isIdentifier(expression)) {\n        return expression.getText();\n    } else {\n        return ''; // Unknown\n    }\n}\n\nfunction addDiagnostic(\n    diagnostics: ts.Diagnostic[],\n    node: Node,\n    messageText: string,\n    code: number\n) {\n    const start = node.getStart();\n    const length = node.getWidth();\n    const diagnostic: ts.Diagnostic = {\n        file: node.getSourceFile().compilerNode,\n        start: start,\n        length: length,\n        messageText: messageText,\n        category: ts.DiagnosticCategory.Error,\n        code: code,\n        source: 'Genies',\n    };\n    diagnostics.push(diagnostic);\n}\n","import {LanguageService} from \"typescript\";\nimport {ILanguageServiceFeature} from \"./ILanguageServiceFeature\";\nimport {Node, Project, SourceFile, SyntaxKind, Type} from \"ts-morph\";\nimport {getOperatorMethodName, getOperatorMethodReturnType, getUnaryOperatorMethodReturnType} from \"../CompilerUtils\";\nimport ts from \"typescript/lib/tsserverlibrary\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\n\ntype getSemanticDiagnostics = (fileName: string) => ts.Diagnostic[];\n\nexport class CSharpOperatorOverloadingSuppress implements ILanguageServiceFeature {\n    private cache: Map<Node, Type | undefined> = new Map<Node, Type | undefined>();\n    private expressionValidity = new Map<number, { start: number, end: number, valid: boolean }>();\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: LanguageService): void {\n        const originalGetSemanticDiagnostics = proxy.getSemanticDiagnostics;\n        proxy.getSemanticDiagnostics = (fileName: string): ts.Diagnostic[] => {\n            return this.getSemanticDiagnostics(originalGetSemanticDiagnostics, fileName);\n        };\n    }\n\n    getSemanticDiagnostics(previousGetter: getSemanticDiagnostics, fileName: string): ts.Diagnostic[] {\n        const priorDiagnostics = previousGetter(fileName);\n        let sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return priorDiagnostics;\n        }\n\n        // Collect all expressions and their validity\n        this.collectExpressions(sourceFile);\n\n        let diagnostics = priorDiagnostics.filter(diagnostic => {\n            const start = diagnostic.start ?? 0;\n            const end = (diagnostic.start ?? 0) + (diagnostic.length ?? 0);\n\n            // Check if the diagnostic range falls within any valid expression\n            for (const {start: exprStart, end: exprEnd, valid} of this.expressionValidity.values()) {\n                if ((start >= exprStart || end <= exprEnd) && valid) {\n                    return false;\n                }\n            }\n            return true;\n        });\n\n        this.expressionValidity?.clear();\n        this.cache?.clear();\n        return diagnostics;\n    }\n\n    collectExpressions(sourceFile: SourceFile) {\n        const binaryExpressions = sourceFile!.getDescendantsOfKind(SyntaxKind.BinaryExpression);\n        const prefixUnaryExpressions = sourceFile!.getDescendantsOfKind(SyntaxKind.PrefixUnaryExpression);\n        const postfixUnaryExpressions = sourceFile!.getDescendantsOfKind(SyntaxKind.PostfixUnaryExpression);\n        const compoundAssignments = sourceFile!.getDescendantsOfKind(SyntaxKind.BinaryExpression).filter(node => {\n            const kind = node.getOperatorToken().getKind();\n            return kind >= SyntaxKind.FirstCompoundAssignment && kind <= SyntaxKind.LastCompoundAssignment;\n        });\n\n        const processNode = (node: Node) => {\n            const start = node.getStart();\n            if (this.expressionValidity.has(start)) {\n                return;\n            }\n\n            const finalType = this.getFinalType(node);\n            const end = node.getEnd();\n            const valid = finalType !== undefined;\n            this.expressionValidity.set(start, {start, end, valid});\n        };\n\n        binaryExpressions.forEach(processNode);\n        prefixUnaryExpressions.forEach(processNode);\n        postfixUnaryExpressions.forEach(processNode);\n        compoundAssignments.forEach(processNode);\n    }\n\n    getFinalType(node: Node): Type | undefined {\n        if (this.cache.has(node)) {\n            return this.cache.get(node);\n        }\n\n        let finalType: Type | undefined;\n\n        if (Node.isBinaryExpression(node)) {\n            const operatorTokenKind = node.getOperatorToken().getKind();\n            const leftNode = node.getLeft();\n            const rightNode = node.getRight();\n            const leftType = this.getFinalType(leftNode);\n            const rightType = this.getFinalType(rightNode);\n            const methodName = getOperatorMethodName(operatorTokenKind);\n\n            if (methodName && leftType && rightType) {\n                const leftReturnType = getOperatorMethodReturnType(leftType, methodName, rightType);\n                const rightReturnType = getOperatorMethodReturnType(rightType, methodName, leftType);\n\n                if (leftReturnType) {\n                    finalType = leftReturnType;\n                } else if (rightReturnType) {\n                    finalType = rightReturnType;\n                } else {\n                    finalType = undefined;\n                }\n            } else {\n                finalType = undefined;\n            }\n\n        } else if (Node.isPrefixUnaryExpression(node) || Node.isPostfixUnaryExpression(node)) {\n            const operand = node.getOperand();\n            const operatorKind = node.getOperatorToken();\n            const operatorMethodName = getOperatorMethodName(operatorKind);\n            const operandType = this.context.TypeChecker.getTypeAtLocation(operand);\n\n            if (operatorMethodName) {\n                const operandReturnType = getUnaryOperatorMethodReturnType(operandType, operatorMethodName);\n                if (operandReturnType) {\n                    finalType = operandReturnType;\n                } else {\n                    finalType = undefined;\n                }\n            } else {\n                finalType = undefined;\n            }\n\n        } else {\n            finalType = this.context.TypeChecker.getTypeAtLocation(node);\n            if (finalType?.isLiteral()) {\n                finalType = this.context.TypeChecker.getBaseTypeOfLiteralType(finalType);\n            }\n        }\n\n        this.cache.set(node, finalType);\n        return finalType;\n    }\n}\n\n\n\n","import ts from 'typescript/lib/tsserverlibrary';\nimport { ILanguageServiceFeature } from './ILanguageServiceFeature';\nimport { GeniesLSPContext } from \"./GeniesLSPContext\";\nimport {getGeniesSemanticDiagnostics} from \"../GeniesDiagnosticsUtils\";\n\nexport class GeniesSemanticDiagnostics implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetSemanticDiagnostics = proxy.getSemanticDiagnostics;\n        proxy.getSemanticDiagnostics = (fileName: string): ts.Diagnostic[] => {\n            let diagnostics = originalGetSemanticDiagnostics(fileName);\n            diagnostics = this.getGeniesSemanticDiagnostics(diagnostics, fileName);\n            return diagnostics;\n        };\n    }\n\n    private getGeniesSemanticDiagnostics(existingDiagnostics: ts.Diagnostic[], fileName: string): ts.Diagnostic[] {\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return existingDiagnostics;\n        }\n\n        // Clear existing diagnostics to prevent duplicate additions\n        const newDiagnostics: ts.Diagnostic[] = getGeniesSemanticDiagnostics(sourceFile, this.context.TypeChecker);\n        \n        // Remove previous diagnostics that share the same message and range\n        const uniqueExistingDiagnostics = existingDiagnostics.filter(existingDiag =>\n            !newDiagnostics.some(newDiag =>\n                newDiag.messageText === existingDiag.messageText &&\n                newDiag.start === existingDiag.start &&\n                newDiag.length === existingDiag.length\n            )\n        );\n\n        return [...uniqueExistingDiagnostics, ...newDiagnostics];\n    }\n}\n","import ts from \"typescript/lib/tsserverlibrary\";\nimport {Project, SourceFile, TypeChecker} from \"ts-morph\";\n\nexport class GeniesLSPContext {\n    private readonly project: Project;\n    private readonly info: ts.server.PluginCreateInfo;\n\n    constructor(project: Project, info: ts.server.PluginCreateInfo) {\n        this.project = project;\n        this.info = info;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.info.project.projectService.logger;\n    }\n    \n    get TypeChecker() : TypeChecker\n    {\n        return this.project.getTypeChecker();\n    }\n    \n    getSourceFile(fileName: string): SourceFile | undefined {\n        let sourceFile = this.project.getSourceFile(fileName);\n        if (!sourceFile) {\n            sourceFile = this.project.addSourceFileAtPath(fileName);\n            \n            if(!sourceFile)\n            {\n                this.Logger.info(\"Source file not found.\");\n                return undefined;\n            }\n        }\n        \n        const snapshot = this.getInMemoryFileContent(fileName, this.info.languageServiceHost);\n        if(snapshot)\n        {\n            sourceFile.replaceWithText(snapshot);\n        }\n        \n        return sourceFile;\n    }\n    \n    private getInMemoryFileContent(fileName: string, languageService: ts.LanguageServiceHost): string | undefined {\n        const scriptSnapshot = languageService.getScriptSnapshot(fileName);\n        return scriptSnapshot ? scriptSnapshot.getText(0, scriptSnapshot.getLength()) : undefined;\n    }\n\n}\n\n","\n// Unity lifecycle methods\nexport const unityLifecycleMethods = [\n    { name: \"Awake\", parameters: \"\", description: \"Called when the script instance is being loaded.\", imports: [] },\n    { name: \"Start\", parameters: \"\", description: \"Called before the first frame update.\", imports: [] },\n    { name: \"OnEnable\", parameters: \"\", description: \"Called when the object becomes enabled and active.\", imports: [] },\n    { name: \"OnDisable\", parameters: \"\", description: \"Called when the object becomes disabled.\", imports: [] },\n    { name: \"OnDestroy\", parameters: \"\", description: \"Called when the MonoBehaviour will be destroyed.\", imports: [] },\n    { name: \"Update\", parameters: \"\", description: \"Called once per frame.\", imports: [] },\n    { name: \"FixedUpdate\", parameters: \"\", description: \"Called every fixed frame-rate frame.\", imports: [] },\n    { name: \"LateUpdate\", parameters: \"\", description: \"Called once per frame after Update.\", imports: [] },\n    { name: \"OnCollisionEnter\", parameters: \"collision: Collision\", description: \"Called when this collider/rigidbody has begun touching another rigidbody/collider.\", imports: [{ type: \"Collision\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionExit\", parameters: \"collision: Collision\", description: \"Called when this collider/rigidbody has stopped touching another rigidbody/collider.\", imports: [{ type: \"Collision\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionStay\", parameters: \"collision: Collision\", description: \"Called once per frame for every collider/rigidbody that is touching rigidbody/collider.\", imports: [{ type: \"Collision\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionEnter2D\", parameters: \"collision: Collision2D\", description: \"Called when this collider/rigidbody has begun touching another rigidbody/collider in 2D.\", imports: [{ type: \"Collision2D\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionExit2D\", parameters: \"collision: Collision2D\", description: \"Called when this collider/rigidbody has stopped touching another rigidbody/collider in 2D.\", imports: [{ type: \"Collision2D\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionStay2D\", parameters: \"collision: Collision2D\", description: \"Called once per frame for every collider/rigidbody that is touching rigidbody/collider in 2D.\", imports: [{ type: \"Collision2D\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerEnter\", parameters: \"other: Collider\", description: \"Called when the Collider other enters the trigger.\", imports: [{ type: \"Collider\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerExit\", parameters: \"other: Collider\", description: \"Called when the Collider other has stopped touching the trigger.\", imports: [{ type: \"Collider\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerStay\", parameters: \"other: Collider\", description: \"Called once per frame for every Collider other that is touching the trigger.\", imports: [{ type: \"Collider\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerEnter2D\", parameters: \"other: Collider2D\", description: \"Called when the Collider other enters the trigger in 2D.\", imports: [{ type: \"Collider2D\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerExit2D\", parameters: \"other: Collider2D\", description: \"Called when the Collider other has stopped touching the trigger in 2D.\", imports: [{ type: \"Collider2D\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerStay2D\", parameters: \"other: Collider2D\", description: \"Called once per frame for every Collider other that is touching the trigger in 2D.\", imports: [{ type: \"Collider2D\", module: \"UnityEngine\" }] },\n    { name: \"OnControllerColliderHit\", parameters: \"hit: ControllerColliderHit\", description: \"Called when the character controller hits a collider while performing a move.\", imports: [{ type: \"ControllerColliderHit\", module: \"UnityEngine\" }] },\n    { name: \"OnGUI\", parameters: \"\", description: \"Called for rendering and handling GUI events.\", imports: [] },\n    { name: \"OnMouseDown\", parameters: \"\", description: \"Called when the user has pressed the mouse button while over the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseDrag\", parameters: \"\", description: \"Called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.\", imports: [] },\n    { name: \"OnMouseUp\", parameters: \"\", description: \"Called when the user has released the mouse button.\", imports: [] },\n    { name: \"OnMouseEnter\", parameters: \"\", description: \"Called when the mouse enters the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseExit\", parameters: \"\", description: \"Called when the mouse is not any longer over the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseOver\", parameters: \"\", description: \"Called every frame while the mouse is over the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseUpAsButton\", parameters: \"\", description: \"Called when the user has pressed the mouse button while over the GUIElement or Collider and is still holding down the mouse.\", imports: [] },\n    { name: \"OnApplicationFocus\", parameters: \"hasFocus: boolean\", description: \"Called when the application gains or loses focus.\", imports: [] },\n    { name: \"OnApplicationPause\", parameters: \"pauseStatus: boolean\", description: \"Called when the application is paused or resumed.\", imports: [] },\n    { name: \"OnApplicationQuit\", parameters: \"\", description: \"Called when the application is about to quit.\", imports: [] },\n    { name: \"OnPreRender\", parameters: \"\", description: \"Called before a camera starts rendering the scene.\", imports: [] },\n    { name: \"OnPostRender\", parameters: \"\", description: \"Called after a camera has finished rendering the scene.\", imports: [] },\n    { name: \"OnRenderImage\", parameters: \"source: RenderTexture, destination: RenderTexture\", description: \"Called after all rendering is complete to render image.\", imports: [{ type: \"RenderTexture\", module: \"UnityEngine\" }] },\n    { name: \"OnRenderObject\", parameters: \"\", description: \"Called after camera has rendered the scene.\", imports: [] },\n    { name: \"OnWillRenderObject\", parameters: \"\", description: \"Called once for each camera if the object is visible.\", imports: [] },\n    { name: \"OnPreCull\", parameters: \"\", description: \"Called before the camera culls the scene.\", imports: [] },\n    { name: \"OnAnimatorIK\", parameters: \"layerIndex: number\", description: \"Called right after the Animator has performed IK pass.\", imports: [] },\n    { name: \"OnAnimatorMove\", parameters: \"\", description: \"Called right after the Animator updates.\", imports: [] },\n    { name: \"OnDrawGizmos\", parameters: \"\", description: \"Called when the editor draws gizmos.\", imports: [] },\n    { name: \"OnValidate\", parameters: \"\", description: \"Called when the script is loaded or a value is changed in the inspector.\", imports: [] },\n    // Experience events\n    { name: \"OnExperiencePaused\", parameters: \"\", description: \"Called when the experience is paused.\", imports: [] },\n    { name: \"OnExperienceResumed\", parameters: \"\", description: \"Called when the experience is resumed.\", imports: [] },\n    { name: \"OnExperienceQuit\", parameters: \"\", description: \"Called when the experience is quit.\", imports: [] },\n];\n\nexport const ScriptableObjectAllowedMethods = [\n    \"Awake\",\n    \"OnEnable\",\n    \"OnDisable\",\n    \"OnDestroy\",\n    \"OnValidate\",\n    \"OnApplicationFocus\",\n    \"OnApplicationPause\",\n    \"OnApplicationQuit\",\n    \"OnExperiencePaused\",\n    \"OnExperienceResumed\",\n    \"OnExperienceQuit\"\n]\n","import ts, {CompletionEntryData, ScriptElementKind} from 'typescript/lib/tsserverlibrary';\nimport {ClassDeclaration, Node, Project, SourceFile, SyntaxKind} from 'ts-morph';\nimport {ILanguageServiceFeature} from './ILanguageServiceFeature';\nimport {GeniesScriptType, getGeniesScriptTypeFromType, isGeniesScriptType} from \"../CompilerUtils\";\nimport {ScriptableObjectAllowedMethods, unityLifecycleMethods} from \"./GeniesLifecycleEvents\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\n\ntype getCompletionsAtPosition = (fileName: string, position: number, options: ts.GetCompletionsAtPositionOptions | undefined) => ts.CompletionInfo | undefined;\ntype getCompletionEntryDetails = (fileName: string, position: number, name: string, formatOptions: ts.FormatCodeOptions | ts.FormatCodeSettings | undefined, source: string | undefined, preferences: ts.UserPreferences | undefined, data: CompletionEntryData | undefined) => ts.CompletionEntryDetails | undefined\n\nexport class GeniesLifecycleEventsCompletions implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetCompletionsAtPosition = proxy.getCompletionsAtPosition;\n        proxy.getCompletionsAtPosition = (fileName: string, position: number, options: ts.GetCompletionsAtPositionOptions | undefined): ts.CompletionInfo | undefined => {\n            return this.getCompletionsAtPosition(originalGetCompletionsAtPosition, fileName, position, options);\n        };\n\n        const originalGetCompletionEntryDetails = proxy.getCompletionEntryDetails;\n        proxy.getCompletionEntryDetails = (fileName: string, position: number, name: string, formatOptions: ts.FormatCodeOptions | ts.FormatCodeSettings | undefined, source: string | undefined, preferences: ts.UserPreferences | undefined, data: CompletionEntryData | undefined): ts.CompletionEntryDetails | undefined => {\n            return this.getCompletionEntryDetails(originalGetCompletionEntryDetails, fileName, position, name, formatOptions, source, preferences, data)\n        };\n    }\n\n    getCompletionsAtPosition(previousGetter: getCompletionsAtPosition, fileName: string, position: number, options: ts.GetCompletionsAtPositionOptions | undefined): ts.CompletionInfo | undefined {\n        this.Logger.info(\"Getting completions at position.\");\n\n        const prior = previousGetter(fileName, position, options);\n        const completions: ts.CompletionEntry[] = [];\n\n        const sourceFile = this.context.getSourceFile(fileName);\n        const filteredPriorEntries = prior?.entries.filter(entry => !unityLifecycleMethods.find(a => a.name == entry.name)) ?? [];\n\n        if(sourceFile) {\n            const relevantMethods = this.getRelevantMethods(sourceFile, position);\n            if (relevantMethods) {\n                completions.push(...relevantMethods.map(method => (\n                    {\n                        name: method.name,\n                        kind: ScriptElementKind.memberFunctionElement,\n                        kindModifiers: 'private',\n                        sortText: '0',\n                        insertText: `private ${method.name}(${method.parameters}) {\\n    // ${method.description}\\n}`,\n                        labelDetails: {\n                            description: method.description\n                        },\n                        hasAction: true as const,\n                    })));\n            }\n        }\n\n        this.Logger.info(\"Adding completions for Unity lifecycle methods.\");\n\n        return {\n            isGlobalCompletion: prior?.isGlobalCompletion ?? false,\n            isMemberCompletion: prior?.isMemberCompletion ?? false,\n            isNewIdentifierLocation: prior?.isNewIdentifierLocation ?? false,\n            entries: [\n                ...(filteredPriorEntries ?? []),\n                ...completions\n            ]\n        };\n    }\n\n    getCompletionEntryDetails(previousGetter: getCompletionEntryDetails, fileName: string, position: number, name: string, formatOptions: ts.FormatCodeOptions | ts.FormatCodeSettings | undefined, source: string | undefined, preferences: ts.UserPreferences | undefined, data: CompletionEntryData | undefined): ts.CompletionEntryDetails | undefined {\n        const prior = previousGetter(fileName, position, name, formatOptions, source, preferences, data);\n        if (prior) {\n            return prior;\n        }\n        \n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return prior;\n        }\n\n        const relevantMethods = this.getRelevantMethods(sourceFile, position);\n        if (!relevantMethods) {\n            return prior;\n        }\n\n        const method = relevantMethods.find(m => m.name === name);\n        if (method) {\n            const displayParts: ts.SymbolDisplayPart[] = [\n                {text: \"private\", kind: \"keyword\"},\n                {text: \" \", kind: \"space\"},\n                {text: method.name, kind: \"methodName\"},\n                {text: \"(\", kind: \"punctuation\"},\n            ];\n\n            if (method.parameters) {\n                displayParts.push(\n                    ...method.parameters.split(',').flatMap(param => [\n                        {text: param.split(':')[0].trim(), kind: \"parameterName\"},\n                        {text: \": \", kind: \"punctuation\"},\n                        {text: param.split(':')[1].trim(), kind: \"type\"},\n                        {text: \", \", kind: \"punctuation\"}\n                    ]).slice(0, -1)\n                );\n            }\n\n            displayParts.push(\n                {text: \")\", kind: \"punctuation\"},\n                {text: \" \", kind: \"space\"}\n            );\n\n            const changes = this.createImportChanges(fileName, method.imports);\n\n            return {\n                name: method.name,\n                kind: ScriptElementKind.memberFunctionElement,\n                kindModifiers: 'private',\n                displayParts: displayParts,\n                documentation: [{text: method.description, kind: \"text\"}],\n                tags: [],\n                codeActions: [\n                    {\n                        description: `Add necessary imports for ${method.name}`,\n                        changes: changes\n                    }\n                ]\n            };\n        }\n\n        return undefined;\n    }\n\n    createImportChanges(fileName: string, imports: { type: string, module: string }[]): ts.FileTextChanges[] {\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) return [];\n\n        const changes: ts.FileTextChanges[] = [];\n\n        // Gather existing imports\n        const importMap = new Map<string, Set<string>>();\n        sourceFile.getImportDeclarations().forEach(importDecl => {\n            const moduleSpecifier = importDecl.getModuleSpecifierValue();\n            const namedImports = new Set(importDecl.getNamedImports().map(namedImport => namedImport.getName()));\n            importMap.set(moduleSpecifier, namedImports);\n        });\n\n        // Update or add new imports\n        imports.forEach(imp => {\n            const existingImports = importMap.get(imp.module);\n            if (existingImports) {\n                if (!existingImports.has(imp.type)) {\n                    existingImports.add(imp.type);\n                }\n            } else {\n                importMap.set(imp.module, new Set([imp.type]));\n            }\n        });\n\n        // Convert import map to text changes\n        importMap.forEach((namedImports, moduleSpecifier) => {\n            const existingImport = sourceFile.getImportDeclaration(moduleSpecifier);\n            if (existingImport) {\n                const existingNamedImports = existingImport.getNamedImports().map(namedImport => namedImport.getName());\n                const newImports = Array.from(namedImports).filter(name => !existingNamedImports.includes(name));\n                if (newImports.length > 0) {\n                    const lastNamedImport = existingImport.getNamedImports().pop();\n                    if (lastNamedImport) {\n                        changes.push({\n                            fileName,\n                            textChanges: [{\n                                newText: `, ${newImports.join(', ')}`,\n                                span: {start: lastNamedImport.getEnd(), length: 0}\n                            }]\n                        });\n                    }\n                }\n            } else {\n                changes.push({\n                    fileName,\n                    textChanges: [{\n                        newText: `import { ${Array.from(namedImports).join(', ')} } from '${moduleSpecifier}';\\n`,\n                        span: {start: 0, length: 0}\n                    }]\n                });\n            }\n        });\n\n        return changes;\n    }\n\n    getRelevantMethods(sourceFile: SourceFile, position: number): Array<{\n        description: string;\n        name: string;\n        parameters: string;\n        imports: { type: string; module: string; }[];\n    }> | undefined {\n\n        sourceFile.refreshFromFileSystemSync();\n        \n        let relevantMethods: Array<{\n            description: string;\n            name: string;\n            parameters: string;\n            imports: { type: string; module: string; }[]\n        }> | undefined = undefined;\n        const node = sourceFile.getDescendantAtPos(position);\n        if (node) {\n            const classDeclaration = this.getEnclosingClassDeclaration(node, position);\n\n            // Check if the node is a direct child of the class declaration\n            const parent = node.getParent();\n            if (!parent || parent.getKind() !== SyntaxKind.ClassDeclaration) {\n                return undefined;\n            }\n            \n            if (classDeclaration) {\n                const type = classDeclaration.getType();\n                const geniesScriptType = getGeniesScriptTypeFromType(type);\n\n                if(geniesScriptType === GeniesScriptType.None)\n                {\n                    this.Logger.info(\"No relevant methods found for the script type.\");\n                    return undefined;\n                }\n                \n                const existingMethods = classDeclaration.getMethods().map(m => m.getName());\n                const unusedUnityMethods = unityLifecycleMethods.filter(um => !existingMethods.includes(um.name));\n                \n                if (geniesScriptType === GeniesScriptType.Monobehaviour) {\n                    relevantMethods = unusedUnityMethods;\n                } else if (geniesScriptType === GeniesScriptType.ScriptableObject) {\n                    relevantMethods = unusedUnityMethods.filter(method => ScriptableObjectAllowedMethods.includes(method.name));\n                }\n            }\n        }\n\n        return relevantMethods;\n    }\n\n    getEnclosingClassDeclaration(node: Node, position: number): ClassDeclaration | undefined {\n        let current: Node | undefined = node;\n        while (current) {\n            if (current.getKind() === SyntaxKind.ClassDeclaration) {\n                const classDeclaration = current as ClassDeclaration;\n                const classStart = classDeclaration.getStart();\n                const classEnd = classDeclaration.getEnd();\n                if (classStart <= position && position <= classEnd) {\n                    return classDeclaration;\n                }\n            }\n            current = current.getParent();\n        }\n        return undefined;\n    }\n}\n","import ts, {DiagnosticWithLocation} from 'typescript/lib/tsserverlibrary';\nimport {ILanguageServiceFeature} from './ILanguageServiceFeature';\nimport {unityLifecycleMethods} from './GeniesLifecycleEvents';\nimport {isGeniesScriptType} from \"../CompilerUtils\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\n\nexport class GeniesLifecycleEventsDiagnostics implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetSuggestionDiagnostics = proxy.getSuggestionDiagnostics;\n        proxy.getSuggestionDiagnostics = (fileName: string): ts.DiagnosticWithLocation[] => {\n            const diagnostics = originalGetSuggestionDiagnostics(fileName);\n            return this.getSuggestionDiagnostics(diagnostics, fileName);\n        };\n    }\n\n    private getSuggestionDiagnostics(existingDiagnostics: DiagnosticWithLocation[], fileName: string): DiagnosticWithLocation[] {\n        const sourceFile = this.context.getSourceFile(fileName);\n        if(!sourceFile)\n        {\n            return existingDiagnostics;\n        }\n        \n        const unityMethodNames = new Set(unityLifecycleMethods.map(method => method.name));\n        const specialMethods = sourceFile.getClasses()\n            .filter(cls => isGeniesScriptType(cls.getType()))\n            .flatMap(cls => cls.getMethods())\n            .filter(m => unityMethodNames.has(m.getName()));\n\n        specialMethods.forEach(method => {\n            const diagnosticsToRemove = existingDiagnostics.filter(diagnostic => {\n                return diagnostic.code === 6133 && diagnostic.start === method.getNameNode().getStart();\n            });\n            diagnosticsToRemove.forEach(diagnostic => {\n                const index = existingDiagnostics.indexOf(diagnostic);\n                if (index > -1) {\n                    existingDiagnostics.splice(index, 1);\n                }\n            });\n        });\n\n        return existingDiagnostics;\n    }\n}\n","import ts, { DiagnosticWithLocation} from 'typescript/lib/tsserverlibrary';\nimport {ILanguageServiceFeature} from './ILanguageServiceFeature';\nimport {isGeniesScriptType} from \"../CompilerUtils\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\n\nexport class GeniesScriptTypeDiagnostics implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetSuggestionDiagnostics = proxy.getSuggestionDiagnostics;\n        proxy.getSuggestionDiagnostics = (fileName: string): ts.DiagnosticWithLocation[] => {\n            const diagnostics = originalGetSuggestionDiagnostics(fileName);\n            return this.getSuggestionDiagnostics(diagnostics, fileName);\n        };\n    }\n\n    private getSuggestionDiagnostics(existingDiagnostics: DiagnosticWithLocation[], fileName: string): DiagnosticWithLocation[] {\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return existingDiagnostics;\n        }\n\n        const specialClasses = sourceFile.getClasses()\n            .filter(cls => isGeniesScriptType(cls.getType()));\n\n\n        specialClasses.forEach(cls => {\n            const diagnosticsToRemove = existingDiagnostics.filter(diagnostic => {\n                this.Logger.info(`found class ${cls.getName()} with range ${cls.getStart()} - ${cls.getEnd()}`);\n                this.Logger.info(`Code = ${diagnostic.code}`);\n                this.Logger.info(`Diagnostic start = ${diagnostic.start}`);\n                this.Logger.info(`Diagnostic Message = ${diagnostic.messageText}`);\n                \n                return diagnostic.code === 6196 && diagnostic.start >= cls.getStart() && diagnostic.start <= cls.getEnd();\n            });\n\n            diagnosticsToRemove.forEach(diagnostic => {\n                const index = existingDiagnostics.indexOf(diagnostic);\n                if (index > -1) {\n                    existingDiagnostics.splice(index, 1);\n                }\n            });\n        });\n\n        return existingDiagnostics;\n    }\n\n}\n","import ts from 'typescript/lib/tsserverlibrary';\nimport { Project } from 'ts-morph';\nimport { tss } from './types';\nimport { ILanguageServiceFeature } from \"./ILanguageServiceFeature\";\nimport { GeniesLifecycleEventsCompletions } from \"./GeniesLifecycleEventsCompletions\";\nimport { CSharpOperatorOverloadingSuppress } from \"./CSharpOperatorOverloadingSupress\";\nimport { GeniesLifecycleEventsDiagnostics } from \"./GeniesLifecycleEventsDiagnostics\";\nimport { GeniesScriptTypeDiagnostics } from \"./GeniesScriptTypeDiagnostics\";\nimport { GeniesLSPContext } from \"./GeniesLSPContext\";\nimport { GeniesSemanticDiagnostics } from \"./GeniesInheritanceDiagnostics\";\n\nconst init = (modules: { typescript: tss }) => {\n    let project: Project;\n    let context: GeniesLSPContext;\n\n    function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n        info.project.projectService.logger.info(\"I'm getting set up now! Check the log for this message.\");\n\n        // Create a ts-morph project using the existing tsconfig\n        project = new Project({\n            compilerOptions: info.project.getCompilerOptions(),\n            skipAddingFilesFromTsConfig: true,\n        });\n\n        context = new GeniesLSPContext(project, info);\n\n        const features: ILanguageServiceFeature[] = [\n            new GeniesLifecycleEventsCompletions(context),\n            new CSharpOperatorOverloadingSuppress(context),\n            new GeniesLifecycleEventsDiagnostics(context),\n            new GeniesScriptTypeDiagnostics(context),\n            new GeniesSemanticDiagnostics(context)\n            // Add other features here\n        ];\n\n        const proxy: ts.LanguageService = Object.create(null);\n        for (const k of Object.keys(info.languageService) as Array<keyof ts.LanguageService>) {\n            const x = info.languageService[k]!;\n            //@ts-expect-error\n            proxy[k] = (...args: Array<{}>) => x.apply(info.languageService, args);\n        }\n\n        features.forEach(feature => feature.enhanceProxy(proxy));\n        return proxy;\n    }\n\n    return { create };\n}\n\nexport = init;\n","module.exports = require(\"ts-morph\");","module.exports = require(\"typescript/lib/tsserverlibrary\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(26);\n"],"names":["root","factory","exports","module","define","amd","this","GeniesScriptUiEvents","GeniesScriptType","extendsMonoBehaviour","classDecl","baseClass","getBaseClass","getName","extendsScriptableObject","inheritsFrom","type","baseNames","transformationContext","baseTypes","symbol","getSymbol","declarations","getDeclarations","declaration","Node","isClassDeclaration","heritageClauses","getHeritageClauses","heritageClause","types","getTypeNodes","typeNode","baseType","typeChecker","getTypeAtLocation","push","getBaseTypes","baseTypeName","includes","getFullTypeName","forCsharp","includeArguments","text","aliasSymbol","getAliasSymbol","getText","getIsUnityAPIType","getFullyQualifiedName","replace","isExported","forEach","decl","isInterfaceDeclaration","length","sourceFile","getSourceFile","sourceFilePath","getFilePath","relativePath","convertToAssetsRelativePath","getDirectoryPath","parsedPath","path","parse","filePathWithoutExt","join","dir","name","indexOf","slice","regex","test","typeArguments","getTypeArguments","arg","index","argText","extractProperties","cls","basePath","typeArgumentMap","Map","properties","getProperties","prop","visibility","getScope","decorators","extractDecorators","some","d","Type","SerializeFieldDecorator","NonSerializedDecorator","resolveGenericType","getType","isArray","resolvedType","resolveArrayElementType","typeName","propName","fullPath","getInitializer","expression","getKind","SyntaxKind","NewExpression","newExpression","getArguments","map","initializerExpressions","hasInitializer","initializer","ArrayLiteralExpression","arrayLiteral","i","getElements","element","propertyInfo","Path","Name","TypeName","ChildProperties","IsArray","IsEnum","EnumKeys","EnumValues","Decorators","IsGeniesBehaviourRef","IsGeniesScriptableObjectRef","Initializers","ArrayElementInitializer","undefined","ArrayDimension","dimension","getArrayElementInitializer","fillExtraPropertyInfo","isEnum","isUnityType","getIsUnityAPIDeclaration","geniesScriptType","getGeniesScriptTypeFromNode","Monobehaviour","ScriptableObject","None","keys","values","find","dec","EnumDeclaration","getMembers","member","getValue","extractEnumDetails","value","toString","fillEnumInfo","typeParams","getTypeParameters","typeArgs","newTypeArgumentMap","param","uniqueParamName","set","childProperties","unshift","newBase","underlyingTypeName","propPath","getArrayElementType","currentDimension","isTypeParameter","parentDecl","getParent","uniqueTypeName","has","get","getIsUnityAPISourceFile","firstNode","getFirstChild","console","log","leadingComments","getLeadingCommentRanges","GeniesDeclarationFileAnnotation","ClassDeclaration","isMonobehaviour","isScriptableObject","getGeniesScriptTypeFromType","absolutePath","resolve","assetsPath","relativeToAssets","relative","startsWith","sep","split","getDecorators","Args","a","GeniesInstancePropName","MonobehaviourTypeName","ScriptableObjectTypeName","HideInInspectorDecorator","HeaderDecorator","SpaceDecorator","TooltipDecorator","GET_ITEM_NAME","SET_ITEM_NAME","componentMethods","Set","AllowedUiInterfaces","UiInterfaceToEnumMap","PointerClick","PointerDown","PointerEnter","PointerExit","PointerUp","BeginDrag","Deselect","Drag","Drop","EndDrag","InitializePotentialDrag","Scroll","Select","Submit","UpdateSelected","Move","Cancel","condition","decorator","remove","classDeclaration","resultSet","currentClass","classTypeName","add","getImplements","implementClause","queue","currentIfaceType","shift","ifaceName","Array","from","operatorKind","EqualsEqualsToken","ExclamationEqualsToken","GreaterThanToken","LessThanToken","GreaterThanEqualsToken","LessThanEqualsToken","AmpersandToken","BarToken","PlusToken","MinusToken","SlashToken","PercentToken","AsteriskToken","LessThanLessThanToken","GreaterThanGreaterThanToken","CaretToken","ExclamationToken","TildeToken","PlusPlusToken","MinusMinusToken","operatorMethodName","parameterType","typeSymbol","leftText","rightText","methods","getMethods","filter","m","method","parameters","getParameters","leftParameterType","rightParameterType","getReturnType","TypeFormatFlags","typeModule","scriptType","Error","typeFullyQualifiedName","lastDotIndex","lastIndexOf","substring","existingImport","getImportDeclarations","importDecl","getModuleSpecifierValue","getNamedImports","namedImport","addNamedImport","importStructure","kind","StructureKind","ImportDeclaration","moduleSpecifier","namedImports","addImportDeclaration","argType","gType","directoryPath","importDeclaration","setModuleSpecifier","CUSTOM_DIAGNOSTIC_CODES","ALLOWED_INHERITANCE_TYPES","COMPONENT_METHODS","addDiagnostic","diagnostics","node","messageText","code","start","getStart","getWidth","diagnostic","file","compilerNode","category","DiagnosticCategory","source","getClasses","implementedInterfaces","baseClassName","diagnosticMessage","intf","processClassDiagnostics","getDescendantsOfKind","CallExpression","callExpr","getExpression","methodDeclarations","isPropertyAccessExpression","isIdentifier","methodSymbol","isMethodDeclaration","methodName","getMethodName","callArgTypes","getProject","getTypeChecker","paramType","isTypeAssignableTo","hasMatchingNonGenericOverload","validArgs","typeArgNode","typeArgType","isValidComponentTypeArg","getIsValidUnityGenericTypeArg","processGenericMethodCall","processCallExpressionDiagnostics","newExpr","classDeclarations","expectedTypeArgsCount","providedTypeArgsCount","processTypeUsageDiagnostics","constructor","context","cache","expressionValidity","Logger","enhanceProxy","proxy","originalGetSemanticDiagnostics","getSemanticDiagnostics","fileName","previousGetter","priorDiagnostics","collectExpressions","end","exprStart","exprEnd","valid","clear","binaryExpressions","BinaryExpression","prefixUnaryExpressions","PrefixUnaryExpression","postfixUnaryExpressions","PostfixUnaryExpression","compoundAssignments","getOperatorToken","FirstCompoundAssignment","LastCompoundAssignment","processNode","finalType","getFinalType","getEnd","isBinaryExpression","operatorTokenKind","leftNode","getLeft","rightNode","getRight","leftType","rightType","getOperatorMethodName","leftReturnType","getOperatorMethodReturnType","rightReturnType","isPrefixUnaryExpression","isPostfixUnaryExpression","operand","getOperand","operandType","TypeChecker","getUnaryOperatorMethodReturnType","isLiteral","getBaseTypeOfLiteralType","getGeniesSemanticDiagnostics","existingDiagnostics","newDiagnostics","existingDiag","newDiag","project","info","projectService","logger","addSourceFileAtPath","snapshot","getInMemoryFileContent","languageServiceHost","replaceWithText","languageService","scriptSnapshot","getScriptSnapshot","getLength","unityLifecycleMethods","description","imports","ScriptableObjectAllowedMethods","originalGetCompletionsAtPosition","getCompletionsAtPosition","position","options","originalGetCompletionEntryDetails","getCompletionEntryDetails","formatOptions","preferences","data","prior","completions","filteredPriorEntries","entries","entry","relevantMethods","getRelevantMethods","ScriptElementKind","memberFunctionElement","kindModifiers","sortText","insertText","labelDetails","hasAction","isGlobalCompletion","isMemberCompletion","isNewIdentifierLocation","displayParts","flatMap","trim","changes","createImportChanges","documentation","tags","codeActions","importMap","imp","existingImports","getImportDeclaration","existingNamedImports","newImports","lastNamedImport","pop","textChanges","newText","span","refreshFromFileSystemSync","getDescendantAtPos","getEnclosingClassDeclaration","parent","existingMethods","unusedUnityMethods","um","current","classStart","classEnd","originalGetSuggestionDiagnostics","getSuggestionDiagnostics","unityMethodNames","isGeniesScriptType","getNameNode","splice","modules","create","Project","compilerOptions","getCompilerOptions","skipAddingFilesFromTsConfig","GeniesLSPContext","features","GeniesLifecycleEventsCompletions","CSharpOperatorOverloadingSuppress","GeniesLifecycleEventsDiagnostics","GeniesScriptTypeDiagnostics","GeniesSemanticDiagnostics","Object","k","x","args","apply","feature","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}